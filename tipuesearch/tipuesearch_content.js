var tipuesearch = {"pages":[{"title":" ALPS ","text":"ALPS ALPS is a parallelised numerical code that solves the Vlasov-Maxwell dispersion\nrelation in hot (even relativistic) magnetised plasma. ALPS allows for any\nnumber of particle species with arbitrary gyrotropic equilibrium distribution\nfunctions supporting waves with any direction of propagation with respect to\nthe background magnetic field. If you use the code for a science publication, please provide the code website\non github.com/danielver02/ALPS and cite the code paper: Verscharen, D., Klein, K. G., Chandran, B. D. G., Stevens, M. L., Salem, C. S.,\nand Bale, S. D.: ALPS: the Arbitrary Linear Plasma Solver, J. Plasma Phys. 84,\n905840403, 2018, doi: 10.1017/S0022377818000739 Developer Info Kristopher Klein, Daniel Verscharen","tags":"home","loc":"index.html"},{"title":"scanner – ALPS ","text":"type, public :: scanner Contents Variables range_i range_f log_scan heat_s eigen_s type_s n_out n_res diff diff2 Components Type Visibility Attributes Name Initial double precision, public :: range_i double precision, public :: range_f logical, public :: log_scan logical, public :: heat_s logical, public :: eigen_s integer, public :: type_s integer, public :: n_out integer, public :: n_res double precision, public :: diff double precision, public :: diff2","tags":"","loc":"type/scanner.html"},{"title":"integrate_res_rel – ALPS","text":"public  function integrate_res_rel(om, nn, mode) Uses alps_var Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode Return Value doublecomplex Contents","tags":"","loc":"proc/integrate_res_rel.html"},{"title":"principal_integral_rel – ALPS","text":"public  function principal_integral_rel(sproc_rel, om, nn, mode, igamma, ipparbar_res, upperlimit) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: sproc_rel double complex :: om integer :: nn integer :: mode integer :: igamma integer :: ipparbar_res integer :: upperlimit Return Value doublecomplex Contents","tags":"","loc":"proc/principal_integral_rel.html"},{"title":"landau_integrate_rel – ALPS","text":"public  function landau_integrate_rel(om, nn, mode) Uses alps_var alps_analyt Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode Return Value doublecomplex Contents","tags":"","loc":"proc/landau_integrate_rel.html"},{"title":"int_ee_rel – ALPS","text":"public  function int_ee_rel(om) Uses alps_var Arguments Type Intent Optional Attributes Name double complex :: om Return Value doublecomplex Contents","tags":"","loc":"proc/int_ee_rel.html"},{"title":"resU_rel – ALPS","text":"public  function resU_rel(sproc_rel, om, nn, igamma, ipparbar) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: sproc_rel double complex :: om integer :: nn integer :: igamma integer :: ipparbar Return Value doublecomplex Contents","tags":"","loc":"proc/resu_rel.html"},{"title":"BESSJ – ALPS","text":"public  function BESSJ(N, X) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X Return Value doubleprecision Contents","tags":"","loc":"proc/bessj.html"},{"title":"BESSJ0 – ALPS","text":"public  function BESSJ0(X) Arguments Type Intent Optional Attributes Name real(kind=8) :: X Return Value doubleprecision Contents","tags":"","loc":"proc/bessj0.html"},{"title":"BESSJ1 – ALPS","text":"public  function BESSJ1(X) Arguments Type Intent Optional Attributes Name real(kind=8) :: X Return Value doubleprecision Contents","tags":"","loc":"proc/bessj1.html"},{"title":"Gamma – ALPS","text":"public  function Gamma(xx) Arguments Type Intent Optional Attributes Name double precision :: xx Return Value doubleprecision Contents","tags":"","loc":"proc/gamma.html"},{"title":"derivative_f0_rel – ALPS","text":"public  subroutine derivative_f0_rel(is, is_rel) Uses alps_io alps_var Arguments Type Intent Optional Attributes Name integer :: is integer :: is_rel Contents","tags":"","loc":"proc/derivative_f0_rel.html"},{"title":"polyharmonic_spline – ALPS","text":"public  subroutine polyharmonic_spline(grid_coarse, gamma_coarse, pparbar_coarse, n_coarse, gamma_rel, pparbar, ngamma, npparbar, smoothing, f0_rel, is_rel, nspec_rel) Arguments Type Intent Optional Attributes Name double precision :: grid_coarse (n_coarse) double precision :: gamma_coarse (n_coarse) double precision :: pparbar_coarse (n_coarse) integer :: n_coarse double precision :: gamma_rel (nspec_rel,0:ngamma,0:npparbar) double precision :: pparbar (nspec_rel,0:ngamma,0:npparbar) integer :: ngamma integer :: npparbar double precision :: smoothing double precision :: f0_rel (nspec_rel,0:ngamma,0:npparbar) integer :: is_rel integer :: nspec_rel Contents","tags":"","loc":"proc/polyharmonic_spline.html"},{"title":"CBESSJ – ALPS","text":"public  subroutine CBESSJ(z, nu, z1) Arguments Type Intent Optional Attributes Name double complex :: z integer :: nu double complex :: z1 Contents","tags":"","loc":"proc/cbessj.html"},{"title":"calc_chi – ALPS","text":"public  subroutine calc_chi(chi, j, kz, kperp, x) Uses alps_var Arguments Type Intent Optional Attributes Name double complex :: chi (3,3) integer :: j double precision :: kz double precision :: kperp double complex :: x Contents","tags":"","loc":"proc/calc_chi.html"},{"title":"check_parameters – ALPS","text":"public  subroutine check_parameters() Arguments None Contents None","tags":"","loc":"proc/check_parameters.html"},{"title":"isnancheck – ALPS","text":"public  function isnancheck(input) Arguments Type Intent Optional Attributes Name double precision :: input Return Value logical Contents","tags":"","loc":"proc/isnancheck.html"},{"title":"init_param – ALPS","text":"public  subroutine init_param() Uses alps_var Arguments None Contents None","tags":"","loc":"proc/init_param.html"},{"title":"fit_read – ALPS","text":"public  subroutine fit_read(is, ifit) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: is integer :: ifit Contents","tags":"","loc":"proc/fit_read.html"},{"title":"read_f0 – ALPS","text":"public  subroutine read_f0() Uses alps_var Arguments None Contents None","tags":"","loc":"proc/read_f0.html"},{"title":"get_indexed_double_namelist_unit – ALPS","text":"public  subroutine get_indexed_double_namelist_unit(unit, nml, spec_in, index_in) Uses alps_var Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character(len=*), intent(in) :: nml integer, intent(in) :: spec_in integer, intent(in) :: index_in Contents","tags":"","loc":"proc/get_indexed_double_namelist_unit.html"},{"title":"get_unused_unit – ALPS","text":"public  subroutine get_unused_unit(unit) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit Contents","tags":"","loc":"proc/get_unused_unit.html"},{"title":"alps_error_init – ALPS","text":"public  subroutine alps_error_init() Uses alps_var Arguments None Contents None","tags":"","loc":"proc/alps_error_init.html"},{"title":"alps_error – ALPS","text":"public  subroutine alps_error(error_id) Uses mpi alps_var Arguments Type Intent Optional Attributes Name integer :: error_id Contents","tags":"","loc":"proc/alps_error.html"},{"title":"output_time – ALPS","text":"public  subroutine output_time() Arguments None Contents None","tags":"","loc":"proc/output_time.html"},{"title":"display_credits – ALPS","text":"public  subroutine display_credits() Arguments None Contents None","tags":"","loc":"proc/display_credits.html"},{"title":"pass_instructions – ALPS","text":"public  subroutine pass_instructions() Uses mpi alps_var Arguments None Contents None","tags":"","loc":"proc/pass_instructions.html"},{"title":"pass_distribution – ALPS","text":"public  subroutine pass_distribution() Uses mpi alps_var Arguments None Contents None","tags":"","loc":"proc/pass_distribution.html"},{"title":"eval_fit – ALPS","text":"public  function eval_fit(is, iperp, ppar_valC) Uses alps_distribution_analyt alps_var This function evaluates the fit to f0 at and the complex parallel\nmomentum eval_fit . It requires the fit parameters that will be determined\nby the subroutine determine_param_fit . Arguments Type Intent Optional Attributes Name integer :: is integer :: iperp double complex :: ppar_valC Return Value doublecomplex Contents","tags":"","loc":"proc/eval_fit.html"},{"title":"determine_param_fit – ALPS","text":"public  subroutine determine_param_fit() Uses alps_var Arguments None Contents None","tags":"","loc":"proc/determine_param_fit.html"},{"title":"alps_fns_rel – ALPS","text":"FUNCTION  GAMMA(X)            * --------------------------------------- *\n Returns the value of Gamma(x) in double *\n precision as EXP(LN(GAMMA(X))) for X>0. * Contents Functions integrate_res_rel principal_integral_rel landau_integrate_rel int_ee_rel resU_rel BESSJ BESSJ0 BESSJ1 Gamma Subroutines derivative_f0_rel polyharmonic_spline CBESSJ Functions public  function integrate_res_rel (om, nn, mode) Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode Return Value doublecomplex public  function principal_integral_rel (sproc_rel, om, nn, mode, igamma, ipparbar_res, upperlimit) Arguments Type Intent Optional Attributes Name integer :: sproc_rel double complex :: om integer :: nn integer :: mode integer :: igamma integer :: ipparbar_res integer :: upperlimit Return Value doublecomplex public  function landau_integrate_rel (om, nn, mode) Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode Return Value doublecomplex public  function int_ee_rel (om) Arguments Type Intent Optional Attributes Name double complex :: om Return Value doublecomplex public  function resU_rel (sproc_rel, om, nn, igamma, ipparbar) Arguments Type Intent Optional Attributes Name integer :: sproc_rel double complex :: om integer :: nn integer :: igamma integer :: ipparbar Return Value doublecomplex public  function BESSJ (N, X) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X Return Value doubleprecision public  function BESSJ0 (X) Arguments Type Intent Optional Attributes Name real(kind=8) :: X Return Value doubleprecision public  function BESSJ1 (X) Arguments Type Intent Optional Attributes Name real(kind=8) :: X Return Value doubleprecision public  function Gamma (xx) Arguments Type Intent Optional Attributes Name double precision :: xx Return Value doubleprecision Subroutines public  subroutine derivative_f0_rel (is, is_rel) Arguments Type Intent Optional Attributes Name integer :: is integer :: is_rel public  subroutine polyharmonic_spline (grid_coarse, gamma_coarse, pparbar_coarse, n_coarse, gamma_rel, pparbar, ngamma, npparbar, smoothing, f0_rel, is_rel, nspec_rel) Arguments Type Intent Optional Attributes Name double precision :: grid_coarse (n_coarse) double precision :: gamma_coarse (n_coarse) double precision :: pparbar_coarse (n_coarse) integer :: n_coarse double precision :: gamma_rel (nspec_rel,0:ngamma,0:npparbar) double precision :: pparbar (nspec_rel,0:ngamma,0:npparbar) integer :: ngamma integer :: npparbar double precision :: smoothing double precision :: f0_rel (nspec_rel,0:ngamma,0:npparbar) integer :: is_rel integer :: nspec_rel public  subroutine CBESSJ (z, nu, z1) Arguments Type Intent Optional Attributes Name double complex :: z integer :: nu double complex :: z1","tags":"","loc":"module/alps_fns_rel.html"},{"title":"alps_nhds – ALPS","text":"* Program to calculate the first kind modified Bessel function of * integer order N , for any REAL X , using the function BESSI ( N , X ) . * * -------------------------------------------------------------------- *\n -------------------------------------------------------------------- *\n   Reference: From Numath Library By Tuan Dang Trong in Fortran 77.   *\n                                                                      *\n                               F90 Release 1.1 By J-P Moreau, Paris.  *\n                                                                      *\n   Version 1.1: corected value of P4 in BESSIO (P4=1.2067492 and not  *\n                1.2067429) Aug. 2011.                                 * Contents Subroutines calc_chi Subroutines public  subroutine calc_chi (chi, j, kz, kperp, x) Arguments Type Intent Optional Attributes Name double complex :: chi (3,3) integer :: j double precision :: kz double precision :: kperp double complex :: x","tags":"","loc":"module/alps_nhds.html"},{"title":"alps_check – ALPS","text":"Contents Subroutines check_parameters Subroutines public  subroutine check_parameters () Arguments None","tags":"","loc":"module/alps_check.html"},{"title":"alps_io – ALPS","text":"Contents Variables unit stdout_unit input_unit_no error_unit_no Functions isnancheck Subroutines init_param fit_read read_f0 get_indexed_double_namelist_unit get_unused_unit alps_error_init alps_error output_time display_credits Variables Type Visibility Attributes Name Initial integer, public :: unit integer, public, parameter :: stdout_unit = 6 integer, public, save :: input_unit_no integer, public, save :: error_unit_no = stdout_unit Functions public  function isnancheck (input) Arguments Type Intent Optional Attributes Name double precision :: input Return Value logical Subroutines public  subroutine init_param () Arguments None public  subroutine fit_read (is, ifit) Arguments Type Intent Optional Attributes Name integer :: is integer :: ifit public  subroutine read_f0 () Arguments None public  subroutine get_indexed_double_namelist_unit (unit, nml, spec_in, index_in) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character(len=*), intent(in) :: nml integer, intent(in) :: spec_in integer, intent(in) :: index_in public  subroutine get_unused_unit (unit) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit public  subroutine alps_error_init () Arguments None public  subroutine alps_error (error_id) Arguments Type Intent Optional Attributes Name integer :: error_id public  subroutine output_time () Arguments None public  subroutine display_credits () Arguments None","tags":"","loc":"module/alps_io.html"},{"title":"alps_com – ALPS","text":"Contents Subroutines pass_instructions pass_distribution Subroutines public  subroutine pass_instructions () Arguments None public  subroutine pass_distribution () Arguments None","tags":"","loc":"module/alps_com.html"},{"title":"alps_analyt – ALPS","text":"This module contains functions and subroutines for the hybrid analytical continuation. Contents Functions eval_fit Subroutines determine_param_fit Functions public  function eval_fit (is, iperp, ppar_valC) This function evaluates the fit to f0 at and the complex parallel\nmomentum eval_fit . It requires the fit parameters that will be determined\nby the subroutine determine_param_fit . Arguments Type Intent Optional Attributes Name integer :: is integer :: iperp double complex :: ppar_valC Return Value doublecomplex Subroutines public  subroutine determine_param_fit () Arguments None","tags":"","loc":"module/alps_analyt.html"},{"title":"alps_var – ALPS","text":"Uses mpi Contents Variables runname foldername option nroots nroots_max use_map writeOut unit_error nproc iproc proc0 ierror kperp kpar vA Bessel_zero nspec nspec_rel wroots numroots omi omf gami gamf loggridw loggridg ni nr nperp npar ngamma npparbar positions_principal Tlim sproc numiter D_threshold D_prec D_gap pi arrayName f0 f0_rel df0 df0_rel pp gamma_rel pparbar_rel nmax nlim ns qs ms relativistic wave chi0 bessel_array n_fits fit_type maxsteps_fit lambda_initial_fit lambdafac_fit epsilon_fit param_fit perp_correction fit_check determine_minima n_resonance_interval scan_option n_scan logfit usebM bMnmaxs bMBessel_zeros bMbetas bMalphas bMpdrifts scan kperp_last kpar_last kperp_0 kpar_0 Derived Types scanner Variables Type Visibility Attributes Name Initial character(len=500), public :: runname character(len=500), public :: foldername integer, public :: option integer, public :: nroots integer, public :: nroots_max logical, public :: use_map logical, public :: writeOut = .true. integer, public :: unit_error integer, public :: nproc integer, public :: iproc logical, public :: proc0 integer, public :: ierror double precision, public :: kperp double precision, public :: kpar double precision, public :: vA double precision, public :: Bessel_zero = 1.d-45 integer, public :: nspec integer, public :: nspec_rel double complex, public, dimension(:), allocatable :: wroots integer, public :: numroots = 100 double precision, public :: omi double precision, public :: omf double precision, public :: gami double precision, public :: gamf logical, public :: loggridw logical, public :: loggridg integer, public :: ni = 128 integer, public :: nr = 128 integer, public :: nperp integer, public :: npar integer, public :: ngamma = 100 integer, public :: npparbar = 200 integer, public :: positions_principal = 5 double precision, public :: Tlim = 0.01d0 integer, public :: sproc integer, public :: numiter = 50 double precision, public :: D_threshold = 1.d-5 double precision, public :: D_prec = 1.d-5 double precision, public :: D_gap = 1.d-5 double precision, public :: pi character(len=75), public :: arrayName double precision, public, dimension(:,:,:), allocatable :: f0 double precision, public, dimension(:,:,:), allocatable :: f0_rel double precision, public, dimension(:,:,:,:), allocatable :: df0 double precision, public, dimension(:,:,:,:), allocatable :: df0_rel double precision, public, dimension(:,:,:,:), allocatable :: pp double precision, public, dimension(:,:,:), allocatable :: gamma_rel double precision, public, dimension(:,:,:), allocatable :: pparbar_rel integer, public, dimension(:), allocatable :: nmax integer, public :: nlim (2) double precision, public, dimension(:), allocatable :: ns double precision, public, dimension(:), allocatable :: qs double precision, public, dimension(:), allocatable :: ms logical, public, dimension(:), allocatable :: relativistic double complex, public, dimension(:,:), allocatable :: wave double complex, public, dimension(:,:,:), allocatable :: chi0 double precision, public, dimension(:,:), allocatable :: bessel_array integer, public, dimension(:), allocatable :: n_fits integer, public, dimension(:,:), allocatable :: fit_type integer, public :: maxsteps_fit = 500 double precision, public :: lambda_initial_fit = 1.d0 double precision, public :: lambdafac_fit = 1.d1 double precision, public :: epsilon_fit = 1.d-8 double precision, public, dimension(:,:,:,:), allocatable :: param_fit double precision, public, dimension(:,:), allocatable :: perp_correction logical, public :: fit_check = .true. logical, public :: determine_minima = .true. integer, public :: n_resonance_interval = 100 integer, public :: scan_option = 1 integer, public :: n_scan = 0 logical, public, dimension(:), allocatable :: logfit logical, public, dimension(:), allocatable :: usebM integer, public, dimension(:), allocatable :: bMnmaxs double precision, public, dimension(:), allocatable :: bMBessel_zeros double precision, public, dimension(:), allocatable :: bMbetas double precision, public, dimension(:), allocatable :: bMalphas double precision, public, dimension(:), allocatable :: bMpdrifts type( scanner ), public, dimension (:), allocatable :: scan double precision, public :: kperp_last double precision, public :: kpar_last double precision, public :: kperp_0 double precision, public :: kpar_0 Derived Types type, public :: scanner Components Type Visibility Attributes Name Initial double precision, public :: range_i double precision, public :: range_f logical, public :: log_scan logical, public :: heat_s logical, public :: eigen_s integer, public :: type_s integer, public :: n_out integer, public :: n_res double precision, public :: diff double precision, public :: diff2","tags":"","loc":"module/alps_var.html"},{"title":"alps – ALPS","text":"Uses alps_com alps_io alps_check alps_analyt mpi alps_fns alps_var Contents Variables ik Variables Type Attributes Name Initial integer :: ik","tags":"","loc":"program/alps.html"},{"title":"ALPS_fns_rel.f90 – ALPS","text":"Contents Modules alps_fns_rel Source Code ALPS_fns_rel.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_fns_rel implicit none private :: int_T_rel , int_T_res_rel , integrate_resU_rel private :: funct_g_rel private :: determine_sproc_rel , fact public :: derivative_f0_rel , polyharmonic_spline public :: integrate_res_rel , landau_integrate_rel , resU_rel public :: bessj0 , bessj1 , bessj contains !-=-=-=-=-=-= subroutine derivative_f0_rel ( is , is_rel ) use alps_var , only : f0 , pp , nperp , npar , vA , ms , writeOut , arrayName use alps_var , only : f0_rel , df0_rel , gamma_rel , pparbar_rel , nspec_rel , ngamma , npparbar use alps_var , only : writeOut , pi use alps_io , only : get_unused_unit implicit none integer :: is , is_rel , n_coarse , counter , igamma , ipparbar , iperp , ipar double precision :: pparbar_max , pparbar_min , gamma_max , gamma_min , gamma_max_use , dgamma , dpparbar double precision , allocatable , dimension (:) :: gamma_coarse , pparbar_coarse , grid_coarse character ( 50 ) :: fmt !Output format character ( 100 ) :: writename double precision :: integrate , gamma , smoothing integer :: unit_f ! Determine the minimum and maximum values of Gamma and ppar pparbar_min = 99999 9.d0 pparbar_max =- 99999 9.d0 gamma_min = 99999 9.d0 gamma_max =- 1.d0 do iperp = 0 , nperp do ipar = 0 , npar gamma = sqrt (( pp ( is , iperp , ipar , 1 ) ** 2 + pp ( is , iperp , ipar , 2 ) ** 2 ) * vA ** 2 / ms ( is ) ** 2 + 1.d0 ) if ( gamma . GT . gamma_max ) gamma_max = gamma if ( gamma . LT . gamma_min ) gamma_min = gamma if ( pp ( is , iperp , ipar , 2 ). LT . pparbar_min ) pparbar_min = pp ( is , iperp , ipar , 2 ) if ( pp ( is , iperp , ipar , 2 ). GT . pparbar_max ) pparbar_max = pp ( is , iperp , ipar , 2 ) enddo enddo pparbar_min = pparbar_min * vA / ms ( is ) pparbar_max = pparbar_max * vA / ms ( is ) gamma_max_use = sqrt ( 1.d0 + pp ( is , nperp , 1 , 1 ) ** 2 * vA ** 2 / ms ( is ) ** 2 ) if ( writeOut ) then write ( * , '(a,i3,a,1es14.4)' ) \"Maximum Gamma for species\" , is , \":\" , gamma_max write ( * , '(a,i3,a,1es14.4)' ) \"Minimum Gamma for species\" , is , \":\" , gamma_min write ( * , '(a,i3,a,1es14.4)' ) \"Maximum Pparbar: for species\" , is , \":\" , pparbar_max write ( * , '(a,i3,a,1es14.4)' ) \"Minimum Pparbar: for species\" , is , \":\" , pparbar_min write ( * , '(a,i3,a,1es14.4)' ) \"Usable Maximum Gamma for species\" , is , \":\" , gamma_max_use endif smoothing = 0.d0 !0.001d0! make this a user-defined parameter ? n_coarse = ( nperp + 1 ) * ( npar + 1 ) ! This has to be (nperp+2)*(npar+1) if we include a line of zeroes allocate ( gamma_coarse ( n_coarse )) allocate ( pparbar_coarse ( n_coarse )) allocate ( grid_coarse ( n_coarse )) counter = 0 do iperp = 0 , nperp do ipar = 0 , npar counter = counter + 1 gamma_coarse ( counter ) = sqrt ( 1.d0 + ( pp ( is , iperp , ipar , 1 ) ** 2 + pp ( is , iperp , ipar , 2 ) ** 2 ) * & vA * vA / ( ms ( is ) * ms ( is ))) pparbar_coarse ( counter ) = pp ( is , iperp , ipar , 2 ) * vA / ms ( is ) grid_coarse ( counter ) = log ( f0 ( is , iperp , ipar )) enddo enddo ! add a line of zeroes at the end: !\tdo ipar = 0, npar !\t\tcounter=counter+1 !\t\tgamma_coarse(counter)=gamma_max+(gamma_max-gamma_min)/(1.d0*ngamma) !\t\tpparbar_coarse(counter)=pp(is,nperp,ipar,2)*vA/ms(is) !\t\tgrid_coarse(counter)=0.d0 !\tenddo do igamma = 0 , ngamma do ipparbar = 0 , npparbar gamma_rel ( is_rel , igamma , ipparbar ) = gamma_min + (( gamma_max_use - gamma_min ) * igamma ) / ( 1.d0 * ngamma ) pparbar_rel ( is_rel , igamma , ipparbar ) = pparbar_min + (( pparbar_max - pparbar_min ) * ipparbar ) / ( 1.d0 * npparbar ) enddo enddo if ( writeOut ) write ( * , '(a)' ) 'Polyharmonic spline interpolation on relativistic grid...' call polyharmonic_spline ( grid_coarse , gamma_coarse , pparbar_coarse , n_coarse , gamma_rel , pparbar_rel ,& ngamma , npparbar , smoothing , f0_rel , is_rel , nspec_rel ) ! Stay within the subluminal cone do igamma = 0 , ngamma do ipparbar = 0 , npparbar f0_rel ( is_rel , igamma , ipparbar ) = exp ( f0_rel ( is_rel , igamma , ipparbar )) if (( gamma_rel ( is_rel , igamma , ipparbar ) ** 2 - 1.d0 ). LT .( pparbar_rel ( is_rel , igamma , ipparbar ) ** 2 ))& f0_rel ( is_rel , igamma , ipparbar ) =- 1.d0 enddo enddo integrate = 0.d0 dgamma = gamma_rel ( is_rel , 2 , 2 ) - gamma_rel ( is_rel , 1 , 2 ) dpparbar = pparbar_rel ( is_rel , 2 , 2 ) - pparbar_rel ( is_rel , 2 , 1 ) do igamma = 0 , ngamma do ipparbar = 0 , npparbar if ( f0_rel ( is_rel , igamma , ipparbar ). GT . - 1.d0 ) then integrate = integrate + & gamma_rel ( is_rel , igamma , ipparbar ) * f0_rel ( is_rel , igamma , ipparbar ) * & 2.d0 * pi * dgamma * dpparbar * ( ms ( is ) / vA ) ** 3 endif enddo enddo write ( * , '(a,i3,a, 2es14.4)' ) 'Integration of species' , is , ':' , integrate if ( writeOut ) write ( * , '(a)' ) 'Writing relativistic grid to file...' write ( fmt , '(a)' ) '(2es14.4,1es14.4)' write ( writeName , '(3a,i0,a)' ) 'distribution/' , trim ( arrayName ), '_f0_rel.' , is , '.array' call get_unused_unit ( unit_f ) open ( unit = unit_f , file = trim ( writeName ), status = 'replace' ) do igamma = 0 , ngamma do ipparbar = 0 , npparbar if ( f0_rel ( is_rel , igamma , ipparbar ). NE . - 1.d0 ) f0_rel ( is_rel , igamma , ipparbar ) = f0_rel ( is_rel , igamma , ipparbar ) / integrate write ( unit_f , fmt ) gamma_rel ( is_rel , igamma , ipparbar ), pparbar_rel ( is_rel , igamma , ipparbar ),& f0_rel ( is_rel , igamma , ipparbar ) enddo write ( unit_f , * ) enddo close ( unit_f ) if ( writeOut ) write ( * , '(a)' ) 'Determining relativistic derivatives...' do igamma = 1 , ngamma - 1 do ipparbar = 1 , npparbar - 1 !index 1-> gamma derivative df0_rel ( is_rel , igamma , ipparbar , 1 ) = 0.d0 if (( f0_rel ( is_rel , igamma - 1 , ipparbar ). GT . 0.d0 ). AND .( f0_rel ( is_rel , igamma + 1 , ipparbar ). GT . 0.d0 )) then df0_rel ( is_rel , igamma , ipparbar , 1 ) = & ( f0_rel ( is_rel , igamma + 1 , ipparbar ) - f0_rel ( is_rel , igamma - 1 , ipparbar )) / & ( gamma_rel ( is_rel , igamma + 1 , ipparbar ) - gamma_rel ( is_rel , igamma - 1 , ipparbar )) endif !index 2-> pparbar derivative df0_rel ( is_rel , igamma , ipparbar , 2 ) = 0.d0 if (( f0_rel ( is_rel , igamma , ipparbar + 1 ). GT . 0.d0 ). AND .( f0_rel ( is_rel , igamma , ipparbar - 1 ). GT . 0.d0 )) then df0_rel ( is_rel , igamma , ipparbar , 2 ) = & ( f0_rel ( is_rel , igamma , ipparbar + 1 ) - f0_rel ( is_rel , igamma , ipparbar - 1 )) / & ( pparbar_rel ( is_rel , igamma , ipparbar + 1 ) - pparbar_rel ( is_rel , igamma , ipparbar - 1 )) endif if ( f0_rel ( is_rel , igamma , ipparbar ). GE . 0.d0 ) then if (( f0_rel ( is_rel , igamma , ipparbar + 1 ). LE . 0.d0 ). AND .( f0_rel ( is_rel , igamma , ipparbar - 1 ). GT . 0.d0 )) then df0_rel ( is_rel , igamma , ipparbar , 2 ) = & ( f0_rel ( is_rel , igamma , ipparbar ) - f0_rel ( is_rel , igamma , ipparbar - 1 )) / & ( pparbar_rel ( is_rel , igamma , ipparbar ) - pparbar_rel ( is_rel , igamma , ipparbar - 1 )) endif if (( f0_rel ( is_rel , igamma , ipparbar + 1 ). GT . 0.d0 ). AND .( f0_rel ( is_rel , igamma , ipparbar - 1 ). LE . 0.d0 )) then df0_rel ( is_rel , igamma , ipparbar , 2 ) = & ( f0_rel ( is_rel , igamma , ipparbar + 1 ) - f0_rel ( is_rel , igamma , ipparbar )) / & ( pparbar_rel ( is_rel , igamma , ipparbar + 1 ) - pparbar_rel ( is_rel , igamma , ipparbar )) endif endif enddo enddo if ( writeOut ) write ( * , '(a)' ) 'Writing relativistic derivatives to file...' write ( fmt , '(a)' ) '(2es14.4,2es14.4)' write ( writeName , '(3a,i0,a)' ) 'distribution/' , trim ( arrayName ), '_dfdv_rel.' , is , '.array' call get_unused_unit ( unit_f ) open ( unit = unit_f , file = trim ( writeName ), status = 'replace' ) do igamma = 0 , ngamma do ipparbar = 0 , npparbar write ( unit_f , fmt ) gamma_rel ( is_rel , igamma , ipparbar ), pparbar_rel ( is_rel , igamma , ipparbar ),& df0_rel ( is_rel , igamma , ipparbar , 1 ), df0_rel ( is_rel , igamma , ipparbar , 2 ) enddo write ( unit_f , * ) enddo close ( unit_f ) if ( writeOut ) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' end subroutine derivative_f0_rel ! Polyharmonic Spline for relativistic calculation: subroutine polyharmonic_spline ( grid_coarse , gamma_coarse , pparbar_coarse , n_coarse , gamma_rel , pparbar , ngamma , npparbar ,& smoothing , f0_rel , is_rel , nspec_rel ) ! ! This soubroutine interpolates the grid with a polyharmonic thin-plate spline. ! ! Input: ! grid_coarse is a vector of length n_coarse that includes the values of f at each point i ! gamma_coarse is a vector of length n_coarse that includes the values of gamma at each point i ! pparbar_coarse is a vector of length n_coarse that includes the values of ppar at each point i ! n_coarse is the total number of points in the coarse grid (ngamma_coarse * npparbar_coarse) ! ! gamma_rel is the value of gamma in the fine grid. It is a field of rank (ngamma, npparbar) ! pparbar is the value of ppar in the fine grid. It is a field of rank (ngamma, npparbar) ! ngamma is the number of perpendicular data points in the fine grid ! npparbar is the number of parallel data points in the fine grid ! ! ! Output: ! f0_rel is the interpolated grid. It is a field of rank (ngamma, npparbar) ! ! This subroutine needs the LUPACK and BLAS libraries to evoke the dgesv subroutine\t! ! This is the Thin Plate Spline: ! We use these resources: ! http://cseweb.ucsd.edu/~sjb/eccv_tps.pdf ! http://www.univie.ac.at/nuhag-php/bibtex/open_files/po94_M%20J%20D%20Powell%2003%2093.pdf ! http://vision.ucsd.edu/sites/default/files/fulltext(4).pdf implicit none integer :: i , j , k , permutation_index ( n_coarse + 3 ) integer :: ngamma , npparbar , n_coarse , is_rel , nspec_rel double precision :: gamma_coarse ( n_coarse ), pparbar_coarse ( n_coarse ) double precision :: grid_coarse ( n_coarse ), f0_rel ( nspec_rel , 0 : ngamma , 0 : npparbar ) double precision :: fullmatrix ( n_coarse + 3 , n_coarse + 3 ) double precision :: grid_vector ( n_coarse + 3 ), weight_param ( n_coarse + 3 ) double precision :: gamma_rel ( nspec_rel , 0 : ngamma , 0 : npparbar ), pparbar ( nspec_rel , 0 : ngamma , 0 : npparbar ) double precision :: r , smoothing double precision :: INFO grid_vector = 0.d0 do i = 1 , n_coarse grid_vector ( i ) = grid_coarse ( i ) enddo ! grid_vector has three additional entries. The last three entries are all zero. fullmatrix = 0.d0 do i = 1 , n_coarse do j = 1 , n_coarse ! Do the K-matrix part first: r = sqrt (( gamma_coarse ( i ) - gamma_coarse ( j )) ** 2 + ( pparbar_coarse ( i ) - pparbar_coarse ( j )) ** 2 ) if ( r . GE . 1.d0 ) then fullmatrix ( i , j ) = r * r * log ( r ) elseif ( r . EQ . 0.d0 ) then fullmatrix ( i , j ) = 0.d0 else fullmatrix ( i , j ) = r * log ( r ** r ) endif enddo fullmatrix ( i , i ) = fullmatrix ( i , i ) + smoothing ! Now the P-matrix parts: fullmatrix ( i , n_coarse + 1 ) = 1.d0 fullmatrix ( i , n_coarse + 2 ) = gamma_coarse ( i ) fullmatrix ( i , n_coarse + 3 ) = pparbar_coarse ( i ) ! and the transposed P-matrix: fullmatrix ( n_coarse + 1 , i ) = 1.d0 fullmatrix ( n_coarse + 2 , i ) = gamma_coarse ( i ) fullmatrix ( n_coarse + 3 , i ) = pparbar_coarse ( i ) enddo weight_param = grid_vector call dgesv ( n_coarse + 3 , 1 , fullmatrix , n_coarse + 3 , permutation_index , weight_param , n_coarse + 3 , INFO ) f0_rel ( is_rel ,:,:) = 0.d0 do i = 0 , ngamma do j = 0 , npparbar do k = 1 , n_coarse r = sqrt (( gamma_rel ( is_rel , i , j ) - gamma_coarse ( k )) ** 2 + ( pparbar ( is_rel , i , j ) - pparbar_coarse ( k )) ** 2 ) if ( r . GE . 1.d0 ) then f0_rel ( is_rel , i , j ) = f0_rel ( is_rel , i , j ) + weight_param ( k ) * r * r * log ( r ) elseif ( r . EQ . 0.d0 ) then f0_rel ( is_rel , i , j ) = f0_rel ( is_rel , i , j ) else f0_rel ( is_rel , i , j ) = f0_rel ( is_rel , i , j ) + weight_param ( k ) * r * log ( r ** r ) endif enddo f0_rel ( is_rel , i , j ) = f0_rel ( is_rel , i , j ) + weight_param ( n_coarse + 1 ) + & weight_param ( n_coarse + 2 ) * gamma_rel ( is_rel , i , j ) + weight_param ( n_coarse + 3 ) * pparbar ( is_rel , i , j ) enddo enddo end subroutine !-=-=-=-=-=-= ! !-=-=-=-=-=-= ! This subroutine determines sproc_rel for the given process subroutine determine_sproc_rel ( sproc_rel ) use alps_var , only : relativistic , sproc , nspec integer :: is_rel , is , sproc_rel is_rel = 0 do is = 1 , nspec if ( relativistic ( is )) then is_rel = is_rel + 1 if ( is . EQ . sproc ) sproc_rel = is_rel endif enddo end subroutine ! This function does the relativistic integration around resonances if necessary: double complex function integrate_res_rel ( om , nn , mode ) use alps_var , only : ngamma , gamma_rel , pparbar_rel implicit none integer :: igamma integer :: nn , mode , sproc_rel double precision :: dgamma , dpparbar double complex :: ii , om integrate_res_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) call determine_sproc_rel ( sproc_rel ) dgamma = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ! At igamma=1, we are already missing the part from igamma=0, where we should actually start. ! Therefore, we use 2 instead of 1 in the trapezoid integration: do igamma = 1 , ngamma - 2 integrate_res_rel = integrate_res_rel + 2.d0 * integrate_resU_rel ( sproc_rel , om , nn , mode , igamma ) enddo igamma = ngamma - 1 integrate_res_rel = integrate_res_rel + integrate_resU_rel ( sproc_rel , om , nn , mode , igamma ) integrate_res_rel = integrate_res_rel * dgamma * 0.25d0 return end function integrate_res_rel ! This function performs the integration of the resU term in (gamma,pparbar) space at a constant igamma double complex function integrate_resU_rel ( sproc_rel , om , nn , mode , igamma ) use alps_var , only : npparbar , sproc , positions_principal , f0_rel , kpar , vA , ms , qs use alps_var , only : gamma_rel , pparbar_rel use alps_io , only : alps_error implicit none integer :: igamma , ipparbar , int_start , int_end integer :: nn , mode , ipparbar_res , sproc_rel , lowerlimit , upperlimit , ipparbar_lower , ipparbar_upper double precision :: dgamma , dpparbar double complex :: ii , om , pparbar_res logical :: found_res , found_lower , found_upper integrate_resU_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) dgamma = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ! determine the position of the resonance (i.e., the step LEFT of it): ipparbar = 0 ipparbar_res = 0 found_res = . FALSE . pparbar_res = ( gamma_rel ( sproc_rel , igamma , 1 ) * om - ( 1.d0 * nn ) * qs ( sproc ) / ms ( sproc )) * vA / kpar if (( real ( pparbar_res ) ** 2 ). LE .( gamma_rel ( sproc_rel , igamma , 1 ) ** 2 - 1.d0 )) then do while (( ipparbar . LT .( npparbar - 2 )). AND .(. NOT . found_res )) ipparbar = ipparbar + 1 if (( pparbar_rel ( sproc_rel , 2 , ipparbar + 1 ). GT . real ( pparbar_res )). and .& ( pparbar_rel ( sproc_rel , 2 , ipparbar ). LE . real ( pparbar_res ))) then ipparbar_res = ipparbar found_res = . TRUE . endif enddo endif ! Handle resonances that are right outside the integration domain: do ipparbar = 0 , positions_principal if (( real ( pparbar_res ). GE .( pparbar_rel ( sproc_rel , 2 , 0 ) - dpparbar * ipparbar )). AND .& ( real ( pparbar_res ). LT .( pparbar_rel ( sproc_rel , 2 , 0 ) - dpparbar * ( ipparbar - 1 )))) then ipparbar_res = - ipparbar found_res = . TRUE . endif if (( real ( pparbar_res ). GE .( pparbar_rel ( sproc_rel , 2 , npparbar - 1 ) + dpparbar * ipparbar )). AND .& ( real ( pparbar_res ). LT .( pparbar_rel ( sproc_rel , 2 , npparbar - 1 ) + dpparbar * ( ipparbar + 1 )))) then ipparbar_res = npparbar - 1 + ipparbar found_res = . TRUE . endif enddo ! determine the limits for the integration: ! What are the relevant ranges in pparbar: found_lower = . FALSE . found_upper = . FALSE . ipparbar_lower = 1 ipparbar_upper = npparbar - 1 do ipparbar = 1 , npparbar - 1 if ((. NOT . found_lower ). AND .( f0_rel ( sproc_rel , igamma , ipparbar - 1 ). LE . - 1.d0 ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 )) then ipparbar_lower = ipparbar found_lower = . TRUE . endif if ((. NOT . found_upper ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 ). AND .( f0_rel ( sproc_rel , igamma , ipparbar + 1 ). LE . - 1.d0 )) then ipparbar_upper = ipparbar found_upper = . TRUE . endif enddo ! define int_start, int_end, lowerlimit, and upperlimit: if ( found_res ) then ! These four are in general correct: int_start = ipparbar_lower int_end = ipparbar_upper lowerlimit = ipparbar_res - positions_principal upperlimit = ipparbar_res + positions_principal + 1 if (( ipparbar_res . GE . 0 ). and .( ipparbar_res . LE . npparbar )) then if ( abs ( real ( pparbar_res ) - pparbar_rel ( sproc_rel , 2 , ipparbar_res )). GT .( 0.5d0 * dpparbar )) upperlimit = upperlimit + 1 endif ! But there are special circumstances: if (( lowerlimit . LT . ipparbar_lower ). AND .( upperlimit . GT . ipparbar_upper )) then call alps_error ( 8 ) elseif ( lowerlimit . LE . ipparbar_lower ) then ! resonance outside or near the left end of the subluminal cone int_start = 1 lowerlimit = 0 !upperlimit = max(upperlimit, ipparbar_lower) upperlimit = ipparbar_lower elseif ( upperlimit . GE . ipparbar_upper ) then ! resonance outside or near the right end of the subluminal cone !lowerlimit = min(lowerlimit, ipparbar_upper) lowerlimit = ipparbar_upper upperlimit = npparbar int_end = npparbar - 1 endif else ! no resonance (only integrate from int_start to lowerlimit) int_start = ipparbar_lower lowerlimit = ipparbar_upper int_end = npparbar - 1 upperlimit = npparbar endif ! Now comes the normal integration: if ( int_start . LE . lowerlimit ) then ipparbar = int_start integrate_resU_rel = integrate_resU_rel + resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) endif do ipparbar = int_start + 1 , lowerlimit - 1 integrate_resU_rel = integrate_resU_rel + 2.d0 * resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) enddo if ( int_start . LT . lowerlimit ) then ipparbar = lowerlimit integrate_resU_rel = integrate_resU_rel + resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) endif if ( upperlimit . LE . int_end ) then ipparbar = upperlimit integrate_resU_rel = integrate_resU_rel + resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) endif do ipparbar = upperlimit + 1 , int_end - 1 integrate_resU_rel = integrate_resU_rel + 2.d0 * resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) enddo if ( upperlimit . LT . int_end ) then ipparbar = int_end integrate_resU_rel = integrate_resU_rel + resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) endif integrate_resU_rel = integrate_resU_rel * dpparbar ! And this is the resonance integration: if ( found_res . AND .( lowerlimit . GE . int_start ). AND .( upperlimit . LE . int_end )) & integrate_resU_rel = integrate_resU_rel + principal_integral_rel ( sproc_rel , om , nn , mode , igamma , ipparbar_res , upperlimit ) return end function integrate_resU_rel double complex function principal_integral_rel ( sproc_rel , om , nn , mode , igamma , ipparbar_res , upperlimit ) use alps_var , only : positions_principal , n_resonance_interval , sproc use alps_var , only : gamma_rel , pparbar_rel , vA , kpar , qs , ms , Tlim , pi implicit none double complex :: om , ii , pparbar_res , gprimetr double precision :: denomR , denomI , capDelta , smdelta , correction , pparbar , dpparbar integer :: nn , mode , ipparbar_res , ipparbar , igamma , upperlimit , sproc_rel , ntiny ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) principal_integral_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ! split the range between the resonance and the upper limit into n_resonance_interval steps: ! Now comes the resonance part: ! We call the function that needs to be integrated WITHOUT the resonance part funct_g. ! We linearize this function. Now we can calculate the even part of the integration. ! We set Delta so that it starts at ipparbar_res-positions_principal. In that way, there is only ! a tiny rest left on the right side that needs to be integrated. ! split the range between the resonance and the upper limit into n_resonance_interval steps: ! the denominator is: ! (pparbar - gamma * om/kpar + (1.d0*nn) * qs(sproc)/ms(sproc)) * vA /kpar ! we define ! denomR=real(gamma *om/kpar - (1.d0*nn) * qs(sproc)/ms(sproc))vA /kpar ) ! denomI=aimag(gamma * ms(sproc)*om/kpar) ! so that the denominator is ! (ppar-denomR-ii*denomI) denomR = real ( gamma_rel ( sproc_rel , igamma , ipparbar_res ) * om * vA / kpar - ( 1.d0 * nn ) * ( qs ( sproc ) / ms ( sproc )) * vA / kpar ) denomI = aimag ( gamma_rel ( sproc_rel , igamma , ipparbar_res ) * om * vA / kpar ) pparbar_res = denomR + denomI * ii capDelta = real ( pparbar_res ) - pparbar_rel ( sproc_rel , 1 , ipparbar_res - positions_principal ) smdelta = capDelta / ( 1.d0 * n_resonance_interval ) if ( abs ( denomI ). GT . Tlim ) then ! regular integration: ! Integrate the boundaries: pparbar = real ( pparbar_res ) principal_integral_rel = principal_integral_rel + 1.d0 * & funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI ) principal_integral_rel = principal_integral_rel - 1.d0 * & funct_g_rel ( sproc_rel , 2.d0 * denomR - pparbar , igamma , om , nn , mode ) / ( pparbar - denomR + ii * denomI ) pparbar = real ( pparbar_res ) + capDelta principal_integral_rel = principal_integral_rel + 1.d0 * & funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI ) principal_integral_rel = principal_integral_rel - 1.d0 * & funct_g_rel ( sproc_rel , 2.d0 * denomR - pparbar , igamma , om , nn , mode ) / ( pparbar - denomR + ii * denomI ) do ipparbar = 1 , n_resonance_interval - 1 pparbar = real ( pparbar_res ) + smdelta * ipparbar principal_integral_rel = principal_integral_rel + 2.d0 * & funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI ) principal_integral_rel = principal_integral_rel - 2.d0 * & funct_g_rel ( sproc_rel , 2.d0 * denomR - pparbar , igamma , om , nn , mode ) / ( pparbar - denomR + ii * denomI ) enddo else ! analytical approximation gprimetr = ( funct_g_rel ( sproc_rel , denomR + dpparbar , igamma , om , nn , mode )& - funct_g_rel ( sproc_rel , denomR - dpparbar , igamma , om , nn , mode )) / ( 2.d0 * dpparbar ) ! Integrate the edges: pparbar = real ( pparbar_res ) ! This case is when pparbar=denomR, so no contribution is needed. !if (denomI.NE.0.d0) then !\tprincipal_integral_rel=principal_integral_rel & !\t\t+ 2.d0 * gprimetr*(pparbar-denomR)**2 / ((pparbar-denomR)**2+denomI**2) !else !\tprincipal_integral_rel=principal_integral_rel + 2.d0 * gprimetr !endif pparbar = real ( pparbar_res ) + capDelta principal_integral_rel = principal_integral_rel & + 2.d0 * gprimetr * ( pparbar - denomR ) ** 2 / (( pparbar - denomR ) ** 2 + denomI ** 2 ) ! end of edges. do ipparbar = 1 , n_resonance_interval - 1 pparbar = real ( pparbar_res ) + smdelta * ipparbar principal_integral_rel = principal_integral_rel & + 2.d0 * 2.d0 * gprimetr * ( pparbar - denomR ) ** 2 / (( pparbar - denomR ) ** 2 + denomI ** 2 ) enddo ! The following lines account for Eq. (3.7) in the paper: ! the factor 2 is for normalization reasons in the trapezoidal rule if ( denomI . GT . 0.d0 ) then principal_integral_rel = principal_integral_rel & + 2.d0 * ii * pi * funct_g_rel ( sproc_rel , denomR , igamma , om , nn , mode ) / smdelta else if ( denomI . LT . 0.d0 ) then principal_integral_rel = principal_integral_rel & - 2.d0 * ii * pi * funct_g_rel ( sproc_rel , denomR , igamma , om , nn , mode ) / smdelta else if ( denomI . EQ . 0.d0 ) then principal_integral_rel = principal_integral_rel + 0.d0 endif endif ! There is a tiny rest left between the point real(pparbar_res)+capDelta and the position ! pparbar_rel(sproc_rel,iperp,upperlimit). We split this interval into steps of roughly size smdelta: ntiny = int (( pparbar_rel ( sproc_rel , igamma , upperlimit ) - real ( pparbar_res ) - capDelta ) / smdelta ) if ( ntiny . GT . 0 ) then ! Correct for the fact that smdelta is not exactly the step width in the tiny-rest integration: correction = (( pparbar_rel ( sproc_rel , igamma , upperlimit ) - real ( pparbar_res ) - capDelta ) / ( 1.d0 * ntiny )) / smdelta pparbar = real ( pparbar_res ) + capDelta principal_integral_rel = principal_integral_rel + 1.d0 * & correction * ( funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI )) pparbar = real ( pparbar_res ) + capDelta + correction * smdelta * ntiny principal_integral_rel = principal_integral_rel + 1.d0 * & correction * ( funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI )) do ipparbar = 1 , ntiny - 1 pparbar = real ( pparbar_res ) + capDelta + correction * smdelta * ipparbar principal_integral_rel = principal_integral_rel + 2.d0 * & correction * ( funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI )) enddo endif principal_integral_rel = principal_integral_rel * smdelta return end function ! Linearized integrand WITHOUT the resonance part. ! It is  resU * int_T * Omega but without the denominator. ! It can be evaluated at any real value of pp (ppar_real) between the grid around the resonance. double complex function funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) use alps_var , only : ms , qs , kpar , df0_rel , sproc , vA , npparbar , pparbar_rel , pi , f0_rel implicit none integer :: nn , mode , ipparbar , ipparbar_close , sproc_rel , igamma double complex :: om , integrandplus , integrandminus , integrand double precision :: pparbar , dpparbar dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ipparbar_close =- 2 ! determine the closest ipar (on the left) to this p_res_real: do ipparbar = 0 , npparbar - 1 if (( pparbar_rel ( sproc_rel , igamma , ipparbar + 1 ). GT . pparbar ). AND .( pparbar_rel ( sproc_rel , igamma , ipparbar ). LE . pparbar )) then ipparbar_close = ipparbar endif enddo if ( f0_rel ( sproc_rel , igamma , ipparbar_close + 1 ). LE . - 1.d0 ) ipparbar_close = ipparbar_close - 1 if ( f0_rel ( sproc_rel , igamma , ipparbar_close - 1 ). LE . - 1.d0 ) ipparbar_close = ipparbar_close + 1 if ( pparbar . EQ . pparbar_rel ( sproc_rel , igamma , npparbar )) ipparbar_close = npparbar - 2 if ( ipparbar_close . GE .( npparbar - 1 )) ipparbar_close = npparbar - 2 if ( ipparbar_close . LE . 1 ) ipparbar_close = 2 ! calculate the function on the grid (left and right of pparbar): integrandplus = - 2.d0 * pi * ( ms ( sproc ) / vA ) ** 3 * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * & ( om * df0_rel ( sproc_rel , igamma , ipparbar_close + 1 , 1 ) + & ( kpar / ( vA )) * df0_rel ( sproc_rel , igamma , ipparbar_close + 1 , 2 ))& * int_T_rel ( sproc_rel , nn , igamma , ipparbar_close + 1 , mode ) integrand = - 2.d0 * pi * ( ms ( sproc ) / vA ) ** 3 * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * & ( om * df0_rel ( sproc_rel , igamma , ipparbar_close , 1 ) + & ( kpar / ( vA )) * df0_rel ( sproc_rel , igamma , ipparbar_close , 2 ))& * int_T_rel ( sproc_rel , nn , igamma , ipparbar_close , mode ) integrandminus = - 2.d0 * pi * ( ms ( sproc ) / vA ) ** 3 * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * & ( om * df0_rel ( sproc_rel , igamma , ipparbar_close - 1 , 1 ) + & ( kpar / ( vA )) * df0_rel ( sproc_rel , igamma , ipparbar_close - 1 , 2 ))& * int_T_rel ( sproc_rel , nn , igamma , ipparbar_close - 1 , mode ) funct_g_rel = integrand + & 0.5d0 * (( integrandplus - integrandminus ) / dpparbar ) * ( pparbar - pparbar_rel ( sproc_rel , igamma , ipparbar_close )) return end function funct_g_rel double complex function landau_integrate_rel ( om , nn , mode ) use alps_var , only : ngamma , gamma_rel , pparbar_rel , pi , ms , qs , kpar , sproc , vA use alps_analyt , only : eval_fit implicit none !Passed double complex :: om !complex frequency integer :: nn !Bessel N integer :: mode !index in T tensor !Local integer :: igamma , sproc_rel double precision :: dgamma , dpparbar double precision :: h double complex :: ii double complex :: dfgamma_C , dfpparbar_C , pparbar_res ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) landau_integrate_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) call determine_sproc_rel ( sproc_rel ) dgamma = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ! Landau contour integral: do igamma = 1 , ngamma - 1 pparbar_res = gamma_rel ( sproc_rel , igamma , 1 ) * om * vA / kpar - ( 1.d0 * nn ) * qs ( sproc ) * vA / ( kpar * ms ( sproc )) if (( real ( pparbar_res ) ** 2 ). LE .( gamma_rel ( sproc_rel , igamma , 1 ) ** 2 - 1.d0 )) then h = 1.d0 ! At igamma=1, we are already missing the part from igamma=0, where we should actually start. ! Therefore, we use 4 instead of 2 in the trapezoid integration: if ( igamma . EQ .( ngamma - 1 )) h = 0.5d0 if ( igamma . EQ . 1 ) then dfgamma_C = ( eval_fit ( sproc , igamma + 1 , pparbar_res ) - eval_fit ( sproc , igamma , pparbar_res )) / dgamma else dfgamma_C = ( eval_fit ( sproc , igamma + 1 , pparbar_res ) - eval_fit ( sproc , igamma - 1 , pparbar_res )) / ( 2.d0 * dgamma ) endif dfpparbar_C = ( eval_fit ( sproc , igamma , pparbar_res + dpparbar ) - eval_fit ( sproc , igamma , pparbar_res - dpparbar )) / ( 2.d0 * dpparbar ) landau_integrate_rel = landau_integrate_rel - h * ( & om * dfgamma_C + ( kpar / ( vA )) * dfpparbar_C ) * int_T_res_rel ( sproc_rel , nn , igamma , pparbar_res , mode ) endif enddo landau_integrate_rel = landau_integrate_rel * ii * dgamma * pi * 2.d0 * pi & * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * ( ms ( sproc ) / vA ) ** 3 return end function landau_integrate_rel double complex function int_ee_rel ( om ) use alps_var , only : qs , ms , pi , f0_rel , df0_rel , vA , sproc , gamma_rel , pparbar_rel use alps_var , only : ngamma , npparbar implicit none double complex :: om !complex frequency integer :: sproc_rel , igamma , ipparbar integer :: ipparbar_lower , ipparbar_upper double precision :: dgamma , dpparbar logical :: found_lower , found_upper call determine_sproc_rel ( sproc_rel ) dgamma = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) int_ee_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) ! What are the relevant ranges in pparbar: igamma = ngamma - 1 found_lower = . FALSE . found_upper = . FALSE . ipparbar_lower = 1 ipparbar_upper = npparbar - 1 do ipparbar = 1 , npparbar - 1 if ((. NOT . found_lower ). AND .( f0_rel ( sproc_rel , igamma , ipparbar - 1 ). LE . - 1.d0 ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 )) then ipparbar_lower = ipparbar found_lower = . TRUE . endif if ((. NOT . found_upper ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 ). AND .( f0_rel ( sproc_rel , igamma , ipparbar + 1 ). LE . - 1.d0 )) then ipparbar_upper = ipparbar found_upper = . TRUE . endif enddo int_ee_rel = int_ee_rel + & pparbar_rel ( sproc_rel , igamma , ipparbar_lower ) * df0_rel ( sproc_rel , igamma , ipparbar_lower , 2 ) int_ee_rel = int_ee_rel + & pparbar_rel ( sproc_rel , igamma , ipparbar_upper ) * df0_rel ( sproc_rel , igamma , ipparbar_upper , 2 ) do ipparbar = ipparbar_lower + 1 , ipparbar_upper - 1 int_ee_rel = int_ee_rel + & 2.d0 * pparbar_rel ( sproc_rel , igamma , ipparbar ) * df0_rel ( sproc_rel , igamma , ipparbar , 2 ) enddo ! At igamma=1, we are already missing the part from igamma=0, where we should actually start. ! Therefore, we use 4 instead of 2 in the trapezoid integration: do igamma = 1 , ngamma - 2 found_lower = . FALSE . found_upper = . FALSE . ipparbar_lower = 1 ipparbar_upper = npparbar - 1 do ipparbar = 1 , npparbar - 1 if ((. NOT . found_lower ). AND .( f0_rel ( sproc_rel , igamma , ipparbar - 1 ). LE . - 1.d0 ). AND .& ( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 )) then ipparbar_lower = ipparbar found_lower = . TRUE . endif if ((. NOT . found_upper ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 ). AND .& ( f0_rel ( sproc_rel , igamma , ipparbar + 1 ). LE . - 1.d0 )) then ipparbar_upper = ipparbar found_upper = . TRUE . endif enddo do ipparbar = ipparbar_lower + 1 , ipparbar_upper - 1 int_ee_rel = int_ee_rel + & 4.d0 * pparbar_rel ( sproc_rel , igamma , ipparbar ) * df0_rel ( sproc_rel , igamma , ipparbar , 2 ) enddo int_ee_rel = int_ee_rel + & 2.d0 * pparbar_rel ( sproc_rel , igamma , ipparbar_lower ) * df0_rel ( sproc_rel , igamma , ipparbar_lower , 2 ) int_ee_rel = int_ee_rel + & 2.d0 * pparbar_rel ( sproc_rel , igamma , ipparbar_upper ) * df0_rel ( sproc_rel , igamma , ipparbar_upper , 2 ) enddo int_ee_rel = int_ee_rel * 2.d0 * pi * qs ( sproc ) / ( ms ( sproc )) int_ee_rel = int_ee_rel * dgamma * dpparbar * 0.25d0 * ( ms ( sproc ) / vA ) ** 3 return end function int_ee_rel !-=-=-=-=-=-= !Functions for resonant term in integral !-=-=-=-=-=-= !-=-=-=-=-=-= !Functions for resonant term in integral for the relativistic calculation: !-=-=-=-=-=-= double complex function resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) use ALPS_var , only : kpar , ms , qs , df0_rel , vA , sproc , gamma_rel use ALPS_var , only : pi , pparbar_rel implicit none !Passed integer :: nn !Bessel N integer :: sproc_rel , igamma , ipparbar double complex :: om !complex frequency !Local resU_rel = - 2.d0 * pi * ( ms ( sproc ) / vA ) ** 3 * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * & ( om * df0_rel ( sproc_rel , igamma , ipparbar , 1 ) + ( kpar / ( vA )) * df0_rel ( sproc_rel , igamma , ipparbar , 2 )) / & ( pparbar_rel ( sproc_rel , igamma , ipparbar ) - gamma_rel ( sproc_rel , igamma , ipparbar ) * om * vA / kpar & + ( 1.d0 * nn ) * qs ( sproc ) * vA / ( kpar * ms ( sproc ))) return end function resU_rel !-=-=-=-=-=-= !Functions for Tij- !-=-=-=-=-=-= !Function to pass T_ij into integrator double complex function int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) use ALPS_var , only : kperp , qs , sproc , pparbar_rel , gamma_rel , vA , ms implicit none !Passed integer :: nn , igamma , ipparbar , sproc_rel integer :: mode !index in T tensor !Local double precision :: z , zbar !Bessel Argument double precision :: pperpbar double precision :: bessel ! Bessel function for nn and z double precision :: besselP ! first derivative of Bessel function for nn and z double complex :: ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) !Bessel Fn Argument pperpbar = sqrt ( gamma_rel ( sproc_rel , igamma , ipparbar ) ** 2 - 1.d0 - pparbar_rel ( sproc_rel , igamma , ipparbar ) ** 2 ) z = ( kperp * ms ( sproc ) / ( vA * qs ( sproc ))) * pperpbar zbar = kperp * ms ( sproc ) / ( vA * qs ( sproc )) ! Look up array of Bessel functions: if ( nn . LT . 0 ) then bessel = (( - 1.d0 ) ** nn ) * BESSJ ( - nn , z ) else bessel = BESSJ ( nn , z ) endif ! determine derivative of Bessel function: if ( nn . GE . 1 ) then besselP = 0.5d0 * ( BESSJ ( nn - 1 , z ) - BESSJ ( nn + 1 , z )) else if ( nn . LT . - 1 ) then besselP = 0.5d0 * (((( - 1.d0 ) ** ( nn - 1 )) * BESSJ ( - ( nn - 1 ), z ))& - ((( - 1.d0 ) ** ( nn + 1 )) * BESSJ ( - ( nn + 1 ), z ))) else if ( nn . EQ . 0 ) then besselP = - BESSJ ( 1 , z ) else if ( nn . EQ . - 1 ) then besselP = 0.5d0 * ( BESSJ ( 2 , z ) - BESSJ ( 0 , z )) endif select case ( mode ) case ( 1 ) !T xx int_T_rel = 1.d0 * ( nn * nn ) * bessel * bessel / ( zbar * zbar ) case ( 2 ) !T yy int_T_rel = besselP * besselP * pperpbar * pperpbar case ( 3 ) !T zz int_T_rel = bessel * bessel * pparbar_rel ( sproc_rel , igamma , ipparbar ) ** 2 case ( 4 ) !T xy int_T_rel = ii * ( 1.d0 * ( nn )) * bessel * besselP * pperpbar / zbar case ( 5 ) !T xz int_T_rel = ( 1.d0 * nn ) * bessel * bessel * pparbar_rel ( sproc_rel , igamma , ipparbar ) / zbar case ( 6 ) !T yz int_T_rel = ( - 1.d0 * ii ) * bessel * besselP * pparbar_rel ( sproc_rel , igamma , ipparbar ) * pperpbar end select return end function int_T_rel !Function to pass T_ij into integrator double complex function int_T_res_rel ( sproc_rel , nn , igamma , pparbar , mode ) use ALPS_var , only : kperp , qs , sproc , gamma_rel , vA , ms implicit none !Passed integer :: nn , igamma , sproc_rel integer :: mode !index in T tensor !Local double precision :: zbar double complex :: z double complex :: pperpbar double complex :: bessel ! Bessel function for nn and z double complex :: besselP ! first derivative of Bessel function for nn and z double complex :: besselH ! Help variable double complex :: ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) double complex :: pparbar !Bessel Fn Argument pperpbar = sqrt ( gamma_rel ( sproc_rel , igamma , 1 ) ** 2 - 1.d0 - pparbar ** 2 ) z = ( kperp * ms ( sproc ) / ( vA * qs ( sproc ))) * pperpbar zbar = kperp * ms ( sproc ) / ( vA * qs ( sproc )) ! Look up array of Bessel functions: if ( nn . LT . 0 ) then call CBESSJ ( z , - nn , bessel ) bessel = bessel * ( - 1.d0 ) ** nn else call CBESSJ ( z , nn , bessel ) endif ! determine derivative of Bessel function: if ( nn . GE . 1 ) then call CBESSJ ( z , nn - 1 , besselP ) call CBESSJ ( z , nn + 1 , besselH ) besselP = 0.5d0 * ( besselP - besselH ) elseif ( nn . LT . - 1 ) then call CBESSJ ( z , - ( nn - 1 ), besselP ) call CBESSJ ( z , - ( nn + 1 ), besselH ) besselP = 0.5d0 * (((( - 1.d0 ) ** ( nn - 1 )) * besselP )& - ((( - 1.d0 ) ** ( nn + 1 )) * besselH )) elseif ( nn . EQ . 0 ) then call CBESSJ ( z , 1 , besselP ) besselP = - besselP elseif ( nn . EQ . - 1 ) then call CBESSJ ( z , 2 , besselP ) call CBESSJ ( z , 0 , besselH ) besselP = 0.5d0 * ( besselP - besselH ) endif select case ( mode ) case ( 1 ) !T xx int_T_res_rel = 1.d0 * ( nn * nn ) * bessel * bessel / ( zbar * zbar ) case ( 2 ) !T yy int_T_res_rel = besselP * besselP * pperpbar * pperpbar case ( 3 ) !T zz int_T_res_rel = bessel * bessel * pparbar ** 2 case ( 4 ) !T xy int_T_res_rel = ii * ( 1.d0 * ( nn )) * bessel * besselP * pperpbar / zbar case ( 5 ) !T xz int_T_res_rel = ( 1.d0 * nn ) * bessel * bessel * pparbar / zbar case ( 6 ) !T yz int_T_res_rel = ( - 1.d0 * ii ) * bessel * besselP * pparbar * pperpbar end select return end function int_T_res_rel ! Calculate the complex Bessel function subroutine CBESSJ ( z , nu , z1 ) !--------------------------------------------------- !                       inf.     (-z&#94;2/4)&#94;k !   Jnu(z) = (z/2)&#94;nu x Sum  ------------------ !                       k=0  k! x Gamma(nu+k+1) !  (nu must be >= 0). !--------------------------------------------------- implicit none double complex :: z , z1 integer :: k , MAXK , nu double complex :: sum , tmp double precision :: ZERO parameter ( MAXK = 20 , ZERO = 0.d0 ) sum = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) do k = 0 , MAXK !calculate (-z**2/4)**k tmp = ( - z * z / 4.d0 ) ** k !divide by k! tmp = tmp / Fact ( k ) !divide by Gamma(nu+k+1) tmp = tmp / Gamma ( 1.d0 * ( nu + k + 1 )) !actualize sum sum = sum + tmp end do !calculate (z/2)**nu tmp = ( z / 2.d0 ) ** nu !multiply (z/2)**nu by sum z1 = tmp * sum return end subroutine double precision function Fact ( K ) implicit none integer :: i , k double precision :: f f = 1.d0 do i = 2 , k f = f * ( 1.d0 * i ) end do Fact = f return end function DOUBLE PRECISION FUNCTION BESSJ ( N , X ) !double precision FUNCTION BESSJ (N,X) !     This subroutine calculates the first kind Bessel function !     of integer order N, for any REAL X. We use here the classical !     recursion formula, when X > N. For X < N, the Miller's algorithm !     is used to avoid overflows. !     REFERENCE: !     C.W.CLENSHAW, CHEBYSHEV SERIES FOR MATHEMATICAL FUNCTIONS, !     MATHEMATICAL TABLES, VOL.5, 1962. IMPLICIT NONE INTEGER , PARAMETER :: IACC = 40 REAL * 8 , PARAMETER :: BIGNO = 1.D10 , BIGNI = 1.D-10 INTEGER M , N , J , JSUM !REAL *8 X,BESSJ,TOX,BJM,BJ,BJP,SUM REAL * 8 X , TOX , BJM , BJ , BJP , SUM !REAL *8 X,BESSJ0,BESSJ1,TOX,BJM,BJ,BJP,SUM !      REAL *8 X,BESSJ,BESSJ0,BESSJ1,TOX,BJM,BJ,BJP,SUM !write(*,*)'z: ', x IF ( N . EQ . 0 ) THEN BESSJ = BESSJ0 ( X ) RETURN ENDIF IF ( N . EQ . 1 ) THEN BESSJ = BESSJ1 ( X ) RETURN ENDIF IF ( X . EQ . 0. ) THEN BESSJ = 0. RETURN ENDIF TOX = 2. / X IF ( X . GT . FLOAT ( N )) THEN BJM = BESSJ0 ( X ) BJ = BESSJ1 ( X ) DO 11 J = 1 , N - 1 BJP = J * TOX * BJ - BJM BJM = BJ BJ = BJP 11 CONTINUE BESSJ = BJ ELSE M = 2 * (( N + INT ( SQRT ( FLOAT ( IACC * N )))) / 2 ) BESSJ = 0. JSUM = 0 SUM = 0. BJP = 0. BJ = 1. DO 12 J = M , 1 , - 1 BJM = J * TOX * BJ - BJP BJP = BJ BJ = BJM IF ( ABS ( BJ ). GT . BIGNO ) THEN BJ = BJ * BIGNI BJP = BJP * BIGNI BESSJ = BESSJ * BIGNI SUM = SUM * BIGNI ENDIF IF ( JSUM . NE . 0 ) SUM = SUM + BJ JSUM = 1 - JSUM IF ( J . EQ . N ) BESSJ = BJP 12 CONTINUE SUM = 2. * SUM - BJ BESSJ = BESSJ / SUM ENDIF RETURN END FUNCTION !double precision FUNCTION BESSJ0 (X) DOUBLE PRECISION FUNCTION BESSJ0 ( X ) IMPLICIT NONE REAL * 8 X , AX , FR , FS , Z , FP , FQ , XX !REAL *8 X,BESSJ0,AX,FR,FS,Z,FP,FQ,XX !     This subroutine calculates the First Kind Bessel Function of !     order 0, for any real number X. The polynomial approximation by !     series of Chebyshev polynomials is used for 0<X<8 and 0<8/X<1. !     REFERENCES: !     M.ABRAMOWITZ,I.A.STEGUN, HANDBOOK OF MATHEMATICAL FUNCTIONS, 1965. !     C.W.CLENSHAW, NATIONAL PHYSICAL LABORATORY MATHEMATICAL TABLES, !     VOL.5, 1962. REAL * 8 Y , P1 , P2 , P3 , P4 , P5 , R1 , R2 , R3 , R4 , R5 , R6 & , Q1 , Q2 , Q3 , Q4 , Q5 , S1 , S2 , S3 , S4 , S5 , S6 DATA P1 , P2 , P3 , P4 , P5 / 1.D0 , - . 1098628627 D - 2 ,. 2734510407 D - 4 , & - . 2073370639 D - 5 ,. 2093887211 D - 6 / DATA Q1 , Q2 , Q3 , Q4 , Q5 /- . 1562499995 D - 1 ,. 1430488765 D - 3 , & - . 6911147651 D - 5 ,. 7621095161 D - 6 , - . 9349451520 D - 7 / DATA R1 , R2 , R3 , R4 , R5 , R6 / 5756849057 4.D0 , - 1336259035 4.D0 , & 65161964 0.7D0 , - 1121442 4.18D0 , 7739 2.33017D0 , - 18 4.9052456D0 / DATA S1 , S2 , S3 , S4 , S5 , S6 / 5756849041 1.D0 , 102953298 5.D0 , & 949468 0.718D0 , 5927 2.64853D0 , 26 7.8532712D0 , 1.D0 / IF ( X . EQ . 0.D0 ) GO TO 1 AX = ABS ( X ) IF ( AX . LT . 8.D0 ) THEN Y = X * X FR = R1 + Y * ( R2 + Y * ( R3 + Y * ( R4 + Y * ( R5 + Y * R6 )))) FS = S1 + Y * ( S2 + Y * ( S3 + Y * ( S4 + Y * ( S5 + Y * S6 )))) BESSJ0 = FR / FS ELSE Z = 8.D0 / AX Y = Z * Z XX = AX - . 785398164 D0 FP = P1 + Y * ( P2 + Y * ( P3 + Y * ( P4 + Y * P5 ))) FQ = Q1 + Y * ( Q2 + Y * ( Q3 + Y * ( Q4 + Y * Q5 ))) BESSJ0 = SQRT (. 636619772 D0 / AX ) * ( FP * COS ( XX ) - Z * FQ * SIN ( XX )) ENDIF RETURN 1 BESSJ0 = 1.D0 RETURN END FUNCTION BESSJ0 ! --------------------------------------------------------------------------- !double precision FUNCTION BESSJ1 (X) double precision FUNCTION BESSJ1 ( X ) IMPLICIT NONE !REAL *8 X,BESSJ1,AX,FR,FS,Z,FP,FQ,XX REAL * 8 X , AX , FR , FS , Z , FP , FQ , XX !     This subroutine calculates the First Kind Bessel Function of !     order 1, for any real number X. The polynomial approximation by !     series of Chebyshev polynomials is used for 0<X<8 and 0<8/X<1. !     REFERENCES: !     M.ABRAMOWITZ,I.A.STEGUN, HANDBOOK OF MATHEMATICAL FUNCTIONS, 1965. !     C.W.CLENSHAW, NATIONAL PHYSICAL LABORATORY MATHEMATICAL TABLES, !     VOL.5, 1962. REAL * 8 Y , P1 , P2 , P3 , P4 , P5 , P6 , R1 , R2 , R3 , R4 , R5 , R6 & , Q1 , Q2 , Q3 , Q4 , Q5 , S1 , S2 , S3 , S4 , S5 , S6 DATA P1 , P2 , P3 , P4 , P5 / 1.D0 ,. 183105 D - 2 , - . 3516396496 D - 4 , & . 2457520174 D - 5 , - . 240337019 D - 6 / , P6 / . 636619772 D0 / DATA Q1 , Q2 , Q3 , Q4 , Q5 / . 04687499995 D0 , - . 2002690873 D - 3 , & . 8449199096 D - 5 , - . 88228987 D - 6 ,. 105787412 D - 6 / DATA R1 , R2 , R3 , R4 , R5 , R6 / 7236261423 2.D0 , - 789505923 5.D0 , & 24239685 3.1D0 , - 297261 1.439D0 , 1570 4.48260D0 , - 3 0.16036606D0 / DATA S1 , S2 , S3 , S4 , S5 , S6 / 14472522844 2.D0 , 230053517 8.D0 , & 1858330 4.74D0 , 9944 7.43394D0 , 37 6.9991397D0 , 1.D0 / AX = ABS ( X ) IF ( AX . LT . 8. ) THEN Y = X * X FR = R1 + Y * ( R2 + Y * ( R3 + Y * ( R4 + Y * ( R5 + Y * R6 )))) FS = S1 + Y * ( S2 + Y * ( S3 + Y * ( S4 + Y * ( S5 + Y * S6 )))) BESSJ1 = X * ( FR / FS ) ELSE Z = 8. / AX Y = Z * Z XX = AX - 2.35619491 FP = P1 + Y * ( P2 + Y * ( P3 + Y * ( P4 + Y * P5 ))) FQ = Q1 + Y * ( Q2 + Y * ( Q3 + Y * ( Q4 + Y * Q5 ))) BESSJ1 = SQRT ( P6 / AX ) * ( COS ( XX ) * FP - Z * SIN ( XX ) * FQ ) * SIGN ( S6 , X ) ENDIF RETURN END FUNCTION BESSJ1 !******************************************* !*           FUNCTION  GAMMA(X)            * !* --------------------------------------- * !* Returns the value of Gamma(x) in double * !* precision as EXP(LN(GAMMA(X))) for X>0. * !******************************************* double precision Function Gamma ( xx ) implicit none double precision :: xx , ONE , FPF , HALF double precision :: cof ( 6 ) double precision :: stp , x , tmp , ser integer :: j parameter ( ONE = 1.d0 , FPF = 5.5d0 , HALF = 0.5d0 ) cof ( 1 ) = 7 6.18009173d0 cof ( 2 ) =- 8 6.50532033d0 cof ( 3 ) = 2 4.01409822d0 cof ( 4 ) =- 1.231739516d0 cof ( 5 ) = 0.120858003d-2 cof ( 6 ) =- 0.536382d-5 stp = 2.50662827465d0 x = xx - ONE tmp = x + FPF tmp = ( x + HALF ) * LOG ( tmp ) - tmp ser = ONE do j = 1 , 6 x = x + ONE ser = ser + cof ( j ) / x end do Gamma = EXP ( tmp + LOG ( stp * ser )) return end function end module alps_fns_rel","tags":"","loc":"sourcefile/alps_fns_rel.f90.html"},{"title":"ALPS.f90 – ALPS","text":"Contents Programs alps Source Code ALPS.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== program alps use alps_var , only : nproc , iproc , ierror , proc0 , sproc use alps_var , only : use_map , unit_error , scan_option use alps_var , only : writeOut , f0 , nperp , npar , nspec , n_scan use alps_io , only : init_param , read_f0 , get_unused_unit use alps_io , only : alps_error , alps_error_init , output_time , display_credits use alps_fns , only : derivative_f0 , disp , secant use alps_fns , only : refine_guess use alps_fns , only : determine_nmax , split_processes , determine_bessel_array use alps_fns , only : map_search use alps_fns , only : om_scan , om_double_scan use alps_com , only : pass_instructions , pass_distribution use alps_analyt , only : determine_param_fit use alps_check , only : check_parameters use mpi implicit none !Local integer :: ik !Initialize MPI message passing--------------------------------------------- call mpi_init ( ierror ) call mpi_comm_size ( mpi_comm_world , nproc , ierror ) call mpi_comm_rank ( mpi_comm_world , iproc , ierror ) !Set logical proc0=true if iproc=0 proc0 = ( iproc == 0 ) if ( proc0 ) then call alps_error_init write ( * , '(a)' ) 'Starting ALPS===================================' write ( * , '(a)' ) \"Time:\" call output_time write ( * , '(a)' ) '================================================' call display_credits endif call mpi_barrier ( mpi_comm_world , ierror ) if ( proc0 ) write ( * , '(a)' ) 'All processes are up and running.' !Check to be sure nproc is even and greater than 2, otherwise shutdown if (( mod ( nproc , 2 ) . ne . 0 ). or .( nproc . le . 2 )) call alps_error ( 0 ) !Read parameters------------------------------------------------------------ if ( proc0 ) call init_param !alps_io !Split Problem Amongst Processors !Pass relevant information from readin call pass_instructions !alps_com if ( proc0 ) then !Allocate background distribution function f0 allocate ( f0 ( 1 : nspec , 0 : nperp , 0 : npar )); f0 = 0.d0 !Read in f0 call read_f0 !alps_io !Calculate pperp, ppar derivatives of f0 call derivative_f0 !alps_fns call determine_param_fit !alps_analyt !f0 not needed for dispersion calculation !Deallocate to save space. deallocate ( f0 ) call check_parameters endif call pass_distribution ! alps_com ! Once we know kperp, we can determine nmax and split the processes: ! The following three routines will also be called when kperp changes call determine_nmax ! alps_fns call split_processes ! alps_fns ! All processes determine their Bessel function array: if (. NOT .( sproc . EQ . 0 )) call determine_bessel_array ! alps_fns call mpi_barrier ( mpi_comm_world , ierror ) !Either: !use_map=.true.  : !    use a scan over (omega,gamma) to local dispersion solutions !OR !use_map=.false. : !    use user input roots as initial guesses for dispersion solutions if ( use_map ) then if ( writeOut . and . proc0 ) & write ( * , '(a)' ) 'Map Search' call map_search else if ( writeOut . and . proc0 ) & write ( * , '(a)' ) 'Starting Secant Method' call refine_guess endif if ( n_scan . gt . 0 ) then !setting n_scan=0 turns off wavevector scanning select case ( scan_option ) case ( 1 ) !scan along perscribed paths in wavevector space do ik = 1 , n_scan call om_scan ( ik ) enddo case ( 2 ) if ( n_scan == 2 ) then call om_double_scan else call alps_error ( 4 ) ! endif case default call alps_error ( 3 ) !scan_option not selected end select endif !Finalize MPI message passing call mpi_finalize ( ierror ) if ( proc0 ) then write ( * , '(a)' ) 'Finishing ALPS===================================' write ( * , '(a)' ) \"Time:\" call output_time write ( * , '(a)' ) '================================================' write ( unit_error , '(a)' ) 'Run completed without fatal error.' close ( unit_error ) endif end program alps","tags":"","loc":"sourcefile/alps.f90.html"},{"title":"ALPS_NHDS.f90 – ALPS","text":"Contents Modules alps_nhds Source Code ALPS_NHDS.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_nhds implicit none private :: calc_ypsilon , besselI , BESSI , BESSI0 , BESSI1 , WOFZ , dispfunct public :: calc_chi contains ! This file is part of NHDS ! Copyright (C) 2020 Daniel Verscharen (d.verscharen@ucl.ac.uk) !All rights reserved. ! !Redistribution and use in source and binary forms, with or without !modification, are permitted provided that the following conditions are met: ! !1. Redistributions of source code must retain the above copyright notice, this !   list of conditions and the following disclaimer. !2. Redistributions in binary form must reproduce the above copyright notice, !   this list of conditions and the following disclaimer in the documentation !   and/or other materials provided with the distribution. ! !THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND !ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED !WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE !DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR !ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES !(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; !LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND !ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT !(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS !SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! !The views and conclusions contained in the software and documentation are those !of the authors and should not be interpreted as representing official policies, !either expressed or implied, of the NHDS project. subroutine calc_chi ( chi , j , kz , kperp , x ) use alps_var , only : bMnmaxs , bMBessel_zeros , bMbetas , bMalphas , bMpdrifts use alps_var , only : ms , qs , ns implicit none double complex :: chi ( 3 , 3 ), Y ( 3 , 3 ), Ynew ( 3 , 3 ), x double precision :: kz , kperp , z double precision :: Omega , ell , vtherm , Bessel_zero , vdrift integer :: j , n , i , k , nmaxrun logical :: Bessel_run integer :: nmax Omega = qs ( j ) / ms ( j ) ell = sqrt ( ms ( j ) / ( ns ( j ) * qs ( j ) * qs ( j ))) vtherm = sqrt ( bMbetas ( j ) / ( ns ( j ) * ms ( j ))) nmax = bMnmaxs ( j ) Bessel_zero = bMBessel_zeros ( j ) vdrift = bMpdrifts ( j ) / ms ( j ) z = 0.5d0 * ( kperp * vtherm / Omega ) * ( kperp * vtherm / Omega ) * bMalphas ( j ) do i = 1 , 3 do k = 1 , 3 Y ( i , k ) = 0.d0 enddo enddo !determine maximum n for Besselfunction: nmaxrun = nmax n = 0 Bessel_run = . TRUE . do while ( Bessel_run ) if (( n . GE . nmax ). OR .( besselI ( n , z ). LT . Bessel_zero )) then nmaxrun = n Bessel_run = . FALSE . endif n = n + 1 enddo do n =- nmaxrun , nmaxrun call calc_ypsilon ( Ynew , j , n , kz , kperp , x ) do i = 1 , 3 do k = 1 , 3 Y ( i , k ) = Y ( i , k ) + exp ( - z ) * Ynew ( i , k ) enddo enddo enddo chi ( 1 , 1 ) = Y ( 1 , 1 ) / ( ell * ell ) chi ( 1 , 2 ) = Y ( 1 , 2 ) / ( ell * ell ) chi ( 1 , 3 ) = Y ( 1 , 3 ) / ( ell * ell ) chi ( 2 , 1 ) = Y ( 2 , 1 ) / ( ell * ell ) chi ( 2 , 2 ) = Y ( 2 , 2 ) / ( ell * ell ) chi ( 2 , 3 ) = Y ( 2 , 3 ) / ( ell * ell ) chi ( 3 , 1 ) = Y ( 3 , 1 ) / ( ell * ell ) chi ( 3 , 2 ) = Y ( 3 , 2 ) / ( ell * ell ) chi ( 3 , 3 ) = 2.d0 * x * vdrift / ( ell * ell * kz * vtherm * vtherm * bMalphas ( j )) + Y ( 3 , 3 ) / ( ell * ell ) end subroutine subroutine calc_ypsilon ( Y , j , n , kz , kperp , x ) use alps_var , only : bMbetas , bMalphas , bMpdrifts use alps_var , only : ms , qs , ns implicit none double complex , parameter :: uniti = ( 0.d0 , 1.d0 ) double complex :: zeta , x , Y ( 3 , 3 ), An , Bn , resfac double precision :: kz , kperp , BInz , z double precision :: Omega , ell , vtherm , vdrift !double precision :: besselI double precision :: dBInzdz integer :: n , j logical :: kpos kpos = . TRUE . if ( kz . LT . 0.d0 ) kpos = . FALSE . Omega = qs ( j ) / ms ( j ) ell = sqrt ( ms ( j ) / ( ns ( j ) * qs ( j ) * qs ( j ))) vtherm = sqrt ( bMbetas ( j ) / ( ns ( j ) * ms ( j ))) vdrift = bMpdrifts ( j ) / ms ( j ) zeta = ( x - kz * vdrift - 1.d0 * n * Omega ) / ( kz * vtherm ) resfac = x - kz * vdrift - 1.d0 * n * Omega z = 0.5d0 * ( kperp * vtherm / Omega ) * ( kperp * vtherm / Omega ) * bMalphas ( j ) An = ( bMalphas ( j ) - 1.d0 ) An = An + ( 1.d0 / ( kz * vtherm )) * ( bMalphas ( j ) * resfac + 1.d0 * n * Omega ) * dispfunct ( zeta , kpos ) Bn = ( bMalphas ( j ) * ( x - 1.d0 * n * Omega ) - ( kz * vdrift - 1.d0 * n * Omega )) / kz Bn = Bn + (( x - 1.d0 * n * Omega ) * ( bMalphas ( j ) * resfac + 1.d0 * n * Omega ) / ( kz * kz * vtherm ) ) * dispfunct ( zeta , kpos ) if ( n . GE . 0 ) then BInz = 1.d0 * besselI ( n , z ) dBInzdz = besselI ( n + 1 , z ) + 1.d0 * n * BInz / z else BInz = 1.d0 * besselI ( - n , z ) dBInzdz = besselI ( - n - 1 , z ) + 1.d0 * n * BInz / z endif ! The tensor in Stix's (10-57) Y ( 1 , 1 ) = 1.d0 * ( n * n ) * BInz * An / z Y ( 1 , 2 ) =- uniti * n * ( BInz - dBInzdz ) * An Y ( 1 , 3 ) = kperp * n * BInz * Bn / ( Omega * z ) Y ( 2 , 1 ) = uniti * n * ( BInz - dBInzdz ) * An Y ( 2 , 2 ) = ( 1.d0 * ( n * n ) * BInz / z + 2.d0 * z * BInz - 2.d0 * z * dBInzdz ) * An Y ( 2 , 3 ) = uniti * kperp * ( BInz - dBInzdz ) * Bn / Omega Y ( 3 , 1 ) = kperp * BInz * n * Bn / ( Omega * z ) Y ( 3 , 2 ) =- uniti * kperp * ( BInz - dBInzdz ) * Bn / Omega Y ( 3 , 3 ) = 2.d0 * ( x - 1.d0 * n * Omega ) * BInz * Bn / ( kz * vtherm * vtherm * bMalphas ( j )) end subroutine double precision function besselI ( n , x ) implicit none double precision :: x integer :: n if ( n . LT . 0 ) then besselI = BESSI ( - n , x ) else besselI = BESSI ( n , x ) endif end function ! ! Calculate the dispersion function: ! double complex function dispfunct ( zeta , kpos ) implicit none double complex , parameter :: uniti = ( 0.d0 , 1.d0 ) double complex :: zeta logical :: flag , kpos double precision :: U , V , XI , YI double precision :: M_PI = 4.d0 * atan ( 1.d0 ) XI = 1.d0 * real ( zeta ) YI = 1.d0 * aimag ( zeta ) if ( kpos ) then call WOFZ ( XI , YI , U , V , flag ) dispfunct = uniti * sqrt ( M_PI ) * ( U + uniti * V ) else call WOFZ ( - XI , - YI , U , V , flag ) dispfunct = - uniti * sqrt ( M_PI ) * ( U + uniti * V ) endif end function !Based on !G.P.M. Poppe, C.M.J. Wijers, \"More Efficient Computation of the Complex Error-Function\", !ACM Trans. Math. Software 16, 47 (1990). !C      ALGORITHM 680, COLLECTED ALGORITHMS FROM ACM. !C      THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE, !C      VOL. 16, NO. 1, PP. 47 SUBROUTINE WOFZ ( XI , YI , U , V , FLAG ) !C !C  GIVEN A COMPLEX NUMBER Z = (XI,YI), THIS SUBROUTINE COMPUTES !C  THE VALUE OF THE FADDEEVA-FUNCTION W(Z) = EXP(-Z**2)*ERFC(-I*Z), !C  WHERE ERFC IS THE COMPLEX COMPLEMENTARY ERROR-FUNCTION AND I !C  MEANS SQRT(-1). !C  THE ACCURACY OF THE ALGORITHM FOR Z IN THE 1ST AND 2ND QUADRANT !C  IS 14 SIGNIFICANT DIGITS; IN THE 3RD AND 4TH IT IS 13 SIGNIFICANT !C  DIGITS OUTSIDE A CIRCULAR REGION WITH RADIUS 0.126 AROUND A ZERO !C  OF THE FUNCTION. !C  ALL REAL VARIABLES IN THE PROGRAM ARE DOUBLE PRECISION. !C !C !C  THE CODE CONTAINS A FEW COMPILER-DEPENDENT PARAMETERS : !C     RMAXREAL = THE MAXIMUM VALUE OF RMAXREAL EQUALS THE ROOT OF !C                RMAX = THE LARGEST NUMBER WHICH CAN STILL BE !C                IMPLEMENTED ON THE COMPUTER IN DOUBLE PRECISION !C                FLOATING-POINT ARITHMETIC !C     RMAXEXP  = LN(RMAX) - LN(2) !C     RMAXGONI = THE LARGEST POSSIBLE ARGUMENT OF A DOUBLE PRECISION !C                GONIOMETRIC FUNCTION (DCOS, DSIN, ...) !C  THE REASON WHY THESE PARAMETERS ARE NEEDED AS THEY ARE DEFINED WILL !C  BE EXPLAINED IN THE CODE BY MEANS OF COMMENTS !C !C !C  PARAMETER LIST !C     XI     = REAL      PART OF Z !C     YI     = IMAGINARY PART OF Z !C     U      = REAL      PART OF W(Z) !C     V      = IMAGINARY PART OF W(Z) !C     FLAG   = AN ERROR FLAG INDICATING WHETHER OVERFLOW WILL !C              OCCUR OR NOT; TYPE LOGICAL; !C              THE VALUES OF THIS VARIABLE HAVE THE FOLLOWING !C              MEANING : !C              FLAG=.FALSE. : NO ERROR CONDITION !C              FLAG=.TRUE.  : OVERFLOW WILL OCCUR, THE ROUTINE !C                             BECOMES INACTIVE !C  XI, YI      ARE THE INPUT-PARAMETERS !C  U, V, FLAG  ARE THE OUTPUT-PARAMETERS !C !C  FURTHERMORE THE PARAMETER FACTOR EQUALS 2/SQRT(PI) !C !C  THE ROUTINE IS NOT UNDERFLOW-PROTECTED BUT ANY VARIABLE CAN BE !C  PUT TO 0 UPON UNDERFLOW; !C !C  REFERENCE - GPM POPPE, CMJ WIJERS; MORE EFFICIENT COMPUTATION OF !C  THE COMPLEX ERROR-FUNCTION, ACM TRANS. MATH. SOFTWARE. !C !* !* !* !* IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) IMPLICIT INTEGER ( I - N ) LOGICAL A , B , FLAG PARAMETER ( FACTOR = 1.12837916709551257388D0 , RMAXREAL = 0.5D+154 , RMAXEXP = 70 8.503061461606D0 ,& & RMAXGONI = 3.53711887601422D+15 ) FLAG = . FALSE . XABS = DABS ( XI ) YABS = DABS ( YI ) X = XABS / 6.3 Y = YABS / 4.4 !* !C !C     THE FOLLOWING IF-STATEMENT PROTECTS !C     QRHO = (X**2 + Y**2) AGAINST OVERFLOW !C IF (( XABS . GT . RMAXREAL ). OR .( YABS . GT . RMAXREAL )) GOTO 100 QRHO = X ** 2 + Y ** 2 XABSQ = XABS ** 2 XQUAD = XABSQ - YABS ** 2 YQUAD = 2 * XABS * YABS A = QRHO . LT . 0.085264D0 IF ( A ) THEN !C !C  IF (QRHO.LT.0.085264D0) THEN THE FADDEEVA-FUNCTION IS EVALUATED !C  USING A POWER-SERIES (ABRAMOWITZ/STEGUN, EQUATION (7.1.5), P.297) !C  N IS THE MINIMUM NUMBER OF TERMS NEEDED TO OBTAIN THE REQUIRED !C  ACCURACY !C QRHO = ( 1 - 0.85 * Y ) * DSQRT ( QRHO ) N = IDNINT ( 6 + 72 * QRHO ) J = 2 * N + 1 XSUM = 1.0 / J YSUM = 0.0D0 DO 10 I = N , 1 , - 1 J = J - 2 XAUX = ( XSUM * XQUAD - YSUM * YQUAD ) / I YSUM = ( XSUM * YQUAD + YSUM * XQUAD ) / I XSUM = XAUX + 1.0 / J 10 CONTINUE U1 = - FACTOR * ( XSUM * YABS + YSUM * XABS ) + 1.0 V1 = FACTOR * ( XSUM * XABS - YSUM * YABS ) DAUX = DEXP ( - XQUAD ) U2 = DAUX * DCOS ( YQUAD ) V2 = - DAUX * DSIN ( YQUAD ) U = U1 * U2 - V1 * V2 V = U1 * V2 + V1 * U2 ELSE !C !C  IF (QRHO.GT.1.O) THEN W(Z) IS EVALUATED USING THE LAPLACE !C  CONTINUED FRACTION !C  NU IS THE MINIMUM NUMBER OF TERMS NEEDED TO OBTAIN THE REQUIRED !C  ACCURACY !C !C  IF ((QRHO.GT.0.085264D0).AND.(QRHO.LT.1.0)) THEN W(Z) IS EVALUATED !C  BY A TRUNCATED TAYLOR EXPANSION, WHERE THE LAPLACE CONTINUED FRACTION !C  IS USED TO CALCULATE THE DERIVATIVES OF W(Z) !C  KAPN IS THE MINIMUM NUMBER OF TERMS IN THE TAYLOR EXPANSION NEEDED !C  TO OBTAIN THE REQUIRED ACCURACY !C  NU IS THE MINIMUM NUMBER OF TERMS OF THE CONTINUED FRACTION NEEDED !C  TO CALCULATE THE DERIVATIVES WITH THE REQUIRED ACCURACY ! IF ( QRHO . GT . 1.0 ) THEN H = 0.0D0 KAPN = 0 QRHO = DSQRT ( QRHO ) NU = IDINT ( 3 + ( 1442 / ( 26 * QRHO + 77 ))) ELSE QRHO = ( 1 - Y ) * DSQRT ( 1 - QRHO ) H = 1.88 * QRHO H2 = 2 * H KAPN = IDNINT ( 7 + 34 * QRHO ) NU = IDNINT ( 16 + 26 * QRHO ) ENDIF B = ( H . GT . 0.0 ) IF ( B ) QLAMBDA = H2 ** KAPN RX = 0.0 RY = 0.0 SX = 0.0 SY = 0.0 DO 11 N = NU , 0 , - 1 NP1 = N + 1 TX = YABS + H + NP1 * RX TY = XABS - NP1 * RY C = 0.5 / ( TX ** 2 + TY ** 2 ) RX = C * TX RY = C * TY IF (( B ). AND .( N . LE . KAPN )) THEN TX = QLAMBDA + SX SX = RX * TX - RY * SY SY = RY * TX + RX * SY QLAMBDA = QLAMBDA / H2 ENDIF 11 CONTINUE IF ( H . EQ . 0.0 ) THEN U = FACTOR * RX V = FACTOR * RY ELSE U = FACTOR * SX V = FACTOR * SY END IF IF ( YABS . EQ . 0.0 ) U = DEXP ( - XABS ** 2 ) END IF !C  EVALUATION OF W(Z) IN THE OTHER QUADRANTS IF ( YI . LT . 0.0 ) THEN IF ( A ) THEN U2 = 2 * U2 V2 = 2 * V2 ELSE XQUAD = - XQUAD !         THE FOLLOWING IF-STATEMENT PROTECTS 2*EXP(-Z**2) !        AGAINST OVERFLOW IF (( YQUAD . GT . RMAXGONI ). OR . ( XQUAD . GT . RMAXEXP )) GOTO 100 W1 = 2 * DEXP ( XQUAD ) U2 = W1 * DCOS ( YQUAD ) V2 = - W1 * DSIN ( YQUAD ) END IF U = U2 - U V = V2 - V IF ( XI . GT . 0.0 ) V = - V ELSE IF ( XI . LT . 0.0 ) V = - V END IF RETURN 100 FLAG = . TRUE . RETURN END !************************************************************************ !*                                                                      * !*    Program to calculate the first kind modified Bessel function of   * !*    integer order N, for any REAL X, using the function BESSI(N,X).   * !*                                                                      * !* -------------------------------------------------------------------- * !* -------------------------------------------------------------------- * !*   Reference: From Numath Library By Tuan Dang Trong in Fortran 77.   * !*                                                                      * !*                               F90 Release 1.1 By J-P Moreau, Paris.  * !*                                                                      * !*   Version 1.1: corected value of P4 in BESSIO (P4=1.2067492 and not  * !*                1.2067429) Aug. 2011.                                 * !************************************************************************ ! ---------------------------------------------------------------------- double precision FUNCTION BESSI ( N , X ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) IMPLICIT INTEGER ( I - N ) !     This subroutine calculates the first kind modified Bessel function !     of integer order N, for any REAL X. We use here the classical !     recursion formula, when X > N. For X < N, the Miller's algorithm !     is used to avoid overflows. !     REFERENCE: !     C.W.CLENSHAW, CHEBYSHEV SERIES FOR MATHEMATICAL FUNCTIONS, !     MATHEMATICAL TABLES, VOL.5, 1962. ! PARAMETER ( IACC = 40 , BIGNO = 1.D10 , BIGNI = 1.D-10 ) REAL * 8 X , TOX , BIM , BI , BIP IF ( N . EQ . 0 ) THEN BESSI = BESSI0 ( X ) RETURN ENDIF IF ( N . EQ . 1 ) THEN BESSI = BESSI1 ( X ) RETURN ENDIF IF ( X . EQ . 0.D0 ) THEN BESSI = 0.D0 RETURN ENDIF TOX = 2.D0 / X BIP = 0.D0 BI = 1.D0 BESSI = 0.D0 M = 2 * (( N + INT ( SQRT ( FLOAT ( IACC * N ))))) DO 12 J = M , 1 , - 1 BIM = BIP + DFLOAT ( J ) * TOX * BI BIP = BI BI = BIM IF ( ABS ( BI ). GT . BIGNO ) THEN BI = BI * BIGNI BIP = BIP * BIGNI BESSI = BESSI * BIGNI ENDIF IF ( J . EQ . N ) BESSI = BIP 12 CONTINUE BESSI = BESSI * BESSI0 ( X ) / BI RETURN END ! ---------------------------------------------------------------------- ! Auxiliary Bessel functions for N=0, N=1 double precision FUNCTION BESSI0 ( X ) REAL * 8 X , Y , P1 , P2 , P3 , P4 , P5 , P6 , P7 , & Q1 , Q2 , Q3 , Q4 , Q5 , Q6 , Q7 , Q8 , Q9 , AX , BX DATA P1 , P2 , P3 , P4 , P5 , P6 , P7 / 1.D0 , 3.5156229D0 , 3.0899424D0 , 1.2067492D0 , & 0.2659732D0 , 0.360768D-1 , 0.45813D-2 / DATA Q1 , Q2 , Q3 , Q4 , Q5 , Q6 , Q7 , Q8 , Q9 / 0.39894228D0 , 0.1328592D-1 , & 0.225319D-2 , - 0.157565D-2 , 0.916281D-2 , - 0.2057706D-1 , & 0.2635537D-1 , - 0.1647633D-1 , 0.392377D-2 / IF ( ABS ( X ). LT . 3.75D0 ) THEN Y = ( X / 3.75D0 ) ** 2 BESSI0 = P1 + Y * ( P2 + Y * ( P3 + Y * ( P4 + Y * ( P5 + Y * ( P6 + Y * P7 ))))) ELSE AX = ABS ( X ) Y = 3.75D0 / AX BX = EXP ( AX ) / SQRT ( AX ) AX = Q1 + Y * ( Q2 + Y * ( Q3 + Y * ( Q4 + Y * ( Q5 + Y * ( Q6 + Y * ( Q7 + Y * ( Q8 + Y * Q9 ))))))) BESSI0 = AX * BX ENDIF RETURN END ! ---------------------------------------------------------------------- double precision FUNCTION BESSI1 ( X ) REAL * 8 X , Y , P1 , P2 , P3 , P4 , P5 , P6 , P7 , & Q1 , Q2 , Q3 , Q4 , Q5 , Q6 , Q7 , Q8 , Q9 , AX , BX DATA P1 , P2 , P3 , P4 , P5 , P6 , P7 / 0.5D0 , 0.87890594D0 , 0.51498869D0 , & 0.15084934D0 , 0.2658733D-1 , 0.301532D-2 , 0.32411D-3 / DATA Q1 , Q2 , Q3 , Q4 , Q5 , Q6 , Q7 , Q8 , Q9 / 0.39894228D0 , - 0.3988024D-1 , & - 0.362018D-2 , 0.163801D-2 , - 0.1031555D-1 , 0.2282967D-1 , & - 0.2895312D-1 , 0.1787654D-1 , - 0.420059D-2 / IF ( ABS ( X ). LT . 3.75D0 ) THEN Y = ( X / 3.75D0 ) ** 2 BESSI1 = X * ( P1 + Y * ( P2 + Y * ( P3 + Y * ( P4 + Y * ( P5 + Y * ( P6 + Y * P7 )))))) ELSE AX = ABS ( X ) Y = 3.75D0 / AX BX = EXP ( AX ) / SQRT ( AX ) AX = Q1 + Y * ( Q2 + Y * ( Q3 + Y * ( Q4 + Y * ( Q5 + Y * ( Q6 + Y * ( Q7 + Y * ( Q8 + Y * Q9 ))))))) BESSI1 = AX * BX ENDIF RETURN END ! ---------------------------------------------------------------------- end module alps_nhds","tags":"","loc":"sourcefile/alps_nhds.f90.html"},{"title":"ALPS_check.f90 – ALPS","text":"Contents Modules alps_check Source Code ALPS_check.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_check implicit none public :: check_parameters !private :: contains subroutine check_parameters implicit none write ( * , '(a)' ) \"Running parameter checks...\" ! THIS IS THE POINT WHERE WE WILL ADD THE PARAMETER CHECKS write ( * , '(a)' ) \" Parameter checks completed.\" write ( * , '(a)' ) \"-=-=-=-=-=-=-=-=-\" end subroutine end module","tags":"","loc":"sourcefile/alps_check.f90.html"},{"title":"ALPS_io.f90 – ALPS","text":"Contents Modules alps_io Source Code ALPS_io.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_io implicit none !Numbers for identifying input/output files integer :: unit integer , parameter :: stdout_unit = 6 integer , save :: input_unit_no , error_unit_no = stdout_unit private :: get_runname , get_indexed_namelist_unit private :: input_unit_exist , input_unit private :: map_read , solution_read , spec_read , scan_read , bM_read public :: init_param , read_f0 , get_unused_unit , alps_error public :: output_time , display_credits , isnancheck contains !-=-=-=-=- !Read in System parameters from *.in file !Only processor 0 calls this routine !-=-=-=-=- subroutine init_param use alps_var , only : runname , foldername , kperp , kpar , option , nroots , D_prec , D_gap use alps_var , only : kperp_last , kpar_last , kperp_0 , kpar_0 use alps_var , only : use_map , writeOut , wroots , nspec , numroots use alps_var , only : nperp , npar , arrayName , fit_check , param_fit , fit_type , perp_correction use alps_var , only : ns , qs , ms , vA , Bessel_zero , numiter , D_threshold , positions_principal use alps_var , only : determine_minima , n_resonance_interval , ngamma , npparbar , Tlim use alps_var , only : scan_option , n_scan , scan , relativistic , logfit , usebM use alps_var , only : maxsteps_fit , n_fits , lambda_initial_fit , lambdafac_fit , epsilon_fit use alps_var , only : bMnmaxs , bMBessel_zeros , bMbetas , bMalphas , bMpdrifts implicit none integer :: ik , is , ifit , ip !Solution, species, fit, additional index !Namelist read in from input file. nameList / system / & kperp , kpar , nspec , option , nroots , use_map , writeOut ,& nperp , npar , ngamma , npparbar , vA , arrayName , Bessel_zero , numiter , D_threshold , & D_prec , D_gap , positions_principal , Tlim , & maxsteps_fit , lambda_initial_fit , lambdafac_fit , epsilon_fit , fit_check , & determine_minima , n_resonance_interval , scan_option , n_scan !Get a unassigned unit number for input/output call get_unused_unit ( input_unit_no ) !Read in system parameters !runname called earlier in alps_error_init unit = input_unit_no open ( unit = unit , file = trim ( foldername ) // trim ( runname ) // \".in\" , status = 'old' , action = 'read' ) read ( unit = unit , nml = system ) if ( writeOut ) & write ( * , '(2a)' ) & 'Reading from Input File: ' , trim ( runname ) !save initial kperp,kpar values kperp_last = kperp ; kpar_last = kpar kperp_0 = kperp ; kpar_0 = kpar !Allocate solution space for nroots dispersion solutions allocate ( wroots ( 1 : numroots )); wroots = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) !Read in map scan parameters if ( use_map ) then if ( writeOut ) & write ( * , '(a)' ) 'MAP ROUTINE' ik = 1 !Either read in parameters for complex frequency map !Some FORTRAN compliers require namelists to be the first !declared item, thus requiring a separate subroutine unit = input_unit_no call get_indexed_namelist_unit ( unit , \"maps\" , ik ) call map_read close ( unit ) else !OR !read in guesses for solutions if ( writeOut ) & write ( * , '(a)' ) 'GUESS ROUTINE: ' do ik = 1 , nroots unit = input_unit_no call get_indexed_namelist_unit ( unit , \"guess\" , ik ) !Some FORTRAN compliers require namelists to be the first !declared item, thus requiring a separate subroutine) call solution_read ( ik ) write ( * , '(a,i3,a,2es14.4)' ) 'Intial Guess ' , ik , ' : ' , wroots ( ik ) close ( unit ) enddo endif !read in species density, charge, and mass from input file if ( writeOut ) & write ( * , '(a)' ) 'SPECIES PARAMETERS: ' allocate ( ns ( 1 : nspec )); ns = 0.d0 allocate ( qs ( 1 : nspec )); qs = 0.d0 allocate ( ms ( 1 : nspec )); ms = 0.d0 allocate ( n_fits ( 1 : nspec )); n_fits = 1 allocate ( relativistic ( 1 : nspec )); relativistic = . FALSE . allocate ( logfit ( 1 : nspec )); logfit = . TRUE . allocate ( usebM ( 1 : nspec )); usebM = . TRUE . allocate ( bMnmaxs ( 1 : nspec )); bMnmaxs = 500 allocate ( bMBessel_zeros ( 1 : nspec )); bMBessel_zeros = 1.d-50 allocate ( bMbetas ( 1 : nspec )); bMbetas = 1.d0 allocate ( bMalphas ( 1 : nspec )); bMalphas = 1.d0 allocate ( bMpdrifts ( 1 : nspec )); bMpdrifts = 0.d0 do is = 1 , nspec !READ IN SPECIES PARAMETERS unit = input_unit_no call get_indexed_namelist_unit ( unit , \"spec\" , is ) !Some FORTRAN compliers require namelists to be the first !declared item, thus requiring a separate subroutine) call spec_read ( is ) write ( * , '(a,i3,a)' ) 'Species ' , is , ' : ' write ( * , '(a,es11.4,a,es11.4,a,es11.4)' )& ' ns/nREF = ' , ns ( is ), ' | qs/qREF = ' , qs ( is ), ' | ms/mREF = ' , ms ( is ) write ( * , '(a,i4)' )& ' Number of fitted functions = ' , n_fits ( is ) if ( n_fits ( is ). EQ . 0 ) & write ( * , '(a)' ) ' Using function defined in distribution/distribution_analyt.f90' write ( * , '(a,l1)' )& ' Relativistic effects = ' , relativistic ( is ) close ( unit ) enddo !I assume that n_fits for any species won't be more than 10 smaller !than the n_fits(ref). KGK -------> If we do it here, we don't have to assume that. DV 2016-05-18 !Quite right. A much cleaner solution. KGK- 2016-05-18 allocate ( param_fit ( 1 : nspec , 0 : max ( nperp , ngamma ), 5 , maxval ( n_fits ))) allocate ( fit_type ( 1 : nspec , maxval ( n_fits ))) allocate ( perp_correction ( 1 : nspec , maxval ( n_fits ))) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' do is = 1 , nspec !READ IN SPECIES FIT PARAMETERS if ( usebM ( is )) then write ( * , '(a,i2,a)' ) 'Species ' , is , ' uses bi-Maxwellian calculation...skipping fits. Parameters:' call get_indexed_namelist_unit ( unit , \"bM_spec\" , is ) call bM_read ( is ) write ( * , '(a,i4,a,es11.4)' )& '  nmax = ' , bMnmaxs ( is ), ',        Bessel_zero = ' , bMBessel_zeros ( is ) write ( * , '(a,es11.4,a,es11.4,a,es11.4)' )& '  beta = ' , bMbetas ( is ), ', alpha = ' , bMalphas ( is ), ', drift momentum = ' , bMpdrifts ( is ) close ( unit ) else do ifit = 1 , n_fits ( is ) !call get_indexed_namelist_unit (unit, \"ffit\", ifit) call get_indexed_double_namelist_unit ( unit , \"ffit\" , is , ifit ) call fit_read ( is , ifit ) select case ( fit_type ( is , ifit )) case ( 1 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', Maxwellian fit: ' case ( 2 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', kappa fit: ' case ( 3 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', Juettner fit (pperp and ppar): ' case ( 4 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', Juettner fit (gamma-dependent only): ' case ( 5 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', Juettner fit (gamma and pparbar): ' case ( 6 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', bi-Moyal fit: ' case default write ( * , '(a)' )& 'Function fit undefined' stop end select do ip = 1 , 5 write ( * , '(a,i2,a,es14.4)' )& ' Initial fit parameter ' , ip , ' = ' , param_fit ( is , 0 , ip , ifit ) enddo write ( * , '(a,es14.4)' )& ' Perpendicular correction:  ' , perp_correction ( is , ifit ) close ( unit ) enddo endif enddo !Read in selection for scan paramter if ( n_scan . gt . 0 ) then write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' allocate ( scan ( n_scan )) do ip = 1 , n_scan unit = input_unit_no call get_indexed_namelist_unit ( unit , \"scan_input\" , ip ) call scan_read ( ip ) close ( unit ) enddo write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' endif close ( unit ) end subroutine init_param !-=-=-=-=- !-=-=-=-=- !-=-=-=-=- !Subroutine for reading in map parameters !-=-=-=-=- subroutine map_read !KGK use alps_var , only : loggridw , loggridg , omi , omf , gami , gamf , ni , nr implicit none nameList / maps / & loggridw , loggridg , omi , omf , gami , gamf , ni , nr read ( unit = unit , nml = maps ) end subroutine map_read !-=-=-=-=- !-=-=-=-=- !-=-=-=-=- !Subroutine for reading in initial guesses for dispersion solutions !-=-=-=-=- subroutine solution_read ( ik ) use alps_var , only : wroots implicit none !Passed integer :: ik !solution index !Local double precision :: g_om , g_gam !Guesses for (real, imaginary) solution nameList / guess / & g_om , g_gam read ( unit = unit , nml = guess ) wroots ( ik ) = cmplx ( g_om , g_gam , kind ( 1.d0 )) end subroutine solution_read !-=-=-=-=- !-=-=-=-=- !-=-=-=-=- !Subroutine for reading in species parameters !-=-=-=-=- subroutine spec_read ( is ) use alps_var , only : ns , qs , ms , n_fits , relativistic , logfit , usebM implicit none !Passed integer :: is !species index !Local double precision :: nn , qq , mm ! Read in values for ns, qs, ms integer :: ff !read in value for number of fitted functions for species logical :: relat = . false . logical :: log_fit = . true . logical :: use_bM = . false . nameList / spec / & nn , qq , mm , ff , relat , log_fit , use_bM read ( unit = unit , nml = spec ) ns ( is ) = nn ; qs ( is ) = qq ; ms ( is ) = mm ; n_fits ( is ) = ff ; relativistic ( is ) = relat ; & logfit ( is ) = log_fit ; usebM ( is ) = use_bM end subroutine spec_read !-=-=-=-=- !-=-=-=-=- !Subroutine for reading in bi-Maxwellian parameters !-=-=-=-=- subroutine bM_read ( is ) use alps_var , only : bMnmaxs , bMBessel_zeros , bMbetas , bMalphas , bMpdrifts implicit none !Passed integer :: is !species index !Local integer :: bM_nmaxs double precision :: bM_Bessel_zeros , bM_betas , bM_alphas , bM_pdrifts nameList / bM_spec / & bM_nmaxs , bM_Bessel_zeros , bM_betas , bM_alphas , bM_pdrifts read ( unit = unit , nml = bM_spec ) bMnmaxs ( is ) = bM_nmaxs ; bMBessel_zeros ( is ) = bM_Bessel_zeros ; bMbetas ( is ) = bM_betas ; & bMalphas ( is ) = bM_alphas ; bMpdrifts ( is ) = bM_pdrifts end subroutine bM_read !-=-=-=-=- !-=-=-=-=- !Subroutine for reading in wavevector scan parameters !-=-=-=-=- subroutine scan_read ( is ) use alps_var , only : scan , kperp_last , kpar_last implicit none !Passed integer :: is !scan index !Local integer :: scan_type , ns , nres double precision :: swi , swf logical :: swlog , heating , eigen double precision :: theta_0 double precision :: k_0 nameList / scan_input / & scan_type , swi , swf , swlog , ns , nres ,& heating , eigen read ( unit = unit , nml = scan_input ) scan ( is )% range_i = swi scan ( is )% range_f = swf scan ( is )% log_scan = swlog scan ( is )% type_s = scan_type scan ( is )% n_out = ns scan ( is )% n_res = nres scan ( is )% eigen_s = eigen scan ( is )% heat_s = heating !calculate step size select case ( scan_type ) case ( 0 ) !scan from k_0 to k_1 write ( * , '(a,i0,a,es12.3,a,es12.3,a,es12.3,a,es12.3,a)' )& 'Scan ' , is , ': (kpar,kperp) from (' ,& kperp_last , ',' , kpar_last , ') to (' , swi , ',' , swf , ')' if ( swlog ) then scan ( is )% diff = ( log10 ( swi ) - log10 ( kperp_last )) / ( 1.d0 * ns * nres ) scan ( is )% diff2 = ( log10 ( swf ) - log10 ( kpar_last )) / ( 1.d0 * ns * nres ) else scan ( is )% diff = ( swi - kperp_last ) / ( 1.d0 * ns * nres ) scan ( is )% diff2 = ( swf - kpar_last ) / ( 1.d0 * ns * nres ) endif kperp_last = swi ; kpar_last = swf case ( 1 ) !scan from theta_0 to theta_1 theta_0 = atan ( kperp_last / kpar_last ); k_0 = sqrt ( kperp_last ** 2 + kpar_last ** 2 ) write ( * , '(a,i0,a,es12.3,a,es12.3)' )& 'Scan ' , is , ': theta from ' ,& theta_0 * 18 0.d0 / ( 4.d0 * atan ( 1.d0 )), ' to ' , swf if ( swlog ) then scan ( is )% diff = ( log10 ( swf * 4.d0 * atan ( 1.d0 ) / 18 0. ) - log10 ( theta_0 )) / ( 1.d0 * ns * nres ) else scan ( is )% diff = (( swf * 4.d0 * atan ( 1.d0 ) / 18 0. ) - theta_0 ) / ( 1.d0 * ns * nres ) endif kpar_last = k_0 * cos ( swf * 4.d0 * atan ( 1.d0 ) / 18 0.d0 ) kperp_last = k_0 * sin ( swf * 4.d0 * atan ( 1.d0 ) / 18 0.d0 ) case ( 2 ) !scan from |k_0| to |k_1| at constant theta theta_0 = atan ( kperp_last / kpar_last ); k_0 = sqrt ( kperp_last ** 2 + kpar_last ** 2 ) write ( * , '(a,i0,a,es12.3,a,es12.3,a,es12.3,a,es12.3,a)' )& 'Scan ' , is , ': |k| from ' ,& k_0 , ' to ' , swf , ' at theta=' , theta_0 * 18 0.d0 / ( 4.d0 * atan ( 1.d0 )) if ( swlog ) then scan ( is )% diff = ( log10 ( swf * sin ( theta_0 )) - log10 ( kperp_last )) / ( 1.d0 * ns * nres ) scan ( is )% diff2 = ( log10 ( swf * cos ( theta_0 )) - log10 ( kpar_last )) / ( 1.d0 * ns * nres ) else scan ( is )% diff = ( swf * sin ( theta_0 ) - kperp_last ) / ( 1.d0 * ns * nres ) scan ( is )% diff2 = ( swf * cos ( theta_0 ) - kpar_last ) / ( 1.d0 * ns * nres ) endif kpar_last = swf * cos ( theta_0 ) kperp_last = swf * sin ( theta_0 ) case ( 3 ) !scan of kperp; kpar constant write ( * , '(a,i0,a,es12.3,a,es12.3)' )& 'Scan ' , is , ': kperp from ' , kperp_last , ' to ' , swf if ( swlog ) then scan ( is )% diff = ( log10 ( swf ) - log10 ( kperp_last )) / ( 1.d0 * ns * nres ) else scan ( is )% diff = ( swf - kperp_last ) / ( 1.d0 * ns * nres ) endif kperp_last = swf case ( 4 ) !scan of kpar; kperp constant write ( * , '(a,i0,a,es12.3,a,es12.3)' )& 'Scan ' , is , ': kpar from ' , kpar_last , ' to ' , swf if ( swlog ) then scan ( is )% diff = ( log10 ( swf ) - log10 ( kpar_last )) / ( 1.d0 * ns * nres ) else scan ( is )% diff = ( swf - kpar_last ) / ( 1.d0 * ns * nres ) endif kpar_last = swf end select end subroutine scan_read !-=-=-=-=- !-=-=-=-=- !-=-=-=-=- !Subroutine for reading in species parameters !-=-=-=-=- subroutine fit_read ( is , ifit ) use alps_var , only : fit_type , param_fit , perp_correction implicit none !Passed integer :: is , ifit !species,  index !Local double precision :: fit_1 , fit_2 , fit_3 , fit_4 , fit_5 ! Read in values for fit functions double precision :: perpcorr integer :: fit_type_in !read in value for type of analytic function nameList / ffit / & fit_type_in , fit_1 , fit_2 , fit_3 , fit_4 , fit_5 , perpcorr fit_1 = 0.d0 ; fit_2 = 0.d0 ; fit_3 = 0.d0 ; fit_4 = 0.d0 ; fit_5 = 0.d0 ; perpcorr = 0.d0 read ( unit = unit , nml = ffit ) fit_type ( is , ifit ) = fit_type_in param_fit ( is , 0 , 1 , ifit ) = fit_1 param_fit ( is , 0 , 2 , ifit ) = fit_2 param_fit ( is , 0 , 3 , ifit ) = fit_3 param_fit ( is , 0 , 4 , ifit ) = fit_4 param_fit ( is , 0 , 5 , ifit ) = fit_5 perp_correction ( is , ifit ) = perpcorr end subroutine fit_read !-=-=-=-=- !-=-=-=-=- !-=-=-=-=- ! Get runname for output files from input argument !-=-=-=-=- subroutine get_runname ( runname , foldername ) implicit none integer :: l integer :: pathend character ( 500 ) :: arg character ( 500 ), intent ( out ) :: runname character ( 500 ), intent ( out ) :: foldername !Get the first argument of the program execution command call getarg ( 1 , arg ) pathend = 0 !Check if this is the input file and trim .in extension to get runname !Also remove any folder structure from the runname: l = len_trim ( arg ) pathend = scan ( arg , \"/\" , . true .) if ( l > 3 . and . arg ( l - 2 : l ) == \".in\" ) then runname = arg ( pathend + 1 : l - 3 ) foldername = arg ( 1 : pathend ) end if end subroutine get_runname !-=-=-=-=- !-=-=-=-=- !-=-=-=-=- ! Subroutine for reading in background distribution function !-=-=-=-=- subroutine read_f0 use alps_var , only : nperp , npar , arrayName , f0 , pp , nspec use alps_var , only : writeOut , usebM implicit none !Local integer :: iperp , ipar !parallel and perpendicular indices integer :: is !species index character ( 100 ) :: readname if ( writeOut ) & write ( * , '(2a)' )& 'Attempting to read f0 array from file: ' , trim ( arrayName ) call get_unused_unit ( input_unit_no ) unit = input_unit_no !The f0 arrays are stored in the distribution folder !arrayName is read in from *.in input file !each species is has a unique file for f0 and pp do is = 1 , nspec if ( usebM ( is )) then write ( * , '(a,i2)' ) ' Bi-Maxwellian calcuation: not reading f0 array for species ' , is f0 ( is ,:,:) = 0.d0 pp ( is ,:,:,:) = 0.d0 else write ( readname , '(3a,i0,a)' ) & \"distribution/\" , trim ( arrayName ), '.' , is , \".array\" open ( unit = unit , file = trim ( readname ), status = 'old' , action = 'read' ) do iperp = 0 , nperp do ipar = 0 , npar !read in: pperp, ppar, f0 read ( unit , * ) pp ( is , iperp , ipar , 1 ), pp ( is , iperp , ipar , 2 ), f0 ( is , iperp , ipar ) enddo enddo close ( unit ) endif enddo end subroutine read_f0 !-=-=-=-=- !-=-=-=-=- !-=-=-=-=-=- !The following routines: !    get_indexed_namelist_unit !    input_unit_exist !    get_unused_unit !    input_unit !were all adopted from the Astrophysical Gyrokinetic Code (AGK) !as a means of allowing arbitrary namelist group name input. !A bit of hassle, but worth the effort. !-=-=-=-=-=- subroutine get_indexed_namelist_unit ( unit , nml , index_in ) use alps_var , only : runname implicit none integer , intent ( out ) :: unit character ( * ), intent ( in ) :: nml integer , intent ( in ) :: index_in character ( 500 ) :: line integer :: iunit , iostat , in_file integer :: ind_slash logical :: exist call get_unused_unit ( unit ) ind_slash = index ( runname , \"/\" ,. True .) if ( ind_slash . EQ . 0 ) then !No slash in name !Original behaviour open ( unit = unit , file = '.' // trim ( runname ) // '.scratch' ) else !General behaviour open ( unit = unit , file = trim ( runname ( 1 : ind_slash )) // \".\" // trim ( runname ( ind_slash + 1 :)) // \".scratch\" ) endif write ( line , * ) index_in line = nml // \"_\" // trim ( adjustl ( line )) in_file = input_unit_exist ( trim ( line ), exist ) if ( exist ) then iunit = input_unit ( trim ( line )) else call alps_error ( 1 ) !return end if read ( unit = iunit , fmt = \"(a)\" ) line write ( unit = unit , fmt = \"('&',a)\" ) nml do read ( unit = iunit , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 . or . trim ( adjustl ( line )) == \"/\" ) exit write ( unit = unit , fmt = \"(a)\" ) trim ( line ) end do write ( unit = unit , fmt = \"('/')\" ) rewind ( unit = unit ) end subroutine get_indexed_namelist_unit !KGK- a work around to allow fit parameter readins for !an arbitrary number of species for an arbitrary number of fitted functions subroutine get_indexed_double_namelist_unit ( unit , nml , spec_in , index_in ) use alps_var , only : runname implicit none integer , intent ( out ) :: unit character ( * ), intent ( in ) :: nml integer , intent ( in ) :: index_in integer , intent ( in ) :: spec_in character ( 500 ) :: line , lines integer :: iunit , iostat , in_file integer :: ind_slash logical :: exist call get_unused_unit ( unit ) ind_slash = index ( runname , \"/\" ,. True .) if ( ind_slash . EQ . 0 ) then !No slash in name !Original behaviour open ( unit = unit , file = '.' // trim ( runname ) // '.scratch' ) else !General behaviour open ( unit = unit , file = trim ( runname ( 1 : ind_slash )) // \".\" // trim ( runname ( ind_slash + 1 :)) // \".scratch\" ) endif write ( line , * ) index_in write ( lines , * ) spec_in line = nml // \"_\" // trim ( adjustl ( lines )) // \"_\" // trim ( adjustl ( line )) in_file = input_unit_exist ( trim ( line ), exist ) if ( exist ) then iunit = input_unit ( trim ( line )) else call alps_error ( 1 ) end if read ( unit = iunit , fmt = \"(a)\" ) line write ( unit = unit , fmt = \"('&',a)\" ) nml do read ( unit = iunit , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 . or . trim ( adjustl ( line )) == \"/\" ) exit write ( unit = unit , fmt = \"(a)\" ) trim ( line ) end do write ( unit = unit , fmt = \"('/')\" ) rewind ( unit = unit ) end subroutine get_indexed_double_namelist_unit function input_unit_exist ( nml , exist ) implicit none character ( * ), intent ( in ) :: nml logical , intent ( out ) :: exist integer :: input_unit_exist , iostat character ( 500 ) :: line intrinsic adjustl , trim input_unit_exist = input_unit_no exist = . true . if ( input_unit_no > 0 ) then rewind ( unit = input_unit_no ) do read ( unit = input_unit_no , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) then rewind ( unit = input_unit_no ) exit end if if ( trim ( adjustl ( line )) == \"&\" // nml ) then backspace ( unit = input_unit_no ) return end if end do end if exist = . false . end function input_unit_exist function input_unit ( nml ) implicit none character ( * ), intent ( in ) :: nml integer :: input_unit , iostat character ( 500 ) :: line intrinsic adjustl , trim input_unit = input_unit_no if ( input_unit_no > 0 ) then rewind ( unit = input_unit_no ) do read ( unit = input_unit_no , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) then rewind ( unit = input_unit_no ) exit end if if ( trim ( adjustl ( line )) == \"&\" // nml ) then backspace ( unit = input_unit_no ) return end if end do end if write ( unit = error_unit_no , fmt = \"('Couldn''t find namelist: ',a)\" ) nml write ( unit =* , fmt = \"('Couldn''t find namelist: ',a)\" ) nml end function input_unit subroutine get_unused_unit ( unit ) implicit none integer , intent ( out ) :: unit logical :: od unit = 50 do inquire ( unit = unit , opened = od ) if (. not . od ) return unit = unit + 1 end do end subroutine get_unused_unit !-=-=-=-=-=- !Open a file for the error log subroutine alps_error_init use alps_var , only : unit_error , runname , foldername implicit none call get_unused_unit ( unit_error ) !Get the run name, which comes from the name !of the input file appended after the executable: !mpirun -np 8 ./alps.e sample.in !yields a run name of 'sample' call get_runname ( runname , foldername ) open ( unit = unit_error , file = trim ( foldername ) // trim ( runname ) // \".log\" , status = 'replace' ) end subroutine alps_error_init !Error catching subroutine subroutine alps_error ( error_id ) use alps_var , only : ierror , unit_error , nproc , scan_option use mpi implicit none integer :: error_id !    if (proc0) then select case ( error_id ) case ( 0 ) !seen by all processors write ( * , '(a,i6)' ) 'ERROR: Number of processors must be even and greater than 2: nproc= ' , nproc write ( unit_error , '(a,i6)' ) 'ERROR: Number of processors must be even and greater than 2: nproc= ' , nproc case ( 1 ) !seen by proc0 write ( * , '(2a)' ) \"get_indexed_namelist: required input namelist not found \" write ( unit_error , '(2a)' ) \"get_indexed_namelist: required input namelist not found \" case ( 2 ) !seen by proc0 write ( * , '(a)' ) \"ERROR: More fit parameters than data points.\" write ( unit_error , '(a)' ) \"ERROR: More fit parameters than data points.\" case ( 3 ) !seen by all processors write ( * , '(a,i6)' )& 'ERROR: scan_option not set to allowable value:' , scan_option write ( unit_error , '(a,i6)' )& 'ERROR: scan_option not set to allowable value:' , scan_option case ( 4 ) !seen by all processors write ( * , '(a)' )& 'ERROR: n_scan .ne.2 for scan_option=2' write ( unit_error , '(a)' )& 'ERROR: n_scan .ne.2 for scan_option=2' case ( 5 ) !seen by all processors write ( * , '(a)' )& 'ERROR: scan(1)%type_s==scan(2)%type_s for double k scan' write ( unit_error , '(a)' )& 'ERROR: scan(1)%type_s==scan(2)%type_s for double k scan' case ( 6 ) !seen by all processors write ( * , '(a)' )& 'ERROR: scan(*)%type_s=0 not allowed for double k scan' write ( unit_error , '(a)' )& 'ERROR: scan(*)%type_s=0 not allowed for double k scan' case ( 7 ) !seen by all processors write ( * , '(a)' )& 'ERROR: Fit for analytical continuation failed. Adjustment of perpcorr may resolve this problem.' write ( unit_error , '(a)' )& 'ERROR: Fit for analytical continuation failed. Adjustment of perpcorr may resolve this problem.' case ( 8 ) !seen by all processors write ( * , '(a)' )& 'ERROR: Resonance integration covers entire subluminal cone.' write ( * , '(a)' )& '       Adjustment of positions_principal, npar, or a non-relativistic run may resolve this problem.' write ( unit_error , '(a)' )& 'ERROR: Resonance integration covers entire subluminal cone.' write ( unit_error , '(a)' )& '       Adjustment of positions_principal, npar, or a non-relativistic run may resolve this problem.' case ( 9 ) !seen by all processors write ( * , '(a)' )& 'ERROR: All roots diverged. Adjustment of initial guesses or step width may resolve this problem.' write ( unit_error , '(a)' )& 'ERROR: All roots diverged. Adjustment of initial guesses or step width may resolve this problem.' case default write ( * , '(a)' ) 'ERROR: Unspecified...' write ( unit_error , '(a)' ) 'ERROR: Unspecified...' end select write ( * , '(a)' ) 'Finishing ALPS==================================' write ( * , '(a)' ) \"Time:\" call output_time write ( * , '(a)' ) '================================================' !   endif close ( unit_error ) call mpi_abort ( MPI_COMM_WORLD , error_id , ierror ) stop end subroutine alps_error !checks if double precision number input is NaN logical function isnancheck ( input ) implicit none double precision :: input isnancheck = . FALSE . if ( abs ( input ). GE . huge ( 1.d0 )) isnancheck = . TRUE . !if ((input+1.d0).EQ.input) isnancheck=.TRUE. if ( input . NE . input ) isnancheck = . TRUE . end function isnancheck !-=-=-=-=-=-= !Output the date and time in a given format !-=-=-=-=-=-= subroutine output_time implicit none character ( 8 ) :: date character ( 10 ) :: time character ( 5 ) :: zone integer , dimension ( 8 ) :: value call date_and_time ( date , time , zone , value ) write ( * , '(i4,a,i2.2,a,i2.2,a,i2.2,a,i2.2,a,i2.2)' ) value ( 1 ), \"-\" , value ( 2 ), \"-\" , value ( 3 ), \" -- \" , value ( 5 ), \":\" , value ( 6 ), \":\" , value ( 7 ) end subroutine !-=-=-=-=-=-= !write the opening credits !-=-=-=-=-=-= subroutine display_credits implicit none write ( * , * ) \"===========================================================\" write ( * , * ) \"I                                                         I\" write ( * , * ) \"I                       A  L  P  S                        I\" write ( * , * ) \"I              Arbitrary Linear Plasma Solver             I\" write ( * , * ) \"I                                                         I\" write ( * , * ) \"I                       Version 1.0                       I\" write ( * , * ) \"I                                                         I\" write ( * , * ) \"I  Kristopher Klein   (kgklein@arizone.edu)               I\" write ( * , * ) \"I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)            I\" write ( * , * ) \"I                                                         I\" write ( * , * ) \"===========================================================\" end subroutine end module alps_io","tags":"","loc":"sourcefile/alps_io.f90.html"},{"title":"ALPS_com.f90 – ALPS","text":"Contents Modules alps_com Source Code ALPS_com.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_com implicit none public :: pass_instructions public :: pass_distribution contains !-=-=-=-=-=-=-=-=-= !Routine for passing information !-=-=-=-=-=-=-=-=-= subroutine pass_instructions use alps_var , only : proc0 , ierror , nroots , n_fits , param_fit , fit_type , perp_correction use alps_var , only : writeOut , nperp , npar , nmax , nlim , nspec , numroots , ngamma , npparbar use alps_var , only : ns , qs , ms , wroots , kperp , kpar , bessel_zero , D_prec use alps_var , only : wave , chi0 , pp , df0 , vA , pi , numiter , D_threshold , D_gap use alps_var , only : use_map use alps_var , only : ni , nr , omi , omf , gami , gamf , loggridg , loggridw use alps_var , only : determine_minima , n_resonance_interval , positions_principal , Tlim use alps_var , only : n_scan , scan , scan_option , relativistic , logfit , usebM use alps_var , only : bMnmaxs , bMBessel_zeros , bMbetas , bMalphas , bMpdrifts use mpi implicit none !Local integer :: is !Broadcast Global Variables needed for code execution call mpi_bcast ( nperp , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( npar , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( ngamma , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( npparbar , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( nspec , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( nroots , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( numiter , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( n_resonance_interval , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( positions_principal , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( writeOut , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( kperp , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( kpar , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( vA , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bessel_zero , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( D_threshold , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( D_prec , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( D_gap , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( Tlim , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( use_map , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( n_scan , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan_option , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) if ( use_map ) then call mpi_bcast ( omi , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( omf , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( gami , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( gamf , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( loggridw , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( loggridg , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( ni , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( nr , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( determine_minima , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) endif pi = 4.d0 * atan ( 1.d0 ) allocate ( nmax ( 1 : nspec )); nmax = 0 nlim = 0 !Point to Point Communication: if ( proc0 ) then !+ Send instructions !wroots allocated for proc0 in ALPS_io !to allow for reading in of guesses for the dispersion solution else !+ Receive instructions allocate ( ns ( 1 : nspec )); ns = 0.d0 allocate ( qs ( 1 : nspec )); qs = 0.d0 allocate ( ms ( 1 : nspec )); ms = 0.d0 allocate ( n_fits ( 1 : nspec )) allocate ( relativistic ( 1 : nspec )); relativistic = . FALSE . allocate ( logfit ( 1 : nspec )); logfit = . TRUE . allocate ( usebM ( 1 : nspec )); usebM = . TRUE . allocate ( bMnmaxs ( 1 : nspec )); bMnmaxs = 500 allocate ( bMBessel_zeros ( 1 : nspec )); bMBessel_zeros = 1.d-50 allocate ( bMbetas ( 1 : nspec )); bMbetas = 1.d0 allocate ( bMalphas ( 1 : nspec )); bMalphas = 1.d0 allocate ( bMpdrifts ( 1 : nspec )); bMpdrifts = 0.d0 !Allocate solution space for nroots dispersion solutions allocate ( wroots ( 1 : numroots )); wroots = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) if ( n_scan . gt . 0 ) allocate ( scan ( n_scan )) endif call mpi_bcast ( ns (:), size ( ns (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( qs (:), size ( qs (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( ms (:), size ( ms (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( n_fits (:), size ( n_fits (:)),& MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( relativistic (:), size ( relativistic (:)),& MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( logfit (:), size ( logfit (:)),& MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( usebM (:), size ( usebM (:)),& MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMnmaxs (:), size ( bMnmaxs (:)),& MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMBessel_zeros (:), size ( bMBessel_zeros (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMbetas (:), size ( bMbetas (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMalphas (:), size ( bMalphas (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMpdrifts (:), size ( bMpdrifts (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( wroots (:), size ( wroots (:)),& MPI_DOUBLE_COMPLEX , 0 , MPI_COMM_WORLD , ierror ) !There is a 'better' way to do this with derived data types and mpi, but this way works, !and only has to be called once. if ( n_scan . gt . 0 ) then do is = 1 , n_scan call mpi_bcast ( scan ( is )% range_i , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% range_f , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% diff , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% diff2 , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% log_scan , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% eigen_s , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% heat_s , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% type_s , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% n_out , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% n_res , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) enddo endif !Allocation of Arrays: if (. true .. neqv . proc0 ) then allocate ( param_fit ( 1 : nspec , 0 :( max ( nperp , ngamma )), 5 , maxval ( n_fits ))) allocate ( fit_type ( 1 : nspec , maxval ( n_fits ))) allocate ( perp_correction ( 1 : nspec , maxval ( n_fits ))) endif !Allocate Wave Equation Tensor !  Only needed on proc0 if ( proc0 ) then allocate ( wave ( 1 : 3 , 1 : 3 )) !KGK: added chi0 as global character allocate ( chi0 ( nspec , 1 : 3 , 1 : 3 )) wave = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) endif !Allocate derivative of f0 allocate ( df0 ( 1 : nspec , 1 : nperp - 1 , 1 : npar - 1 , 1 : 2 )); df0 = 0.d0 !Allocate fit parameters !Allocate velocity grid allocate ( pp ( 1 : nspec , 0 : nperp , 0 : npar , 1 : 2 )); pp = 0.d0 end subroutine pass_instructions !-=-=-=-=-=-=-=-=-= !Routine for passing distribution function parameters !-=-=-=-=-=-=-=-=-= subroutine pass_distribution use alps_var , only : df0 , pp , param_fit , fit_type , perp_correction , proc0 , writeOut , ierror use alps_var , only : df0_rel , gamma_rel , pparbar_rel , f0_rel use alps_var , only : relativistic , nspec , ngamma , npparbar use mpi implicit none integer :: is_rel , is , nspec_rel logical :: any_relativistic !+ Broadcast derivative array if ( writeOut . and . proc0 )& write ( * , '(a)' ) 'Broadcasting df0/dp...' any_relativistic = . FALSE . is_rel = 0 do is = 1 , nspec if ( relativistic ( is )) then any_relativistic = . TRUE . is_rel = is_rel + 1 endif enddo if ( any_relativistic ) then nspec_rel = is_rel if (. not .( proc0 )) then ! Allocate the relativistic fields: allocate ( gamma_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) allocate ( pparbar_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) allocate ( df0_rel ( nspec_rel , 0 : ngamma , 0 : npparbar , 2 )) allocate ( f0_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) endif call mpi_bcast ( f0_rel (:,:,:), size ( f0_rel (:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( df0_rel (:,:,:,:), size ( df0_rel (:,:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( gamma_rel (:,:,:), size ( gamma_rel (:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( pparbar_rel (:,:,:), size ( pparbar_rel (:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) endif call mpi_bcast ( df0 (:,:,:,:), size ( df0 (:,:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( pp (:,:,:,:), size ( pp (:,:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( param_fit (:,:,:,:), size ( param_fit (:,:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( fit_type (:,:), size ( fit_type (:,:)),& MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( perp_correction (:,:), size ( perp_correction (:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) if ( writeOut . and . proc0 )& write ( * , '(a)' ) ' df0/dp received' end subroutine pass_distribution end module alps_com","tags":"","loc":"sourcefile/alps_com.f90.html"},{"title":"ALPS_analyt.f90 – ALPS","text":"Contents Modules alps_analyt Source Code ALPS_analyt.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_analyt !! This module contains functions and subroutines for the hybrid analytical continuation. implicit none public :: eval_fit , determine_param_fit private :: fit_function , output_fit , determine_JT , LM_nonlinear_fit contains double complex function eval_fit ( is , iperp , ppar_valC ) !! This function evaluates the fit to f0 at and the complex parallel !! momentum [[eval_fit(function):ppar_valC(variable)]]. It requires the fit parameters that will be determined !! by the subroutine [[determine_param_fit(subroutine)]]. use alps_var , only : fit_type , pp , param_fit , n_fits , gamma_rel , nspec , relativistic use alps_distribution_analyt , only : distribution_analyt implicit none integer :: is , iperp , par_ind , ifit , n_params , is_rel , sproc_rel , is_run double precision :: pperp_val double precision , allocatable , dimension (:) :: params double complex :: ppar_valC ! Use the pre-coded distribution from distribution/distribution_analyt.f90 if ( n_fits ( is ). EQ . 0 ) then eval_fit = distribution_analyt ( is , pp ( is , iperp , 1 , 1 ), ppar_valC ) return endif n_params = 0 ! total number of fit_parameters do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) n_params = n_params + 3 ! Maxwell if ( fit_type ( is , ifit ). EQ . 2 ) n_params = n_params + 5 ! kappa if ( fit_type ( is , ifit ). EQ . 3 ) n_params = n_params + 3 ! Juettner with pperp and ppar if ( fit_type ( is , ifit ). EQ . 4 ) n_params = n_params + 1 ! Juettner with gamma and pparbar, constant in pparbar if ( fit_type ( is , ifit ). EQ . 5 ) n_params = n_params + 3 ! Juettner with gamma and pparbar with pparbar-dependence if ( fit_type ( is , ifit ). EQ . 6 ) n_params = n_params + 4 ! Bi-Moyal distribution enddo allocate ( params ( n_params )) par_ind = 0 do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell pperp_val = pp ( is , iperp , 1 , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa pperp_val = pp ( is , iperp , 1 , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) params ( ifit + par_ind + 3 ) = param_fit ( is , iperp , 4 , ifit ) params ( ifit + par_ind + 4 ) = param_fit ( is , iperp , 5 , ifit ) par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner in pperp and ppar pperp_val = pp ( is , iperp , 1 , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner in gamma and pparbar, constant in pparbar ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo pperp_val = gamma_rel ( sproc_rel , iperp , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) par_ind = par_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner in gamma and pparbar with pparbar-dependence ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo pperp_val = gamma_rel ( sproc_rel , iperp , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! Bi-Moyal pperp_val = pp ( is , iperp , 1 , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) params ( ifit + par_ind + 3 ) = param_fit ( is , iperp , 4 , ifit ) par_ind = par_ind + 3 endif enddo eval_fit = fit_function ( is , n_params , params , pperp_val , ppar_valC ) deallocate ( params ) return end function !-=-=-=-=-=-= ! This function evaluates the fit to f0 at real pperp_val and complex ppar_val ! provided that the one-dimensional fit-parameter array params is fed into the ! function. This is only used during the fitting. For the evaluation in ALPS, ! use eval_fit. !-=-=-=-=-=-= double complex function fit_function ( is , n_params , params , pperp_val , ppar_val ) use alps_var , only : fit_type , n_fits , ms , vA , perp_correction implicit none integer :: n_params , ifit , is , par_ind double precision :: params ( n_params ), pperp_val double complex :: ppar_val , sqrtpart , kappapart fit_function = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) par_ind = 0 do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( - perp_correction ( is , ifit ) * pperp_val ** 2 )& * exp ( - params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa kappapart = 1.d0 + params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 & + perp_correction ( is , ifit ) * params ( ifit + par_ind + 4 ) * pperp_val ** 2 fit_function = fit_function + params ( ifit + par_ind + 0 ) * kappapart ** params ( ifit + par_ind + 3 ) par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner in pperp and ppar sqrtpart = sqrt ( 1.d0 + ( pperp_val ** 2 + ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) * vA * vA / ( ms ( is ) * ms ( is ))) fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( - params ( ifit + par_ind + 1 ) * sqrtpart ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner in gamma only, constant in pparbar fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( - perp_correction ( is , ifit ) * pperp_val ) par_ind = par_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner in gamma and pparbar with pparbar-dependence fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( - perp_correction ( is , ifit ) * pperp_val ) * & exp ( - params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! Bi-Moyal fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( 0.5d0 * ( params ( ifit + par_ind + 3 ) * & perp_correction ( is , ifit ) * pperp_val ** 2 + params ( ifit + par_ind + 1 ) * & ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 - & exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) )) par_ind = par_ind + 3 endif enddo return end function !-=-=-=-=-=-= ! This is the fitting routine for the hybrid analytic continuation. It determines ! the full field param_fit. !-=-=-=-=-=-= subroutine determine_param_fit use alps_var , only : writeOut , fit_type , param_fit , n_fits , nspec , f0 , nperp , npar , logfit , runname use alps_var , only : relativistic , npparbar , f0_rel , ngamma , perp_correction , gamma_rel , usebM implicit none integer :: ifit , n_params , par_ind , iperp , is , is_run , is_rel , sproc_rel , nJT integer :: ipparbar , ipparbar_lower , ipparbar_upper , upperlimit , unit_spec logical :: found_lower , found_upper double precision :: quality , qualitytotal logical , allocatable , dimension (:) :: param_mask double precision , allocatable , dimension (:) :: g double precision , allocatable , dimension (:) :: params character ( 10 ) :: specwrite if ( writeOut ) then write ( * , '(a)' ) 'Determine fit parameters for hybrid analytic continuation...' endif qualitytotal = 0.d0 do is = 1 , nspec if ( usebM ( is )) then write ( * , '(a,i2)' ) ' Bi-Maxwellian calcuation: no fits necessary for species ' , is param_fit ( is ,:,:,:) = 0.d0 fit_type ( is ,:) = 1 perp_correction ( is ,:) = 1.d0 elseif ( n_fits ( is ). EQ . 0 ) then write ( * , '(a,i2)' ) ' Using analytical function from distribution/distribution_analyt.f90: no fits necessary for species ' , is param_fit ( is ,:,:,:) = 0.d0 fit_type ( is ,:) = 1 perp_correction ( is ,:) = 1.d0 else ! For all fit types that include a fit parameter for the perpendicular momentum (kappa and Moyal), ! we must not fit this parameter when pperp=0. Otherwise, the LM matrix is singular: n_params = 0 ! total number of fit_parameters do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) n_params = n_params + 3 ! Maxwell if ( fit_type ( is , ifit ). EQ . 2 ) n_params = n_params + 5 ! kappa if ( fit_type ( is , ifit ). EQ . 3 ) n_params = n_params + 3 ! Juettner with pperp and ppar if ( fit_type ( is , ifit ). EQ . 4 ) n_params = n_params + 1 ! Juettner with gamma and pparbar, constant in pparbar if ( fit_type ( is , ifit ). EQ . 5 ) n_params = n_params + 3 ! Juettner with gamma and pparbar with pparbar-dependence if ( fit_type ( is , ifit ). EQ . 6 ) n_params = n_params + 4 ! Bi-Moyal enddo allocate ( params ( n_params )) allocate ( param_mask ( n_params )) if ( relativistic ( is )) then upperlimit = ngamma else upperlimit = nperp endif unit_spec = 2500 + is write ( specwrite , '(i0)' ) is open ( unit = unit_spec , file = 'distribution/' // trim ( runname ) // '.fit_parameters.' // trim ( specwrite ) // '.out' , status = 'replace' ) do iperp = 0 , upperlimit ! Every step that is not iperp = 0 should use the previous result as a start value: if ( iperp . NE . 0 ) param_fit ( is , iperp ,:,:) = param_fit ( is , iperp - 1 ,:,:) par_ind = 0 nJT = 0 param_mask = . TRUE . do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) params ( ifit + par_ind + 3 ) = param_fit ( is , iperp , 4 , ifit ) params ( ifit + par_ind + 4 ) = param_fit ( is , iperp , 5 , ifit ) if ( iperp . EQ . 0 ) then nJT = nJT - 1 param_mask ( ifit + par_ind + 4 ) = . FALSE . endif par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner in pperp and ppar params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner in gamma and pparbar, constant in pparbar params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) par_ind = par_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner in gamma and pparbar with pparbar-dependence params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! Bi-Moyal params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) params ( ifit + par_ind + 3 ) = param_fit ( is , iperp , 4 , ifit ) if ( iperp . EQ . 0 ) then nJT = nJT - 1 param_mask ( ifit + par_ind + 3 ) = . FALSE . endif par_ind = par_ind + 3 endif enddo nJT = nJT + n_params ! Fit and return everything in one array \"params\": if ( relativistic ( is )) then ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo ! What are the relevant ranges in pparbar: found_lower = . FALSE . found_upper = . FALSE . ipparbar_lower = 1 ipparbar_upper = npparbar - 1 do ipparbar = 1 , npparbar - 1 if ((. NOT . found_lower ). AND .( f0_rel ( sproc_rel , iperp , ipparbar - 1 ). LE . - 1.d0 ). AND .( f0_rel ( sproc_rel , iperp , ipparbar ). GT . - 1.d0 )) then ipparbar_lower = ipparbar found_lower = . TRUE . endif if ((. NOT . found_upper ). AND .( f0_rel ( sproc_rel , iperp , ipparbar ). GT . - 1.d0 ). AND .( f0_rel ( sproc_rel , iperp , ipparbar + 1 ). LE . - 1.d0 )) then ipparbar_upper = ipparbar found_upper = . TRUE . endif enddo if (( ipparbar_upper - ipparbar_lower ). GT . 2 ) then allocate ( g ( 0 : ipparbar_upper - ipparbar_lower )) if ( logfit ( is )) then g = log ( f0_rel ( sproc_rel , iperp , ipparbar_lower : ipparbar_upper )) else g = f0_rel ( sproc_rel , iperp , ipparbar_lower : ipparbar_upper ) endif call LM_nonlinear_fit ( is , g , n_params , nJT , params , param_mask , iperp ,& ( ipparbar_upper - ipparbar_lower ), ipparbar_lower , quality ) deallocate ( g ) else par_ind = 0 do ifit = 1 , n_fits ( is ) params ( ifit + par_ind + 0 ) = f0_rel ( sproc_rel , iperp ,( ipparbar_upper + ipparbar_lower ) / 2 ) / & exp ( - perp_correction ( is , ifit ) * gamma_rel ( sproc_rel , iperp , 1 )) if ( fit_type ( is , ifit ). EQ . 5 ) then params ( ifit + par_ind + 1 ) = 1.d-12 params ( ifit + par_ind + 2 ) = 0.d0 par_ind = par_ind + 2 endif enddo endif else ! non-relativistic allocate ( g ( 0 : npar )) if ( logfit ( is )) then g = log ( f0 ( is , iperp ,:)) else g = f0 ( is , iperp ,:) endif call LM_nonlinear_fit ( is , g , n_params , nJT , params , param_mask , iperp , npar , 0 , quality ) deallocate ( g ) endif qualitytotal = qualitytotal + quality ! Write  Fit parameters to output files write ( unit_spec , * ) iperp , params ! Fill it back into the param_fit field: par_ind = 0 do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) param_fit ( is , iperp , 4 , ifit ) = params ( ifit + par_ind + 3 ) param_fit ( is , iperp , 5 , ifit ) = params ( ifit + par_ind + 4 ) par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner in pperp and ppar param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner in gamma and pparbar, constant in pparbar param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) par_ind = par_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner in gamma and pparbar with pparbar-dependence param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! Bi-Moyal param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) param_fit ( is , iperp , 4 , ifit ) = params ( ifit + par_ind + 3 ) par_ind = par_ind + 3 endif enddo enddo ! End loop over iperp close ( unit_spec ) deallocate ( params ) deallocate ( param_mask ) endif enddo ! End loop over is if ( writeOut ) then call output_fit ( qualitytotal ) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' endif end subroutine !-=-=-=-=-=-= ! This subroutine outputs the fit parameters for iperp=0 to stdout to monitor the fit !-=-=-=-=-=-= subroutine output_fit ( qualitytotal ) use alps_io , only : isnancheck , alps_error use alps_var , only : fit_type , param_fit , n_fits , nspec , nperp , npar , pp , f0 , pi , vA , runname use alps_var , only : relativistic , gamma_rel , pparbar_rel , ngamma , npparbar , f0_rel , ms , usebM implicit none integer :: is , ifit , n_params , iparam , unit_spec , ipar , iperp , is_rel , sproc_rel , igamma , ipparbar , is_run double precision :: qualitytotal , integrate , dpperp , dppar , dgamma , dpparbar double complex :: ppar_comp character ( 10 ) :: specwrite write ( * , '(a)' ) ' Results of the fit for hybrid analytic continuation at iperp = 1:' do is = 1 , nspec do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) n_params = 3 if ( fit_type ( is , ifit ). EQ . 2 ) n_params = 5 if ( fit_type ( is , ifit ). EQ . 3 ) n_params = 3 if ( fit_type ( is , ifit ). EQ . 4 ) n_params = 1 if ( fit_type ( is , ifit ). EQ . 5 ) n_params = 3 if ( fit_type ( is , ifit ). EQ . 6 ) n_params = 4 if (. not . usebM ( is )) then do iparam = 1 , n_params write ( * , '(a,i2,a,i2,a,i2,a,2es14.4)' ) '  param_fit(' , is , ', 1,' , iparam , ',' , ifit , ') = ' , param_fit ( is , 1 , iparam , ifit ) enddo write ( * , '(a)' ) ' ' endif enddo enddo write ( * , '(a,es14.4)' ) ' Sum of all least-squares: ' , qualitytotal write ( * , '(a,es14.4)' ) ' Standard error of the estimate: ' , sqrt ( qualitytotal / ( 1.d0 * ( nspec * nperp * npar ))) if ( isnancheck ( qualitytotal )) call alps_error ( 7 ) write ( * , '(a)' ) ' Writing fit result to files' do is = 1 , nspec if (. not . usebM ( is )) then unit_spec = 2000 + is write ( specwrite , '(i0)' ) is open ( unit = unit_spec , file = 'distribution/' // trim ( runname ) // '.fit_result.' // trim ( specwrite ) // '.out' , status = 'replace' ) integrate = 0.d0 if ( relativistic ( is )) then ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo dgamma = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) do igamma = 0 , ngamma do ipparbar = 0 , npparbar ppar_comp = pparbar_rel ( sproc_rel , igamma , ipparbar ) if ( f0_rel ( sproc_rel , igamma , ipparbar ). EQ . - 1.d0 ) then write ( unit_spec , * ) gamma_rel ( sproc_rel , igamma , ipparbar ), pparbar_rel ( sproc_rel , igamma , ipparbar ),& \"-1.0\" , abs ( - 1.d0 - f0_rel ( sproc_rel , igamma , ipparbar )) else write ( unit_spec , * ) gamma_rel ( sproc_rel , igamma , ipparbar ), pparbar_rel ( sproc_rel , igamma , ipparbar ),& real ( eval_fit ( is , igamma , ppar_comp )),& abs ( real ( eval_fit ( is , igamma , ppar_comp )) - f0_rel ( sproc_rel , igamma , ipparbar )) / f0_rel ( sproc_rel , igamma , ipparbar ) integrate = integrate + & gamma_rel ( is_rel , igamma , ipparbar ) * real ( eval_fit ( is , igamma , ppar_comp )) * & 2.d0 * pi * dgamma * dpparbar * ( ms ( is ) / vA ) ** 3 endif enddo enddo else ! non-relativistic: dpperp = pp ( is , 2 , 2 , 1 ) - pp ( is , 1 , 2 , 1 ) dppar = pp ( is , 2 , 2 , 2 ) - pp ( is , 2 , 1 , 2 ) do iperp = 0 , nperp do ipar = 0 , npar ppar_comp = pp ( is , iperp , ipar , 2 ) write ( unit_spec , * ) pp ( is , iperp , ipar , 1 ), pp ( is , iperp , ipar , 2 ), real ( eval_fit ( is , iperp , ppar_comp )), & abs ( real ( eval_fit ( is , iperp , ppar_comp )) - f0 ( is , iperp , ipar )) / f0 ( is , iperp , ipar ) integrate = integrate + pp ( is , iperp , ipar , 1 ) * real ( eval_fit ( is , iperp , ppar_comp )) * & 2.d0 * pi * dpperp * dppar enddo enddo endif close ( unit_spec ) write ( * , '(a,i3,a, 2es14.4)' ) ' Integration of fit/analytical function for species' , is , ':' , integrate endif enddo end subroutine !-=-=-=-=-=-= ! This subroutine calculates the transposed Jacobian matrix of the fit function w.r.t. the ! fit parameter array. !-=-=-=-=-=-=! subroutine determine_JT ( is , n_params , nJT , JT , params , iperp , upper_limit , ipparbar_lower ) use alps_var , only : fit_type , n_fits , pp , ms , vA , perp_correction use alps_var , only : gamma_rel , pparbar_rel , nspec , relativistic implicit none integer :: n_params , ifit , par_ind , iperp , ipar , is , upper_limit , is_rel , sproc_rel , is_run , ipparbar_lower , nJT , JT_ind double precision :: ppar_val , pperp_val , params ( n_params ) double precision :: sqrtpart , expterm , kappapart , JT ( nJT , 0 : upper_limit ) if ( relativistic ( is )) then ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo endif do ipar = 0 , upper_limit if ( relativistic ( is )) then pperp_val = gamma_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) ppar_val = pparbar_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) else pperp_val = pp ( is , iperp , ipar , 1 ) ppar_val = pp ( is , iperp , ipar , 2 ) endif par_ind = 0 JT_ind = 0 do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell expterm = exp ( - params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 & - perp_correction ( is , ifit ) * pperp_val ** 2 ) JT ( ifit + JT_ind + 0 , ipar ) = expterm JT ( ifit + JT_ind + 1 , ipar ) =- (( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) * params ( ifit + par_ind + 0 ) * expterm JT ( ifit + JT_ind + 2 , ipar ) = 2.d0 * params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) * & params ( ifit + par_ind + 0 ) * expterm par_ind = par_ind + 2 JT_ind = JT_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa kappapart = 1.d0 + params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 & + perp_correction ( is , ifit ) * params ( ifit + par_ind + 4 ) * pperp_val ** 2 JT ( ifit + JT_ind + 0 , ipar ) = kappapart ** params ( ifit + par_ind + 3 ) JT ( ifit + JT_ind + 1 , ipar ) = params ( ifit + par_ind + 0 ) * params ( ifit + par_ind + 3 ) * kappapart ** ( params ( ifit + par_ind + 3 ) - 1.d0 ) * & ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 JT ( ifit + JT_ind + 2 , ipar ) = params ( ifit + par_ind + 0 ) * params ( ifit + par_ind + 3 ) * kappapart ** ( params ( ifit + par_ind + 3 ) - 1.d0 ) * & 2.d0 * params ( ifit + par_ind + 1 ) * ( params ( ifit + par_ind + 2 ) - ppar_val ) JT ( ifit + JT_ind + 3 , ipar ) = log ( kappapart ) * params ( ifit + par_ind + 0 ) * kappapart ** params ( ifit + par_ind + 3 ) if ( iperp . EQ . 0 ) then JT_ind = JT_ind + 3 else JT ( ifit + JT_ind + 4 , ipar ) = params ( ifit + par_ind + 0 ) * params ( ifit + par_ind + 3 ) * & kappapart ** ( params ( ifit + par_ind + 3 ) - 1.d0 ) * perp_correction ( is , ifit ) * pperp_val ** 2 JT_ind = JT_ind + 4 endif par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner with pperp and ppar sqrtpart = sqrt ( 1.d0 + ( pperp_val ** 2 + ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) * vA * vA / ( ms ( is ) * ms ( is ))) JT ( ifit + JT_ind + 0 , ipar ) = exp ( - params ( ifit + par_ind + 1 ) * sqrtpart ) JT ( ifit + JT_ind + 1 , ipar ) =- params ( ifit + par_ind + 0 ) * exp ( - params ( ifit + par_ind + 1 ) * sqrtpart ) * sqrtpart JT ( ifit + JT_ind + 2 , ipar ) = params ( ifit + par_ind + 0 ) * exp ( - params ( ifit + par_ind + 1 ) * sqrtpart ) * & ( params ( ifit + par_ind + 1 ) / sqrtpart ) * ( ppar_val - params ( ifit + par_ind + 2 )) * vA * vA / ( ms ( is ) * ms ( is )) par_ind = par_ind + 2 JT_ind = JT_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner with gamma and pparbar, constant in pparbar JT ( ifit + JT_ind + 0 , ipar ) = exp ( - perp_correction ( is , ifit ) * pperp_val ) par_ind = par_ind + 0 JT_ind = JT_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner with gamma and pparbar with pparbar-dependence expterm = exp ( - params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) * & exp ( - perp_correction ( is , ifit ) * pperp_val ) JT ( ifit + JT_ind + 0 , ipar ) = expterm JT ( ifit + JT_ind + 1 , ipar ) =- params ( ifit + par_ind + 0 ) * expterm * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 JT ( ifit + JT_ind + 2 , ipar ) = 2.d0 * params ( ifit + par_ind + 0 ) * ( ppar_val - params ( ifit + par_ind + 2 )) * & params ( ifit + par_ind + 1 ) * expterm par_ind = par_ind + 2 JT_ind = JT_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! bi-Moyal expterm = exp ( 0.5d0 * ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 - & exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) )) JT ( ifit + JT_ind + 0 , ipar ) = expterm JT ( ifit + JT_ind + 1 , ipar ) = params ( ifit + par_ind + 0 ) * expterm * 0.5d0 * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 * & ( 1.d0 - exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) ) JT ( ifit + JT_ind + 2 , ipar ) = params ( ifit + par_ind + 0 ) * expterm * params ( ifit + par_ind + 1 ) * & ( params ( ifit + par_ind + 2 ) - ppar_val ) * & ( 1.d0 - exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) ) if ( iperp . EQ . 0 ) then JT_ind = JT_ind + 2 else JT ( ifit + JT_ind + 3 , ipar ) = params ( ifit + par_ind + 0 ) * expterm * 0.5d0 * perp_correction ( is , ifit ) * pperp_val ** 2 * & ( 1.d0 - exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) ) JT_ind = JT_ind + 3 endif par_ind = par_ind + 3 endif enddo enddo end subroutine !-=-=-=-=-=-= ! This subroutine processes the nonlinear Levenberg-Marquart algorithm and returns ! the one-dimensional array params at a given iperp. ! quality is the sum of the squares of all residuals. !-=-=-=-=-=-= subroutine LM_nonlinear_fit ( is , g , n_params , nJT , params , param_mask , iperp , npar , ipparbar_lower , quality ) use alps_var , only : lambda_initial_fit , pp , lambdafac_fit , logfit use alps_var , only : epsilon_fit , maxsteps_fit use alps_var , only : gamma_rel , pparbar_rel , relativistic , nspec use alps_io , only : alps_error use mpi implicit none logical :: converged , param_mask ( n_params ) integer :: ipar , k , counter , is , n_params , nJT , iperp , npar , is_rel , is_run , sproc_rel , ipparbar_lower , l double precision :: LSQ , LSQnew , lambda_fit , quality , pperp_val , ppar_val double precision :: g ( 0 : npar ), params ( n_params ) double precision :: residuals ( 0 : npar ), deltaparam_fit ( nJT ) double precision :: JTJ ( nJT , nJT ), JT ( nJT , 0 : npar ) double precision :: diagmat ( nJT , nJT ), Amat ( nJT , nJT ) double precision :: work_array ( nJT ) integer :: ipiv ( nJT ), info converged = . FALSE . counter = 0 lambda_fit = lambda_initial_fit if (( 1 + npar ). LT . n_params ) call alps_error ( 2 ) if ( relativistic ( is )) then ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo endif do while (. NOT . converged ) counter = counter + 1 LSQ = 0.d0 ! Determine the transposed Jacobian and the residuals: call determine_JT ( is , n_params , nJT , JT , params , iperp , npar , ipparbar_lower ) do ipar = 0 , npar if ( relativistic ( is )) then pperp_val = gamma_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) ppar_val = pparbar_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) else pperp_val = pp ( is , iperp , ipar , 1 ) ppar_val = pp ( is , iperp , ipar , 2 ) endif if ( logfit ( is )) then do k = 1 , nJT JT ( k , ipar ) = JT ( k , ipar ) / fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 ))) enddo residuals ( ipar ) = g ( ipar ) - log ( real ( fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 ))))) else residuals ( ipar ) = g ( ipar ) - real ( fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 )))) endif ! Least squares: LSQ = LSQ + residuals ( ipar ) * residuals ( ipar ) enddo JTJ = matmul ( JT , transpose ( JT )) diagmat = 0.d0 do k = 1 , nJT diagmat ( k , k ) = JTJ ( k , k ) enddo Amat = JTJ + lambda_fit * diagmat ! The following routine is from LAPACK to invert the matrix: call dgetrf ( nJT , nJT , Amat , nJT , ipiv , info ) if ( info . NE . 0 ) stop \"Fit matrix is numerically singular.\" call dgetri ( nJT , Amat , nJT , ipiv , work_array , nJT , info ) if ( info . NE . 0 ) stop \"Fit matrix inversion failed.\" ! Now Amat is the inverse of JTJ+lambda_fit*diagmat deltaparam_fit = matmul ( Amat , matmul ( JT , residuals )) l = 0 do k = 1 , n_params if ( param_mask ( k )) then l = l + 1 params ( k ) = params ( k ) + deltaparam_fit ( l ) endif enddo ! With the new param_fit, what is the new mean square error: LSQnew = 0.d0 do ipar = 0 , npar if ( relativistic ( is )) then pperp_val = gamma_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) ppar_val = pparbar_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) else pperp_val = pp ( is , iperp , ipar , 1 ) ppar_val = pp ( is , iperp , ipar , 2 ) endif if ( logfit ( is )) then residuals ( ipar ) = g ( ipar ) - log ( real ( fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 ))))) else residuals ( ipar ) = g ( ipar ) - real ( fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 )))) endif ! Least squares: LSQnew = LSQnew + residuals ( ipar ) * residuals ( ipar ) enddo if ( LSQnew . GT . LSQ ) then l = 0 do k = 1 , n_params if ( param_mask ( k )) then l = l + 1 params ( k ) = params ( k ) - deltaparam_fit ( l ) endif enddo lambda_fit = lambda_fit * lambdafac_fit else lambda_fit = lambda_fit / lambdafac_fit endif ! Check if it converged (we can add further break criteria): if ( abs ( LSQnew - LSQ ). LT . epsilon_fit ) converged = . TRUE . if ( counter . EQ . maxsteps_fit ) converged = . TRUE . enddo quality = LSQ end subroutine end module alps_analyt","tags":"","loc":"sourcefile/alps_analyt.f90.html"},{"title":"ALPS_var.f90 – ALPS","text":"Contents Modules alps_var Source Code ALPS_var.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_var use mpi implicit none private !I/O Variables character ( 500 ) :: runname !Root of input file name character ( 500 ) :: foldername !Directory of input file name integer :: option !System Option: Chooses Style of Run !See README file for list of options integer :: nroots !Number of Dispersion Solutions !under consideration integer :: nroots_max !Number of Dispersion Solutions !found in frequency map scan logical :: use_map !Choice of !T: searching for roots over a map in complex frequency space !OR !F: input (nroots) guesses for solutions logical :: writeOut = . true . !Write or Spress output to screen integer :: unit_error !MPI variables integer :: nproc !Number of Processors (1 to nproc) integer :: iproc !Number of local processor (0 to nproc-1) logical :: proc0 !T if iproc=0 integer :: ierror !Integer error flag !Plasma Parameters !Wave vector normalized by inverse reference inertial length double precision :: kperp !Perpendicular Wave number; double precision :: kpar !Parallel Wave number; double precision :: vA !reference Alfven Velocity /c double precision :: Bessel_zero = 1.d-45 ! Use Bessel functions until ! the maximum is less than this value !The proton typically serves as the reference species. integer :: nspec !Number of plasma species integer :: nspec_rel !Number of relativistic plasma species !Solutions for dispersion surface double complex , dimension (:), allocatable :: wroots !(1:numroots) !maximum # of roots integer :: numroots = 100 !Limits on (real, imaginary) map search double precision :: omi , omf , gami , gamf !T: log spacing for complex frequency map search !F: linear spacing for complex frequency map search logical :: loggridw , loggridg !number of points in (real, imaginary) frequency space grid integer :: ni = 128 , nr = 128 !Number of Momentum Space Grid Points integer :: nperp , npar integer :: ngamma = 100 , npparbar = 200 ! How many points in ipar should be used to calculate the principal value integral? integer :: positions_principal = 5 ! Threshold for analytical principal-value integration double precision :: Tlim = 0.01d0 ! The species number on which this process is working integer :: sproc ! Maximum number of iterations in secant method integer :: numiter = 50 ! Value of \"zero\" for secant method double precision :: D_threshold = 1.d-5 ! size of bounding region for secant method double precision :: D_prec = 1.d-5 ! size of allowable difference between roots double precision :: D_gap = 1.d-5 !pi double precision :: pi !Name of input files for distributions character ( 75 ) :: arrayName !Background Distribution Function Array !f0(1:nspec,0:nperp,0:npar) double precision , dimension (:,:,:), allocatable :: f0 double precision , dimension (:,:,:), allocatable :: f0_rel !Perpendicular and parallel Derivatives of f0 !df0(1:nspec,0:nperp,0:npar,1:2) !with index 1-> dvperp !     index 2-> dvpar double precision , dimension (:,:,:,:), allocatable :: df0 double precision , dimension (:,:,:,:), allocatable :: df0_rel !Momentum Space Array for f0 !pp(1:nspec,0:nperp,0:npar,1:2) !with index 1->vperp !     index 2->vpar double precision , dimension (:,:,:,:), allocatable :: pp double precision , dimension (:,:,:), allocatable :: gamma_rel , pparbar_rel !number of n values to sum over !nmax(1:nspec) integer , dimension (:), allocatable :: nmax !Lower and Upper limits for n values for !iproc to sum over integer :: nlim ( 2 ) !Ratios of species density double precision , dimension (:), allocatable :: ns !charge double precision , dimension (:), allocatable :: qs !and mass double precision , dimension (:), allocatable :: ms !relative to the reference value. logical , dimension (:), allocatable :: relativistic !use relativistic treatment; set for each species !Wave Equation Tensor !wave(1:3, 1:3) double complex , dimension (:,:), allocatable :: wave double complex , dimension (:,:,:), allocatable :: chi0 ! Array of Bessel functions: ! bessel_array(nlim(1):nlim(2)+1,0:nperp) double precision , dimension (:,:), allocatable :: bessel_array !Fit Parameters for Hybrid-Analytical Continuation Method integer , dimension (:), allocatable :: n_fits !number of fitted functions, per species integer , dimension (:,:), allocatable :: fit_type !type of analytic function to be fit !fit_type(1:nspec,1:maxval(nfits)) integer :: maxsteps_fit = 500 !maximum number of fitting iterations double precision :: lambda_initial_fit = 1.d0 !Inital Levenberg-Marquardt damping parameter double precision :: lambdafac_fit = 1.d1 !Adjustment factor for Levenberg-Marquardt damping parameter double precision :: epsilon_fit = 1.d-8 !Convergence for fit !Fit output !param_fit(1:nspec,nperp,4,maxval(n_fits)) double precision , dimension (:,:,:,:), allocatable :: param_fit double precision , dimension (:,:), allocatable :: perp_correction logical :: fit_check = . true . !T-> output fitted functions to ASCII file for each species logical :: determine_minima = . true . ! after map search, determine minima and refine? integer :: n_resonance_interval = 100 ! how many steps should be used to integrate around the resonance integer :: scan_option = 1 !select case for scans. !1: consecutive scans along input paths in wavevector space !2: double scans of two selected parameters integer :: n_scan = 0 !number of wavevector scans. !must be set to 2 for scan_option=2 !must be 1 or larger for scan_option=1 !n_scan=0 turns off wavevector scans logical , dimension (:), allocatable :: logfit ! Use logarithmic fitting? logical , dimension (:), allocatable :: usebM ! Use bi-Maxwellian calculation from NHDS? integer , dimension (:), allocatable :: bMnmaxs ! Maximum number of n for bi-Maxwellian calculation from NHDS double precision , dimension (:), allocatable :: bMBessel_zeros ! Besser-zero for bi-Maxwellian calculation from NHDS double precision , dimension (:), allocatable :: bMbetas ! Species beta for bi-Maxwellian calculation from NHDS double precision , dimension (:), allocatable :: bMalphas ! Species temperature anisotropy for bi-Maxwellian calculation from NHDS double precision , dimension (:), allocatable :: bMpdrifts ! Species drift momentum for bi-Maxwellian calculation from NHDS public :: scanner type :: scanner double precision :: range_i !initial value double precision :: range_f !final value logical :: log_scan !T-> log, F-> linear scan logical :: heat_s !T-> heating calc; F-> no heating logical :: eigen_s !T-> eigen calc;   F-> no eigen integer :: type_s !Type of parameter scan integer :: n_out !Number of steps integer :: n_res !scan resolution double precision :: diff , diff2 !step size for scanned parameter end type scanner !-=-=-=-=-=-=-=-=- !Defines nature of parameter scans: !     Type: 0 k_0-> k_1 !           1 theta_0 -> theta_1 !           2 k_fixed angle !     Type: 3 kperp !           4 kpar !-=-=-=-=-=-=-=-=- type ( scanner ), dimension (:), allocatable :: scan double precision :: kperp_last , kpar_last double precision :: kperp_0 , kpar_0 public :: nproc , iproc , proc0 , ierror public :: runname , foldername , option , writeOut public :: kperp , kpar , nspec , use_map , wroots public :: loggridw , loggridg , omi , omf , gami , gamf public :: arrayName , nperp , npar , f0 , pp , df0 , bessel_array public :: nmax , nlim , wave , numiter , D_threshold , D_prec , D_gap , chi0 public :: ns , qs , ms , vA , pi , Bessel_zero , sproc public :: ni , nr , positions_principal , Tlim public :: n_fits , maxsteps_fit , lambda_initial_fit , lambdafac_fit , epsilon_fit public :: param_fit , fit_check , fit_type , perp_correction public :: nroots , nroots_max , numroots public :: determine_minima , n_resonance_interval public :: unit_error , scan_option , n_scan , scan public :: kperp_last , kpar_last , kperp_0 , kpar_0 public :: relativistic , logfit , usebM public :: f0_rel , df0_rel , nspec_rel , gamma_rel , pparbar_rel , ngamma , npparbar public :: bMnmaxs , bMBessel_zeros , bMbetas , bMalphas , bMpdrifts end module alps_var","tags":"","loc":"sourcefile/alps_var.f90.html"},{"title":"Readme – ALPS","text":"A  L  P  S  Arbitrary Linear Plasma Solver This is the ALPS code: the Arbitrary Linear Plasma Solver. Authors Kristopher Klein   (kgklein@arizona.edu)\nDaniel Verscharen  (d.verscharen@ucl.ac.uk) WARNING IN ITS CURRENT FORM, THE CODE IS STILL UNDER DEVELOPMENT. WE RECOMMEND THAT YOU\nUSE IT VERY CAREFULLY OR ONLY IN DIRECT COMMUNICATION WITH THE CODE DEVELOPMENT\nTEAM. THE CODE WILL BE MADE MORE USEABLE AND SUSTAINABLE IN THE FUTURE. CONTENTS What is ALPS? Acknowledgements Installing the ALPS Code Running the ALPS Code Documentation for Input/Output Data List of Error Codes License WHAT IS ALPS? ALPS is a parallelised numerical code that solves the Vlasov-Maxwell dispersion\nrelation in hot (even relativistic) magnetised plasma. ALPS allows for any\nnumber of particle species with arbitrary gyrotropic equilibrium distribution\nfunctions supporting waves with any direction of propagation with respect to\nthe background magnetic field. If you use the code for a science publication, please provide the code website\non github.com/danielver02/ALPS and cite the code paper: Verscharen, D., Klein, K. G., Chandran, B. D. G., Stevens, M. L., Salem, C. S.,\nand Bale, S. D.: ALPS: the Arbitrary Linear Plasma Solver, J. Plasma Phys. 84,\n905840403, 2018, doi: 10.1017/S0022377818000739 ACKNOWLEDGEMENTS The development of the ALPS code was supported by NASA Grant NNX16AG81G. We will\npresent document more details about the numerics on the website\nhttp://www.alps.space. The code developers appreciate support from the UK Science\nand Technology Facilities Council (STFC) Ernest Rutherford Fellowship ST/P003826/1,\nSTFC Consolidated Grants ST/S000240/1 and ST/W001004/1, and the Open Source\nSoftware Sustainability Funding programme from UCL's Advanced Research Computing\nCentre and UCL's eResearch Domain. We appreciate software engineering support by\nDavid Stansby (UCL). INSTALLING THE ALPS CODE For advice on the installation of the code, please check INSTALL.md RUNNING THE ALPS CODE ALPS works with input files that specify the plasma and numerical parameters for\nthe calculation. We recommend that you start by checking out the provided test\ncases as a guidance for the creation of input files. These test cases are listed\nin the scripts run_test.sh and run_test_suite.sh . All associated input files have\na name starting with test_ . You can execute the ALPS code through the following command: mpirun -np <NP> ./src/ALPS <input_file.in> where <NP> is the number of processors you want to use. This number must be greater\nthan or equal to 4, and it must be an even number. <input_file.in> is the input file\nthat includes all parameters for your run. On some systems, depending on the MPI configuration, the oversubscribe flag is\nrequired. In this case, the above command must be replaced with mpirun -np <NP> --oversubscribe ./src/ALPS <input_file.in> DOCUMENTATION FOR INPUT/OUTPUT DATA Input Velocity Distribution Function folder: ./distribution (optionally created by subroutine generate_distribution distribution/generate_distribution.f90 ) file: distribution/<arrayName>.<is>.array data: pp(is,iperp,ipar,1:2) , f0(is,iperp,ipar) Fit Parameters for Hybrid Analytic Continuation folder: ./distribution created by subroutine determine_fit_parameters ( ALPS_analyt.f90 ) file: distribution/<runname>.fit_parameters.<is>.out data: iperp , params Result from Fit Routine for Hybrid Analytic Continuation folder: ./distribution created by subroutine output_fit ( ALPS_analyt.f90 ) file: distribution/<runname>.fit_parameters.<is>.out data: pp(is,iperp,ipar,1:2) , fit_result(is,iperp,ipar) , abs(fit_result(is,iperp,ipar,1:2)- f0(is,iperp,ipar))/f0(is,iperp,ipar) Map (grid in omega,gamma) of Dispersion Solutions created by subroutine map_search ( ALPS_fns.f90 ) file: solution/<runname>.map data: ir , ii , om(ir,ii) , log10(val(ir,ii)) , cal(ir,ii) Listing of Roots created by subroutine refine_guess ( ALPS_fns.f90 ) file: solution/<runname>.roots data: iw , wroots(iw) , log10(abs(tmpDisp)) , tmpDisp Scans of the Dispersion Solutions through k-space created by subroutine om_scan ( ALPS_fns.f90 ) file: solution/<runname>.scan_<option>.root_<rootnumber> data: kperp , kpar , om(ir,ii) Evaluation of the Eigen Vectors created by subroutine om_scan ( ALPS_fns.f90 ) file: solution/<runname>.eigen_<option>.root_<rootnumber> data: kperp , kpar , om(ir,ii) , ef , bf , Us , ds Evaluation of the Heating Rates created by subroutine om_scan ( ALPS_fns.f90 ) file: solution/<runname>.heat_<option>.root_<rootnumber> data: kperp , kpar , om(ir,ii) , Ps LIST OF ERROR CODES error_id = 0 - if mod ( nproc , 2 ) . ne . 0 error_id = 1 - Does requested input namelist exist ? error_id = 2 - if (( 1 + npar ) . LT . n_params ) ERRORS TO ADD: if the size of the input distribution function array is not equal to\nthe allocated distribution function array in ALPS LICENSE BSD 2-Clause License Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen\nAll rights reserved. Redistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","tags":"","loc":"page/index.html"},{"title":"Install – ALPS","text":"A  L  P  S  Arbitrary Linear Plasma Solver These are the install instructions for the ALPS code: the Arbitrary Linear\nPlasma Solver. Authors Kristopher Klein   (kgklein@arizona.edu)\nDaniel Verscharen  (d.verscharen@ucl.ac.uk) CONTENTS Requirements and Dependencies Setting up Computer Environments Getting the ALPS Code Installing the ALPS Code Execution of Test Runs REQUIREMENTS AND DEPENDENCIES ALPS has the following requirements: A UNIX, Linux, or macOS operating system with a working shell GNU make, in some cases it is useful to have the autoconf/automake tools Fortran 90 compiler (e.g., gfortran) - we recommend using the latest version\n  of the compiler to avoid any surprises in the evaluation. MPI (e.g., openmpi) - likewise, this should also be the latest version BLAS and LAPACK - these two libraries are used for the polyharmonic spline\n  interpolation in ALPS. They are directly linked during the compilation SETTING UP COMPUTER ENVIRONMENTS For Ubuntu and macOS users, the following instructions have proven to be useful.\nOn both systems, we recommend deactivating potential anaconda installations\nthat could interfere with the ALPS installation: conda deactivate On Ubuntu, the following installation routines obtain the necessary software\npackages for ALPS: sudo apt-get install -y libopenmpi-dev\nsudo apt-get install -y libopenblas-dev libblas-dev liblapack-dev If an older compiler or MPI version is still installed, it may be necessary to\ndeinstall this before using apt-get. On macOS, homebrew is a good way to install the necessary packages: brew install gcc openmpi GETTING THE ALPS CODE We recommend pulling the latest version of ALPS from GitHub. For this, go to\nthe directory where you want to install ALPS and execute the following command: git clone https://github.com/danielver02/ALPS Alternatively, you can also go to the website https://github.com/danielver02/ALPS\ndirectly and download the source code from there. The advantage of using the git\ncommand is that you can now contribute to the development of the ALPS code. If\nyou make any changes to the code, GitHub will run automatic tests (via workflows)\nto ensure that the changes do not break the code. INSTALLING THE ALPS CODE If all requirements are available, the code can be compiled with the following\ncommands: . / configure make sudo make install ( this option is only required if you want to make the ALPS executable available to all users ) If either of these steps fails, we recommend starting with autoreconf -i -f before the execution of ./configure . EXECUTION OF TEST RUNS ALPS comes with a selection of test runs that cycle through various test\nproblems. To execute a small set of tests, execute the following shell script: ./run_test.sh This script will test the interpolation routine, the routine to generate pre-\ndescribed distribution functions, and a simply fast dispersion relation. To execute a more complete set of test problems, execute the following shell\nscript: ./run_test_suite.sh This script will test the interpolation routine and then a number of ALPS test\ncases, including the generation of the relevant distribution functions. The test\nroutine outputs time stamps during each steps to compare the speed of the ALPS\ncode and to facilitate scaling tests. For each test, the script will explain\nwhether errors occurred or not in any of the tests. The code output itself will\nbe piped into the .out and .error files in the home directory. For advice on running ALPS, please see the README file.","tags":"","loc":"page/INSTALL.html"}]}