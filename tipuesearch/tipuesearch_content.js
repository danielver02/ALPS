var tipuesearch = {"pages":[{"title":" ALPS ","text":"ALPS ALPS is a parallelised numerical code that solves the Vlasov-Maxwell dispersion\nrelation in hot (even relativistic) magnetised plasma. ALPS allows for any\nnumber of particle species with arbitrary gyrotropic equilibrium distribution\nfunctions supporting waves with any direction of propagation with respect to\nthe background magnetic field. If you use the code for a science publication, please provide the code website\non github.com/danielver02/ALPS and cite the code paper: Verscharen, D., Klein, K. G., Chandran, B. D. G., Stevens, M. L., Salem, C. S.,\nand Bale, S. D.: ALPS: the Arbitrary Linear Plasma Solver, J. Plasma Phys. 84,\n905840403, 2018, doi: 10.1017/S0022377818000739 Developer Info Kristopher Klein, Daniel Verscharen","tags":"home","loc":"index.html"},{"title":"scanner – ALPS ","text":"type, public :: scanner Contents Variables range_i range_f log_scan heat_s eigen_s type_s n_out n_res diff diff2 Components Type Visibility Attributes Name Initial double precision, public :: range_i double precision, public :: range_f logical, public :: log_scan logical, public :: heat_s logical, public :: eigen_s integer, public :: type_s integer, public :: n_out integer, public :: n_res double precision, public :: diff double precision, public :: diff2","tags":"","loc":"type/scanner.html"},{"title":"integrate_res_rel – ALPS","text":"public  function integrate_res_rel(om, nn, mode) Uses alps_var Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode Return Value doublecomplex Contents","tags":"","loc":"proc/integrate_res_rel.html"},{"title":"integrate_resU_rel – ALPS","text":"private  function integrate_resU_rel(sproc_rel, om, nn, mode, igamma) Uses alps_var alps_io Arguments Type Intent Optional Attributes Name integer :: sproc_rel double complex :: om integer :: nn integer :: mode integer :: igamma Return Value doublecomplex Contents","tags":"","loc":"proc/integrate_resu_rel.html"},{"title":"principal_integral_rel – ALPS","text":"public  function principal_integral_rel(sproc_rel, om, nn, mode, igamma, ipparbar_res, upperlimit) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: sproc_rel double complex :: om integer :: nn integer :: mode integer :: igamma integer :: ipparbar_res integer :: upperlimit Return Value doublecomplex Contents","tags":"","loc":"proc/principal_integral_rel.html"},{"title":"funct_g_rel – ALPS","text":"private  function funct_g_rel(sproc_rel, pparbar, igamma, om, nn, mode) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: sproc_rel double precision :: pparbar integer :: igamma double complex :: om integer :: nn integer :: mode Return Value doublecomplex Contents","tags":"","loc":"proc/funct_g_rel.html"},{"title":"landau_integrate_rel – ALPS","text":"public  function landau_integrate_rel(om, nn, mode) Uses alps_analyt alps_var Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode Return Value doublecomplex Contents","tags":"","loc":"proc/landau_integrate_rel.html"},{"title":"int_ee_rel – ALPS","text":"public  function int_ee_rel(om) Uses alps_var Arguments Type Intent Optional Attributes Name double complex :: om Return Value doublecomplex Contents","tags":"","loc":"proc/int_ee_rel.html"},{"title":"resU_rel – ALPS","text":"public  function resU_rel(sproc_rel, om, nn, igamma, ipparbar) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: sproc_rel double complex :: om integer :: nn integer :: igamma integer :: ipparbar Return Value doublecomplex Contents","tags":"","loc":"proc/resu_rel.html"},{"title":"int_T_rel – ALPS","text":"private  function int_T_rel(sproc_rel, nn, igamma, ipparbar, mode) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: sproc_rel integer :: nn integer :: igamma integer :: ipparbar integer :: mode Return Value doublecomplex Contents","tags":"","loc":"proc/int_t_rel.html"},{"title":"int_T_res_rel – ALPS","text":"private  function int_T_res_rel(sproc_rel, nn, igamma, pparbar, mode) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: sproc_rel integer :: nn integer :: igamma double complex :: pparbar integer :: mode Return Value doublecomplex Contents","tags":"","loc":"proc/int_t_res_rel.html"},{"title":"Fact – ALPS","text":"private  function Fact(k) Arguments Type Intent Optional Attributes Name integer :: k Return Value doubleprecision Contents","tags":"","loc":"proc/fact.html"},{"title":"BESSJ – ALPS","text":"public  function BESSJ(N, X) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X Return Value doubleprecision Contents","tags":"","loc":"proc/bessj.html"},{"title":"BESSJ0 – ALPS","text":"public  function BESSJ0(X) Arguments Type Intent Optional Attributes Name real(kind=8) :: X Return Value doubleprecision Contents","tags":"","loc":"proc/bessj0.html"},{"title":"BESSJ1 – ALPS","text":"public  function BESSJ1(X) Arguments Type Intent Optional Attributes Name real(kind=8) :: X Return Value doubleprecision Contents","tags":"","loc":"proc/bessj1.html"},{"title":"Gamma – ALPS","text":"public  function Gamma(xx) Arguments Type Intent Optional Attributes Name double precision :: xx Return Value doubleprecision Contents","tags":"","loc":"proc/gamma.html"},{"title":"derivative_f0_rel – ALPS","text":"public  subroutine derivative_f0_rel(is, is_rel) Uses alps_var alps_io Arguments Type Intent Optional Attributes Name integer :: is integer :: is_rel Contents","tags":"","loc":"proc/derivative_f0_rel.html"},{"title":"polyharmonic_spline – ALPS","text":"public  subroutine polyharmonic_spline(grid_coarse, gamma_coarse, pparbar_coarse, n_coarse, gamma_rel, pparbar, ngamma, npparbar, smoothing, f0_rel, is_rel, nspec_rel) Arguments Type Intent Optional Attributes Name double precision :: grid_coarse (n_coarse) double precision :: gamma_coarse (n_coarse) double precision :: pparbar_coarse (n_coarse) integer :: n_coarse double precision :: gamma_rel (nspec_rel,0:ngamma,0:npparbar) double precision :: pparbar (nspec_rel,0:ngamma,0:npparbar) integer :: ngamma integer :: npparbar double precision :: smoothing double precision :: f0_rel (nspec_rel,0:ngamma,0:npparbar) integer :: is_rel integer :: nspec_rel Contents","tags":"","loc":"proc/polyharmonic_spline.html"},{"title":"determine_sproc_rel – ALPS","text":"private  subroutine determine_sproc_rel(sproc_rel) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: sproc_rel Contents","tags":"","loc":"proc/determine_sproc_rel.html"},{"title":"CBESSJ – ALPS","text":"public  subroutine CBESSJ(z, nu, z1) Arguments Type Intent Optional Attributes Name double complex :: z integer :: nu double complex :: z1 Contents","tags":"","loc":"proc/cbessj.html"},{"title":"besselI – ALPS","text":"private  function besselI(n, x) Arguments Type Intent Optional Attributes Name integer :: n double precision :: x Return Value doubleprecision Contents","tags":"","loc":"proc/besseli.html"},{"title":"dispfunct – ALPS","text":"private  function dispfunct(zeta, kpos) Arguments Type Intent Optional Attributes Name double complex :: zeta logical :: kpos Return Value doublecomplex Contents","tags":"","loc":"proc/dispfunct.html"},{"title":"BESSI – ALPS","text":"private  function BESSI(N, X) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X Return Value doubleprecision Contents","tags":"","loc":"proc/bessi.html"},{"title":"BESSI0 – ALPS","text":"private  function BESSI0(X) Arguments Type Intent Optional Attributes Name real(kind=8) :: X Return Value doubleprecision Contents","tags":"","loc":"proc/bessi0.html"},{"title":"BESSI1 – ALPS","text":"private  function BESSI1(X) Arguments Type Intent Optional Attributes Name real(kind=8) :: X Return Value doubleprecision Contents","tags":"","loc":"proc/bessi1.html"},{"title":"calc_chi – ALPS","text":"public  subroutine calc_chi(chi, j, kz, kperp, x) Uses alps_var Arguments Type Intent Optional Attributes Name double complex :: chi (3,3) integer :: j double precision :: kz double precision :: kperp double complex :: x Contents","tags":"","loc":"proc/calc_chi.html"},{"title":"calc_ypsilon – ALPS","text":"private  subroutine calc_ypsilon(Y, j, n, kz, kperp, x) Uses alps_var Arguments Type Intent Optional Attributes Name double complex :: Y (3,3) integer :: j integer :: n double precision :: kz double precision :: kperp double complex :: x Contents","tags":"","loc":"proc/calc_ypsilon.html"},{"title":"WOFZ – ALPS","text":"private  subroutine WOFZ(XI, YI, U, V, FLAG) C\nC     THE FOLLOWING IF-STATEMENT PROTECTS\nC     QRHO = (X 2 + Y 2) AGAINST OVERFLOW\nC Arguments Type Intent Optional Attributes Name real :: XI real :: YI real :: U real :: V logical :: FLAG Contents","tags":"","loc":"proc/wofz.html"},{"title":"check_parameters – ALPS","text":"public  subroutine check_parameters() Verifies input parameters and distributions. Todo Add\n- [ ] Quasi-Neutrality\n- [ ] Zero Net Current\n- [ ] ... Arguments None Contents None","tags":"","loc":"proc/check_parameters.html"},{"title":"input_unit_exist – ALPS","text":"private  function input_unit_exist(nml, exist) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nml logical, intent(out) :: exist Return Value integer Contents","tags":"","loc":"proc/input_unit_exist.html"},{"title":"input_unit – ALPS","text":"private  function input_unit(nml) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nml Return Value integer Contents","tags":"","loc":"proc/input_unit.html"},{"title":"isnancheck – ALPS","text":"public  function isnancheck(input) Arguments Type Intent Optional Attributes Name double precision :: input Return Value logical Contents","tags":"","loc":"proc/isnancheck.html"},{"title":"init_param – ALPS","text":"public  subroutine init_param() Uses alps_var Arguments None Contents None","tags":"","loc":"proc/init_param.html"},{"title":"map_read – ALPS","text":"private  subroutine map_read() Uses alps_var Arguments None Contents None","tags":"","loc":"proc/map_read.html"},{"title":"solution_read – ALPS","text":"private  subroutine solution_read(ik) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: ik Contents","tags":"","loc":"proc/solution_read.html"},{"title":"spec_read – ALPS","text":"private  subroutine spec_read(is) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: is Contents","tags":"","loc":"proc/spec_read.html"},{"title":"bM_read – ALPS","text":"private  subroutine bM_read(is) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: is Contents","tags":"","loc":"proc/bm_read.html"},{"title":"scan_read – ALPS","text":"private  subroutine scan_read(is) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: is Contents","tags":"","loc":"proc/scan_read.html"},{"title":"fit_read – ALPS","text":"public  subroutine fit_read(is, ifit) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: is integer :: ifit Contents","tags":"","loc":"proc/fit_read.html"},{"title":"get_runname – ALPS","text":"private  subroutine get_runname(runname, foldername) Arguments Type Intent Optional Attributes Name character(len=500), intent(out) :: runname character(len=500), intent(out) :: foldername Contents","tags":"","loc":"proc/get_runname.html"},{"title":"read_f0 – ALPS","text":"public  subroutine read_f0() Uses alps_var Arguments None Contents None","tags":"","loc":"proc/read_f0.html"},{"title":"get_indexed_namelist_unit – ALPS","text":"private  subroutine get_indexed_namelist_unit(unit, nml, index_in) Uses alps_var Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character(len=*), intent(in) :: nml integer, intent(in) :: index_in Contents","tags":"","loc":"proc/get_indexed_namelist_unit.html"},{"title":"get_indexed_double_namelist_unit – ALPS","text":"public  subroutine get_indexed_double_namelist_unit(unit, nml, spec_in, index_in) Uses alps_var Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character(len=*), intent(in) :: nml integer, intent(in) :: spec_in integer, intent(in) :: index_in Contents","tags":"","loc":"proc/get_indexed_double_namelist_unit.html"},{"title":"get_unused_unit – ALPS","text":"public  subroutine get_unused_unit(unit) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit Contents","tags":"","loc":"proc/get_unused_unit.html"},{"title":"alps_error_init – ALPS","text":"public  subroutine alps_error_init() Uses alps_var Arguments None Contents None","tags":"","loc":"proc/alps_error_init.html"},{"title":"alps_error – ALPS","text":"public  subroutine alps_error(error_id) Uses mpi alps_var Arguments Type Intent Optional Attributes Name integer :: error_id Contents","tags":"","loc":"proc/alps_error.html"},{"title":"output_time – ALPS","text":"public  subroutine output_time() Arguments None Contents None","tags":"","loc":"proc/output_time.html"},{"title":"display_credits – ALPS","text":"public  subroutine display_credits() Arguments None Contents None","tags":"","loc":"proc/display_credits.html"},{"title":"pass_instructions – ALPS","text":"public  subroutine pass_instructions() Uses mpi alps_var Arguments None Contents None","tags":"","loc":"proc/pass_instructions.html"},{"title":"pass_distribution – ALPS","text":"public  subroutine pass_distribution() Uses mpi alps_var Arguments None Contents None","tags":"","loc":"proc/pass_distribution.html"},{"title":"eval_fit – ALPS","text":"public  function eval_fit(is, iperp, ppar_valC) Uses alps_distribution_analyt alps_var This function evaluates the fit to f0 at and the complex parallel\nmomentum ppar_valC . It requires the fit parameters that will be determined\nby the subroutine determine_param_fit . Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Index of species for which eval_fit is executed. integer, intent(in) :: iperp Index of perpendicular momentum at which eval_fit is executed. double complex, intent(in) :: ppar_valC Complex parallel momentum at which eval_fit is executed. Return Value doublecomplex Contents","tags":"","loc":"proc/eval_fit.html"},{"title":"fit_function – ALPS","text":"private  function fit_function(is, n_params, params, pperp_val, ppar_val) Uses alps_var This function evaluates the fit to f0 at real pperp_val and complex ppar_val ,\nprovided that the one-dimensional fit-parameter array params is fed into the\nfunction. This is only used during the fitting. For the evaluation in ALPS,\nuse eval_fit . Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Index of species for which eval_fit is executed. integer, intent(in) :: n_params Total number of fit parameters for a given species. double precision, intent(in) :: params (n_params) Array of fit parameters. double precision, intent(in) :: pperp_val Perpendicular momentum. double complex, intent(in) :: ppar_val Complex parallel momentum. Return Value doublecomplex Contents","tags":"","loc":"proc/fit_function.html"},{"title":"determine_param_fit – ALPS","text":"public  subroutine determine_param_fit() Uses alps_var This is the fitting routine for the hybrid analytic continuation. It determines\nthe full field param_fit . Arguments None Contents None","tags":"","loc":"proc/determine_param_fit.html"},{"title":"output_fit – ALPS","text":"private  subroutine output_fit(qualitytotal) Uses alps_var alps_io This subroutine outputs the fit parameters for iperp=0 to stdout to monitor the fit. Arguments Type Intent Optional Attributes Name double precision, intent(in) :: qualitytotal Quality of the total fit result. Contents","tags":"","loc":"proc/output_fit.html"},{"title":"determine_JT – ALPS","text":"private  subroutine determine_JT(is, n_params, nJT, JT, params, iperp, upper_limit, ipparbar_lower) Uses alps_var This subroutine calculates the transposed Jacobian matrix of the fit function with respect to the\nfit parameter array. Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Index of species for which determine_JT is executed. integer, intent(in) :: n_params Total number of fit parameters for a given species. integer, intent(in) :: nJT First dimension of matrix nJT [[JT(variable)]]. double precision, intent(out) :: JT (nJT,0:upper_limit) Transposed Jacobian matrix of the fit function. double precision, intent(in) :: params (n_params) Array of fit parameters. integer, intent(in) :: iperp Index of perpendicular momentum at which [[JT(variable)]] is evaluated. integer, intent(in) :: upper_limit Upper limit of iperp space (relativistic and non-relativistic). integer, intent(in) :: ipparbar_lower Lower index of parallel momentum (relativistic). Contents","tags":"","loc":"proc/determine_jt.html"},{"title":"LM_nonlinear_fit – ALPS","text":"private  subroutine LM_nonlinear_fit(is, g, n_params, nJT, params, param_mask, iperp, npar, ipparbar_lower, quality) Uses mpi alps_var alps_io This subroutine processes the nonlinear Levenberg-Marquart algorithm and returns\nthe one-dimensional array params at a given iperp.\nThe variable quality is the sum of the squares of all residuals. Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Index of species for which LM_nonlinear_fit is executed. double precision, intent(in) :: g (0:npar) Array of function to be fitted. integer, intent(in) :: n_params Total number of fit parameters for a given species. integer, intent(in) :: nJT First dimension of matrix nJT determine_JT . double precision, intent(inout) :: params (n_params) Array of fit parameters. logical, intent(in) :: param_mask (n_params) Bit mask for required fit parameters. integer, intent(in) :: iperp Index of perpendicular momentum. integer, intent(in) :: npar Number of steps in parallel momentum integer, intent(in) :: ipparbar_lower Lower index of parallel momentum (relativistic). double precision, intent(out) :: quality Quality of the individual fit result. Contents","tags":"","loc":"proc/lm_nonlinear_fit.html"},{"title":"disp – ALPS","text":"public  function disp(om) Uses alps_nhds mpi alps_var alps_fns_rel Arguments Type Intent Optional Attributes Name double complex :: om Return Value doublecomplex Contents","tags":"","loc":"proc/disp.html"},{"title":"full_integrate – ALPS","text":"public  function full_integrate(om, nn, mode, found_res) Uses alps_var alps_fns_rel Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode logical :: found_res Return Value doublecomplex Contents","tags":"","loc":"proc/full_integrate.html"},{"title":"integrate – ALPS","text":"private  function integrate(om, nn, mode, iparmin, iparmax) Uses alps_var Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode integer :: iparmin integer :: iparmax Return Value doublecomplex Contents","tags":"","loc":"proc/integrate.html"},{"title":"integrate_res – ALPS","text":"private  function integrate_res(om, nn, mode) Uses alps_var Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode Return Value doublecomplex Contents","tags":"","loc":"proc/integrate_res.html"},{"title":"funct_g – ALPS","text":"public  function funct_g(ppar_real, iperp, om, nn, mode) Uses alps_var Arguments Type Intent Optional Attributes Name double precision :: ppar_real integer :: iperp double complex :: om integer :: nn integer :: mode Return Value doublecomplex Contents","tags":"","loc":"proc/funct_g.html"},{"title":"landau_integrate – ALPS","text":"private  function landau_integrate(om, nn, mode) Uses alps_analyt alps_var Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode Return Value doublecomplex Contents","tags":"","loc":"proc/landau_integrate.html"},{"title":"int_ee – ALPS","text":"public  function int_ee(om) Uses alps_var Arguments Type Intent Optional Attributes Name double complex :: om Return Value doublecomplex Contents","tags":"","loc":"proc/int_ee.html"},{"title":"resU – ALPS","text":"private  function resU(om, nn, iperp, ipar) Uses alps_var Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: iperp integer :: ipar Return Value doublecomplex Contents","tags":"","loc":"proc/resu.html"},{"title":"int_T – ALPS","text":"private  function int_T(nn, iperp, ipar, mode) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: nn integer :: iperp integer :: ipar integer :: mode Return Value doublecomplex Contents","tags":"","loc":"proc/int_t.html"},{"title":"int_T_res – ALPS","text":"private  function int_T_res(nn, iperp, p_res, mode) Uses alps_var Arguments Type Intent Optional Attributes Name integer :: nn integer :: iperp double complex :: p_res integer :: mode Return Value doublecomplex Contents","tags":"","loc":"proc/int_t_res.html"},{"title":"derivative_f0 – ALPS","text":"public  subroutine derivative_f0() Uses alps_fns_rel alps_var alps_io Arguments None Contents None","tags":"","loc":"proc/derivative_f0.html"},{"title":"determine_resonances – ALPS","text":"public  subroutine determine_resonances(om, nn, found_res_plus, found_res_minus) Uses alps_var alps_io Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn logical :: found_res_plus logical :: found_res_minus Contents","tags":"","loc":"proc/determine_resonances.html"},{"title":"secant – ALPS","text":"public  subroutine secant(om) Uses mpi alps_var Arguments Type Intent Optional Attributes Name double complex :: om Contents","tags":"","loc":"proc/secant.html"},{"title":"om_scan – ALPS","text":"public  subroutine om_scan(ik) Uses mpi alps_var alps_io Arguments Type Intent Optional Attributes Name integer :: ik Contents","tags":"","loc":"proc/om_scan.html"},{"title":"calc_eigen – ALPS","text":"public  subroutine calc_eigen(omega, electric, magnetic, vmean, ds, Ps, eigen_L, heat_L) Uses alps_var Arguments Type Intent Optional Attributes Name double complex :: omega double complex, intent(out), dimension(1:3) :: electric double complex, intent(out), dimension(1:3) :: magnetic double complex, intent(out), dimension(1:3,1:nspec) :: vmean double complex, intent(out), dimension(1:nspec) :: ds double precision, intent(out), dimension(1:nspec) :: Ps logical :: eigen_L logical :: heat_L Contents","tags":"","loc":"proc/calc_eigen.html"},{"title":"om_double_scan – ALPS","text":"public  subroutine om_double_scan() Uses mpi alps_var alps_io Arguments None Contents None","tags":"","loc":"proc/om_double_scan.html"},{"title":"map_search – ALPS","text":"public  subroutine map_search() Uses mpi alps_var alps_io Arguments None Contents None","tags":"","loc":"proc/map_search.html"},{"title":"refine_guess – ALPS","text":"public  subroutine refine_guess() Uses mpi alps_var alps_io Arguments None Contents None","tags":"","loc":"proc/refine_guess.html"},{"title":"find_minima – ALPS","text":"public  subroutine find_minima(val, numroots, iroots, nroots) Uses alps_var Arguments Type Intent Optional Attributes Name double precision, dimension(:,:), pointer :: val integer :: numroots integer, dimension(1:2,1:numroots) :: iroots integer, intent(out) :: nroots Contents","tags":"","loc":"proc/find_minima.html"},{"title":"determine_nmax – ALPS","text":"public  subroutine determine_nmax() Uses mpi alps_var alps_fns_rel Arguments None Contents None","tags":"","loc":"proc/determine_nmax.html"},{"title":"split_processes – ALPS","text":"public  subroutine split_processes() Uses alps_var Arguments None Contents None","tags":"","loc":"proc/split_processes.html"},{"title":"determine_bessel_array – ALPS","text":"public  subroutine determine_bessel_array() Uses alps_fns_rel alps_var alps_io Arguments None Contents None","tags":"","loc":"proc/determine_bessel_array.html"},{"title":"alps_fns_rel – ALPS","text":"FUNCTION  GAMMA(X)            * --------------------------------------- *\n Returns the value of Gamma(x) in double *\n precision as EXP(LN(GAMMA(X))) for X>0. * Contents Functions integrate_res_rel integrate_resU_rel principal_integral_rel funct_g_rel landau_integrate_rel int_ee_rel resU_rel int_T_rel int_T_res_rel Fact BESSJ BESSJ0 BESSJ1 Gamma Subroutines derivative_f0_rel polyharmonic_spline determine_sproc_rel CBESSJ Functions public  function integrate_res_rel (om, nn, mode) Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode Return Value doublecomplex private  function integrate_resU_rel (sproc_rel, om, nn, mode, igamma) Arguments Type Intent Optional Attributes Name integer :: sproc_rel double complex :: om integer :: nn integer :: mode integer :: igamma Return Value doublecomplex public  function principal_integral_rel (sproc_rel, om, nn, mode, igamma, ipparbar_res, upperlimit) Arguments Type Intent Optional Attributes Name integer :: sproc_rel double complex :: om integer :: nn integer :: mode integer :: igamma integer :: ipparbar_res integer :: upperlimit Return Value doublecomplex private  function funct_g_rel (sproc_rel, pparbar, igamma, om, nn, mode) Arguments Type Intent Optional Attributes Name integer :: sproc_rel double precision :: pparbar integer :: igamma double complex :: om integer :: nn integer :: mode Return Value doublecomplex public  function landau_integrate_rel (om, nn, mode) Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode Return Value doublecomplex public  function int_ee_rel (om) Arguments Type Intent Optional Attributes Name double complex :: om Return Value doublecomplex public  function resU_rel (sproc_rel, om, nn, igamma, ipparbar) Arguments Type Intent Optional Attributes Name integer :: sproc_rel double complex :: om integer :: nn integer :: igamma integer :: ipparbar Return Value doublecomplex private  function int_T_rel (sproc_rel, nn, igamma, ipparbar, mode) Arguments Type Intent Optional Attributes Name integer :: sproc_rel integer :: nn integer :: igamma integer :: ipparbar integer :: mode Return Value doublecomplex private  function int_T_res_rel (sproc_rel, nn, igamma, pparbar, mode) Arguments Type Intent Optional Attributes Name integer :: sproc_rel integer :: nn integer :: igamma double complex :: pparbar integer :: mode Return Value doublecomplex private  function Fact (k) Arguments Type Intent Optional Attributes Name integer :: k Return Value doubleprecision public  function BESSJ (N, X) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X Return Value doubleprecision public  function BESSJ0 (X) Arguments Type Intent Optional Attributes Name real(kind=8) :: X Return Value doubleprecision public  function BESSJ1 (X) Arguments Type Intent Optional Attributes Name real(kind=8) :: X Return Value doubleprecision public  function Gamma (xx) Arguments Type Intent Optional Attributes Name double precision :: xx Return Value doubleprecision Subroutines public  subroutine derivative_f0_rel (is, is_rel) Arguments Type Intent Optional Attributes Name integer :: is integer :: is_rel public  subroutine polyharmonic_spline (grid_coarse, gamma_coarse, pparbar_coarse, n_coarse, gamma_rel, pparbar, ngamma, npparbar, smoothing, f0_rel, is_rel, nspec_rel) Arguments Type Intent Optional Attributes Name double precision :: grid_coarse (n_coarse) double precision :: gamma_coarse (n_coarse) double precision :: pparbar_coarse (n_coarse) integer :: n_coarse double precision :: gamma_rel (nspec_rel,0:ngamma,0:npparbar) double precision :: pparbar (nspec_rel,0:ngamma,0:npparbar) integer :: ngamma integer :: npparbar double precision :: smoothing double precision :: f0_rel (nspec_rel,0:ngamma,0:npparbar) integer :: is_rel integer :: nspec_rel private  subroutine determine_sproc_rel (sproc_rel) Arguments Type Intent Optional Attributes Name integer :: sproc_rel public  subroutine CBESSJ (z, nu, z1) Arguments Type Intent Optional Attributes Name double complex :: z integer :: nu double complex :: z1","tags":"","loc":"module/alps_fns_rel.html"},{"title":"alps_nhds – ALPS","text":"* Program to calculate the first kind modified Bessel function of * integer order N , for any REAL X , using the function BESSI ( N , X ) . * * -------------------------------------------------------------------- *\n -------------------------------------------------------------------- *\n   Reference: From Numath Library By Tuan Dang Trong in Fortran 77.   *\n                                                                      *\n                               F90 Release 1.1 By J-P Moreau, Paris.  *\n                                                                      *\n   Version 1.1: corected value of P4 in BESSIO (P4=1.2067492 and not  *\n                1.2067429) Aug. 2011.                                 * Contents Functions besselI dispfunct BESSI BESSI0 BESSI1 Subroutines calc_chi calc_ypsilon WOFZ Functions private  function besselI (n, x) Arguments Type Intent Optional Attributes Name integer :: n double precision :: x Return Value doubleprecision private  function dispfunct (zeta, kpos) Arguments Type Intent Optional Attributes Name double complex :: zeta logical :: kpos Return Value doublecomplex private  function BESSI (N, X) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X Return Value doubleprecision private  function BESSI0 (X) Arguments Type Intent Optional Attributes Name real(kind=8) :: X Return Value doubleprecision private  function BESSI1 (X) Arguments Type Intent Optional Attributes Name real(kind=8) :: X Return Value doubleprecision Subroutines public  subroutine calc_chi (chi, j, kz, kperp, x) Arguments Type Intent Optional Attributes Name double complex :: chi (3,3) integer :: j double precision :: kz double precision :: kperp double complex :: x private  subroutine calc_ypsilon (Y, j, n, kz, kperp, x) Arguments Type Intent Optional Attributes Name double complex :: Y (3,3) integer :: j integer :: n double precision :: kz double precision :: kperp double complex :: x private  subroutine WOFZ (XI, YI, U, V, FLAG) C\nC     THE FOLLOWING IF-STATEMENT PROTECTS\nC     QRHO = (X 2 + Y 2) AGAINST OVERFLOW\nC Arguments Type Intent Optional Attributes Name real :: XI real :: YI real :: U real :: V logical :: FLAG","tags":"","loc":"module/alps_nhds.html"},{"title":"alps_check – ALPS","text":"Verification of input parameters and distributions. Contents Subroutines check_parameters Subroutines public  subroutine check_parameters () Verifies input parameters and distributions. Read more… Arguments None","tags":"","loc":"module/alps_check.html"},{"title":"alps_io – ALPS","text":"Contents Variables unit stdout_unit input_unit_no error_unit_no Functions input_unit_exist input_unit isnancheck Subroutines init_param map_read solution_read spec_read bM_read scan_read fit_read get_runname read_f0 get_indexed_namelist_unit get_indexed_double_namelist_unit get_unused_unit alps_error_init alps_error output_time display_credits Variables Type Visibility Attributes Name Initial integer, public :: unit integer, public, parameter :: stdout_unit = 6 integer, public, save :: input_unit_no integer, public, save :: error_unit_no = stdout_unit Functions private  function input_unit_exist (nml, exist) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nml logical, intent(out) :: exist Return Value integer private  function input_unit (nml) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nml Return Value integer public  function isnancheck (input) Arguments Type Intent Optional Attributes Name double precision :: input Return Value logical Subroutines public  subroutine init_param () Arguments None private  subroutine map_read () Arguments None private  subroutine solution_read (ik) Arguments Type Intent Optional Attributes Name integer :: ik private  subroutine spec_read (is) Arguments Type Intent Optional Attributes Name integer :: is private  subroutine bM_read (is) Arguments Type Intent Optional Attributes Name integer :: is private  subroutine scan_read (is) Arguments Type Intent Optional Attributes Name integer :: is public  subroutine fit_read (is, ifit) Arguments Type Intent Optional Attributes Name integer :: is integer :: ifit private  subroutine get_runname (runname, foldername) Arguments Type Intent Optional Attributes Name character(len=500), intent(out) :: runname character(len=500), intent(out) :: foldername public  subroutine read_f0 () Arguments None private  subroutine get_indexed_namelist_unit (unit, nml, index_in) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character(len=*), intent(in) :: nml integer, intent(in) :: index_in public  subroutine get_indexed_double_namelist_unit (unit, nml, spec_in, index_in) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit character(len=*), intent(in) :: nml integer, intent(in) :: spec_in integer, intent(in) :: index_in public  subroutine get_unused_unit (unit) Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit public  subroutine alps_error_init () Arguments None public  subroutine alps_error (error_id) Arguments Type Intent Optional Attributes Name integer :: error_id public  subroutine output_time () Arguments None public  subroutine display_credits () Arguments None","tags":"","loc":"module/alps_io.html"},{"title":"alps_com – ALPS","text":"Contents Subroutines pass_instructions pass_distribution Subroutines public  subroutine pass_instructions () Arguments None public  subroutine pass_distribution () Arguments None","tags":"","loc":"module/alps_com.html"},{"title":"alps_analyt – ALPS","text":"This module contains functions and subroutines for the hybrid analytical continuation. Contents Functions eval_fit fit_function Subroutines determine_param_fit output_fit determine_JT LM_nonlinear_fit Functions public  function eval_fit (is, iperp, ppar_valC) This function evaluates the fit to f0 at and the complex parallel\nmomentum ppar_valC . It requires the fit parameters that will be determined\nby the subroutine determine_param_fit . Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Index of species for which eval_fit is executed. integer, intent(in) :: iperp Index of perpendicular momentum at which eval_fit is executed. double complex, intent(in) :: ppar_valC Complex parallel momentum at which eval_fit is executed. Return Value doublecomplex private  function fit_function (is, n_params, params, pperp_val, ppar_val) This function evaluates the fit to f0 at real pperp_val and complex ppar_val ,\nprovided that the one-dimensional fit-parameter array params is fed into the\nfunction. This is only used during the fitting. For the evaluation in ALPS,\nuse eval_fit . Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Index of species for which eval_fit is executed. integer, intent(in) :: n_params Total number of fit parameters for a given species. double precision, intent(in) :: params (n_params) Array of fit parameters. double precision, intent(in) :: pperp_val Perpendicular momentum. double complex, intent(in) :: ppar_val Complex parallel momentum. Return Value doublecomplex Subroutines public  subroutine determine_param_fit () This is the fitting routine for the hybrid analytic continuation. It determines\nthe full field param_fit . Arguments None private  subroutine output_fit (qualitytotal) This subroutine outputs the fit parameters for iperp=0 to stdout to monitor the fit. Arguments Type Intent Optional Attributes Name double precision, intent(in) :: qualitytotal Quality of the total fit result. private  subroutine determine_JT (is, n_params, nJT, JT, params, iperp, upper_limit, ipparbar_lower) This subroutine calculates the transposed Jacobian matrix of the fit function with respect to the\nfit parameter array. Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Index of species for which determine_JT is executed. integer, intent(in) :: n_params Total number of fit parameters for a given species. integer, intent(in) :: nJT First dimension of matrix nJT [[JT(variable)]]. double precision, intent(out) :: JT (nJT,0:upper_limit) Transposed Jacobian matrix of the fit function. double precision, intent(in) :: params (n_params) Array of fit parameters. integer, intent(in) :: iperp Index of perpendicular momentum at which [[JT(variable)]] is evaluated. integer, intent(in) :: upper_limit Upper limit of iperp space (relativistic and non-relativistic). integer, intent(in) :: ipparbar_lower Lower index of parallel momentum (relativistic). private  subroutine LM_nonlinear_fit (is, g, n_params, nJT, params, param_mask, iperp, npar, ipparbar_lower, quality) This subroutine processes the nonlinear Levenberg-Marquart algorithm and returns\nthe one-dimensional array params at a given iperp.\nThe variable quality is the sum of the squares of all residuals. Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Index of species for which LM_nonlinear_fit is executed. double precision, intent(in) :: g (0:npar) Array of function to be fitted. integer, intent(in) :: n_params Total number of fit parameters for a given species. integer, intent(in) :: nJT First dimension of matrix nJT determine_JT . double precision, intent(inout) :: params (n_params) Array of fit parameters. logical, intent(in) :: param_mask (n_params) Bit mask for required fit parameters. integer, intent(in) :: iperp Index of perpendicular momentum. integer, intent(in) :: npar Number of steps in parallel momentum integer, intent(in) :: ipparbar_lower Lower index of parallel momentum (relativistic). double precision, intent(out) :: quality Quality of the individual fit result.","tags":"","loc":"module/alps_analyt.html"},{"title":"alps_fns – ALPS","text":"Contents Functions disp full_integrate integrate integrate_res funct_g landau_integrate int_ee resU int_T int_T_res Subroutines derivative_f0 determine_resonances secant om_scan calc_eigen om_double_scan map_search refine_guess find_minima determine_nmax split_processes determine_bessel_array Functions public  function disp (om) Arguments Type Intent Optional Attributes Name double complex :: om Return Value doublecomplex public  function full_integrate (om, nn, mode, found_res) Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode logical :: found_res Return Value doublecomplex private  function integrate (om, nn, mode, iparmin, iparmax) Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode integer :: iparmin integer :: iparmax Return Value doublecomplex private  function integrate_res (om, nn, mode) Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode Return Value doublecomplex public  function funct_g (ppar_real, iperp, om, nn, mode) Arguments Type Intent Optional Attributes Name double precision :: ppar_real integer :: iperp double complex :: om integer :: nn integer :: mode Return Value doublecomplex private  function landau_integrate (om, nn, mode) Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: mode Return Value doublecomplex public  function int_ee (om) Arguments Type Intent Optional Attributes Name double complex :: om Return Value doublecomplex private  function resU (om, nn, iperp, ipar) Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn integer :: iperp integer :: ipar Return Value doublecomplex private  function int_T (nn, iperp, ipar, mode) Arguments Type Intent Optional Attributes Name integer :: nn integer :: iperp integer :: ipar integer :: mode Return Value doublecomplex private  function int_T_res (nn, iperp, p_res, mode) Arguments Type Intent Optional Attributes Name integer :: nn integer :: iperp double complex :: p_res integer :: mode Return Value doublecomplex Subroutines public  subroutine derivative_f0 () Arguments None public  subroutine determine_resonances (om, nn, found_res_plus, found_res_minus) Arguments Type Intent Optional Attributes Name double complex :: om integer :: nn logical :: found_res_plus logical :: found_res_minus public  subroutine secant (om) Arguments Type Intent Optional Attributes Name double complex :: om public  subroutine om_scan (ik) Arguments Type Intent Optional Attributes Name integer :: ik public  subroutine calc_eigen (omega, electric, magnetic, vmean, ds, Ps, eigen_L, heat_L) Arguments Type Intent Optional Attributes Name double complex :: omega double complex, intent(out), dimension(1:3) :: electric double complex, intent(out), dimension(1:3) :: magnetic double complex, intent(out), dimension(1:3,1:nspec) :: vmean double complex, intent(out), dimension(1:nspec) :: ds double precision, intent(out), dimension(1:nspec) :: Ps logical :: eigen_L logical :: heat_L public  subroutine om_double_scan () Arguments None public  subroutine map_search () Arguments None public  subroutine refine_guess () Arguments None public  subroutine find_minima (val, numroots, iroots, nroots) Arguments Type Intent Optional Attributes Name double precision, dimension(:,:), pointer :: val integer :: numroots integer, dimension(1:2,1:numroots) :: iroots integer, intent(out) :: nroots public  subroutine determine_nmax () Arguments None public  subroutine split_processes () Arguments None public  subroutine determine_bessel_array () Arguments None","tags":"","loc":"module/alps_fns.html"},{"title":"alps_var – ALPS","text":"Uses mpi Contents Variables runname foldername option nroots nroots_max use_map writeOut unit_error nproc iproc proc0 ierror kperp kpar vA Bessel_zero nspec nspec_rel wroots numroots omi omf gami gamf loggridw loggridg ni nr nperp npar ngamma npparbar positions_principal Tlim sproc numiter D_threshold D_prec D_gap pi arrayName f0 f0_rel df0 df0_rel pp gamma_rel pparbar_rel nmax nlim ns qs ms relativistic wave chi0 bessel_array n_fits fit_type maxsteps_fit lambda_initial_fit lambdafac_fit epsilon_fit param_fit perp_correction fit_check determine_minima n_resonance_interval scan_option n_scan logfit usebM bMnmaxs bMBessel_zeros bMbetas bMalphas bMpdrifts scan kperp_last kpar_last kperp_0 kpar_0 Derived Types scanner Variables Type Visibility Attributes Name Initial character(len=500), public :: runname character(len=500), public :: foldername integer, public :: option integer, public :: nroots integer, public :: nroots_max logical, public :: use_map logical, public :: writeOut = .true. integer, public :: unit_error integer, public :: nproc integer, public :: iproc logical, public :: proc0 integer, public :: ierror double precision, public :: kperp double precision, public :: kpar double precision, public :: vA double precision, public :: Bessel_zero = 1.d-45 integer, public :: nspec integer, public :: nspec_rel double complex, public, dimension(:), allocatable :: wroots integer, public :: numroots = 100 double precision, public :: omi double precision, public :: omf double precision, public :: gami double precision, public :: gamf logical, public :: loggridw logical, public :: loggridg integer, public :: ni = 128 integer, public :: nr = 128 integer, public :: nperp integer, public :: npar integer, public :: ngamma = 100 integer, public :: npparbar = 200 integer, public :: positions_principal = 5 double precision, public :: Tlim = 0.01d0 integer, public :: sproc integer, public :: numiter = 50 double precision, public :: D_threshold = 1.d-5 double precision, public :: D_prec = 1.d-5 double precision, public :: D_gap = 1.d-5 double precision, public :: pi character(len=75), public :: arrayName double precision, public, dimension(:,:,:), allocatable :: f0 double precision, public, dimension(:,:,:), allocatable :: f0_rel double precision, public, dimension(:,:,:,:), allocatable :: df0 double precision, public, dimension(:,:,:,:), allocatable :: df0_rel double precision, public, dimension(:,:,:,:), allocatable :: pp double precision, public, dimension(:,:,:), allocatable :: gamma_rel double precision, public, dimension(:,:,:), allocatable :: pparbar_rel integer, public, dimension(:), allocatable :: nmax integer, public :: nlim (2) double precision, public, dimension(:), allocatable :: ns double precision, public, dimension(:), allocatable :: qs double precision, public, dimension(:), allocatable :: ms logical, public, dimension(:), allocatable :: relativistic double complex, public, dimension(:,:), allocatable :: wave double complex, public, dimension(:,:,:), allocatable :: chi0 double precision, public, dimension(:,:), allocatable :: bessel_array integer, public, dimension(:), allocatable :: n_fits integer, public, dimension(:,:), allocatable :: fit_type integer, public :: maxsteps_fit = 500 double precision, public :: lambda_initial_fit = 1.d0 double precision, public :: lambdafac_fit = 1.d1 double precision, public :: epsilon_fit = 1.d-8 double precision, public, dimension(:,:,:,:), allocatable :: param_fit double precision, public, dimension(:,:), allocatable :: perp_correction logical, public :: fit_check = .true. logical, public :: determine_minima = .true. integer, public :: n_resonance_interval = 100 integer, public :: scan_option = 1 integer, public :: n_scan = 0 logical, public, dimension(:), allocatable :: logfit logical, public, dimension(:), allocatable :: usebM integer, public, dimension(:), allocatable :: bMnmaxs double precision, public, dimension(:), allocatable :: bMBessel_zeros double precision, public, dimension(:), allocatable :: bMbetas double precision, public, dimension(:), allocatable :: bMalphas double precision, public, dimension(:), allocatable :: bMpdrifts type( scanner ), public, dimension (:), allocatable :: scan double precision, public :: kperp_last double precision, public :: kpar_last double precision, public :: kperp_0 double precision, public :: kpar_0 Derived Types type, public :: scanner Components Type Visibility Attributes Name Initial double precision, public :: range_i double precision, public :: range_f logical, public :: log_scan logical, public :: heat_s logical, public :: eigen_s integer, public :: type_s integer, public :: n_out integer, public :: n_res double precision, public :: diff double precision, public :: diff2","tags":"","loc":"module/alps_var.html"},{"title":"alps – ALPS","text":"Uses alps_com alps_check alps_var alps_fns mpi alps_analyt alps_io Contents Variables ik Variables Type Attributes Name Initial integer :: ik Index for iterating through wavevector scans with om_scan or om_double_scan","tags":"","loc":"program/alps.html"},{"title":"ALPS_fns_rel.f90 – ALPS","text":"Contents Modules alps_fns_rel Source Code ALPS_fns_rel.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_fns_rel implicit none private :: int_T_rel , int_T_res_rel , integrate_resU_rel private :: funct_g_rel private :: determine_sproc_rel , fact public :: derivative_f0_rel , polyharmonic_spline public :: integrate_res_rel , landau_integrate_rel , resU_rel public :: bessj0 , bessj1 , bessj contains !-=-=-=-=-=-= subroutine derivative_f0_rel ( is , is_rel ) use alps_var , only : f0 , pp , nperp , npar , vA , ms , writeOut , arrayName use alps_var , only : f0_rel , df0_rel , gamma_rel , pparbar_rel , nspec_rel , ngamma , npparbar use alps_var , only : writeOut , pi use alps_io , only : get_unused_unit implicit none integer :: is , is_rel , n_coarse , counter , igamma , ipparbar , iperp , ipar double precision :: pparbar_max , pparbar_min , gamma_max , gamma_min , gamma_max_use , dgamma , dpparbar double precision , allocatable , dimension (:) :: gamma_coarse , pparbar_coarse , grid_coarse character ( 50 ) :: fmt !Output format character ( 100 ) :: writename double precision :: integrate , gamma , smoothing integer :: unit_f ! Determine the minimum and maximum values of Gamma and ppar pparbar_min = 99999 9.d0 pparbar_max =- 99999 9.d0 gamma_min = 99999 9.d0 gamma_max =- 1.d0 do iperp = 0 , nperp do ipar = 0 , npar gamma = sqrt (( pp ( is , iperp , ipar , 1 ) ** 2 + pp ( is , iperp , ipar , 2 ) ** 2 ) * vA ** 2 / ms ( is ) ** 2 + 1.d0 ) if ( gamma . GT . gamma_max ) gamma_max = gamma if ( gamma . LT . gamma_min ) gamma_min = gamma if ( pp ( is , iperp , ipar , 2 ). LT . pparbar_min ) pparbar_min = pp ( is , iperp , ipar , 2 ) if ( pp ( is , iperp , ipar , 2 ). GT . pparbar_max ) pparbar_max = pp ( is , iperp , ipar , 2 ) enddo enddo pparbar_min = pparbar_min * vA / ms ( is ) pparbar_max = pparbar_max * vA / ms ( is ) gamma_max_use = sqrt ( 1.d0 + pp ( is , nperp , 1 , 1 ) ** 2 * vA ** 2 / ms ( is ) ** 2 ) if ( writeOut ) then write ( * , '(a,i3,a,1es14.4)' ) \"Maximum Gamma for species\" , is , \":\" , gamma_max write ( * , '(a,i3,a,1es14.4)' ) \"Minimum Gamma for species\" , is , \":\" , gamma_min write ( * , '(a,i3,a,1es14.4)' ) \"Maximum Pparbar: for species\" , is , \":\" , pparbar_max write ( * , '(a,i3,a,1es14.4)' ) \"Minimum Pparbar: for species\" , is , \":\" , pparbar_min write ( * , '(a,i3,a,1es14.4)' ) \"Usable Maximum Gamma for species\" , is , \":\" , gamma_max_use endif smoothing = 0.d0 !0.001d0! make this a user-defined parameter ? n_coarse = ( nperp + 1 ) * ( npar + 1 ) ! This has to be (nperp+2)*(npar+1) if we include a line of zeroes allocate ( gamma_coarse ( n_coarse )) allocate ( pparbar_coarse ( n_coarse )) allocate ( grid_coarse ( n_coarse )) counter = 0 do iperp = 0 , nperp do ipar = 0 , npar counter = counter + 1 gamma_coarse ( counter ) = sqrt ( 1.d0 + ( pp ( is , iperp , ipar , 1 ) ** 2 + pp ( is , iperp , ipar , 2 ) ** 2 ) * & vA * vA / ( ms ( is ) * ms ( is ))) pparbar_coarse ( counter ) = pp ( is , iperp , ipar , 2 ) * vA / ms ( is ) grid_coarse ( counter ) = log ( f0 ( is , iperp , ipar )) enddo enddo ! add a line of zeroes at the end: !\tdo ipar = 0, npar !\t\tcounter=counter+1 !\t\tgamma_coarse(counter)=gamma_max+(gamma_max-gamma_min)/(1.d0*ngamma) !\t\tpparbar_coarse(counter)=pp(is,nperp,ipar,2)*vA/ms(is) !\t\tgrid_coarse(counter)=0.d0 !\tenddo do igamma = 0 , ngamma do ipparbar = 0 , npparbar gamma_rel ( is_rel , igamma , ipparbar ) = gamma_min + (( gamma_max_use - gamma_min ) * igamma ) / ( 1.d0 * ngamma ) pparbar_rel ( is_rel , igamma , ipparbar ) = pparbar_min + (( pparbar_max - pparbar_min ) * ipparbar ) / ( 1.d0 * npparbar ) enddo enddo if ( writeOut ) write ( * , '(a)' ) 'Polyharmonic spline interpolation on relativistic grid...' call polyharmonic_spline ( grid_coarse , gamma_coarse , pparbar_coarse , n_coarse , gamma_rel , pparbar_rel ,& ngamma , npparbar , smoothing , f0_rel , is_rel , nspec_rel ) ! Stay within the subluminal cone do igamma = 0 , ngamma do ipparbar = 0 , npparbar f0_rel ( is_rel , igamma , ipparbar ) = exp ( f0_rel ( is_rel , igamma , ipparbar )) if (( gamma_rel ( is_rel , igamma , ipparbar ) ** 2 - 1.d0 ). LT .( pparbar_rel ( is_rel , igamma , ipparbar ) ** 2 ))& f0_rel ( is_rel , igamma , ipparbar ) =- 1.d0 enddo enddo integrate = 0.d0 dgamma = gamma_rel ( is_rel , 2 , 2 ) - gamma_rel ( is_rel , 1 , 2 ) dpparbar = pparbar_rel ( is_rel , 2 , 2 ) - pparbar_rel ( is_rel , 2 , 1 ) do igamma = 0 , ngamma do ipparbar = 0 , npparbar if ( f0_rel ( is_rel , igamma , ipparbar ). GT . - 1.d0 ) then integrate = integrate + & gamma_rel ( is_rel , igamma , ipparbar ) * f0_rel ( is_rel , igamma , ipparbar ) * & 2.d0 * pi * dgamma * dpparbar * ( ms ( is ) / vA ) ** 3 endif enddo enddo write ( * , '(a,i3,a, 2es14.4)' ) 'Integration of species' , is , ':' , integrate if ( writeOut ) write ( * , '(a)' ) 'Writing relativistic grid to file...' write ( fmt , '(a)' ) '(2es14.4,1es14.4)' write ( writeName , '(3a,i0,a)' ) 'distribution/' , trim ( arrayName ), '_f0_rel.' , is , '.array' call get_unused_unit ( unit_f ) open ( unit = unit_f , file = trim ( writeName ), status = 'replace' ) do igamma = 0 , ngamma do ipparbar = 0 , npparbar if ( f0_rel ( is_rel , igamma , ipparbar ). NE . - 1.d0 ) f0_rel ( is_rel , igamma , ipparbar ) = f0_rel ( is_rel , igamma , ipparbar ) / integrate write ( unit_f , fmt ) gamma_rel ( is_rel , igamma , ipparbar ), pparbar_rel ( is_rel , igamma , ipparbar ),& f0_rel ( is_rel , igamma , ipparbar ) enddo write ( unit_f , * ) enddo close ( unit_f ) if ( writeOut ) write ( * , '(a)' ) 'Determining relativistic derivatives...' do igamma = 1 , ngamma - 1 do ipparbar = 1 , npparbar - 1 !index 1-> gamma derivative df0_rel ( is_rel , igamma , ipparbar , 1 ) = 0.d0 if (( f0_rel ( is_rel , igamma - 1 , ipparbar ). GT . 0.d0 ). AND .( f0_rel ( is_rel , igamma + 1 , ipparbar ). GT . 0.d0 )) then df0_rel ( is_rel , igamma , ipparbar , 1 ) = & ( f0_rel ( is_rel , igamma + 1 , ipparbar ) - f0_rel ( is_rel , igamma - 1 , ipparbar )) / & ( gamma_rel ( is_rel , igamma + 1 , ipparbar ) - gamma_rel ( is_rel , igamma - 1 , ipparbar )) endif !index 2-> pparbar derivative df0_rel ( is_rel , igamma , ipparbar , 2 ) = 0.d0 if (( f0_rel ( is_rel , igamma , ipparbar + 1 ). GT . 0.d0 ). AND .( f0_rel ( is_rel , igamma , ipparbar - 1 ). GT . 0.d0 )) then df0_rel ( is_rel , igamma , ipparbar , 2 ) = & ( f0_rel ( is_rel , igamma , ipparbar + 1 ) - f0_rel ( is_rel , igamma , ipparbar - 1 )) / & ( pparbar_rel ( is_rel , igamma , ipparbar + 1 ) - pparbar_rel ( is_rel , igamma , ipparbar - 1 )) endif if ( f0_rel ( is_rel , igamma , ipparbar ). GE . 0.d0 ) then if (( f0_rel ( is_rel , igamma , ipparbar + 1 ). LE . 0.d0 ). AND .( f0_rel ( is_rel , igamma , ipparbar - 1 ). GT . 0.d0 )) then df0_rel ( is_rel , igamma , ipparbar , 2 ) = & ( f0_rel ( is_rel , igamma , ipparbar ) - f0_rel ( is_rel , igamma , ipparbar - 1 )) / & ( pparbar_rel ( is_rel , igamma , ipparbar ) - pparbar_rel ( is_rel , igamma , ipparbar - 1 )) endif if (( f0_rel ( is_rel , igamma , ipparbar + 1 ). GT . 0.d0 ). AND .( f0_rel ( is_rel , igamma , ipparbar - 1 ). LE . 0.d0 )) then df0_rel ( is_rel , igamma , ipparbar , 2 ) = & ( f0_rel ( is_rel , igamma , ipparbar + 1 ) - f0_rel ( is_rel , igamma , ipparbar )) / & ( pparbar_rel ( is_rel , igamma , ipparbar + 1 ) - pparbar_rel ( is_rel , igamma , ipparbar )) endif endif enddo enddo if ( writeOut ) write ( * , '(a)' ) 'Writing relativistic derivatives to file...' write ( fmt , '(a)' ) '(2es14.4,2es14.4)' write ( writeName , '(3a,i0,a)' ) 'distribution/' , trim ( arrayName ), '_dfdv_rel.' , is , '.array' call get_unused_unit ( unit_f ) open ( unit = unit_f , file = trim ( writeName ), status = 'replace' ) do igamma = 0 , ngamma do ipparbar = 0 , npparbar write ( unit_f , fmt ) gamma_rel ( is_rel , igamma , ipparbar ), pparbar_rel ( is_rel , igamma , ipparbar ),& df0_rel ( is_rel , igamma , ipparbar , 1 ), df0_rel ( is_rel , igamma , ipparbar , 2 ) enddo write ( unit_f , * ) enddo close ( unit_f ) if ( writeOut ) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' end subroutine derivative_f0_rel ! Polyharmonic Spline for relativistic calculation: subroutine polyharmonic_spline ( grid_coarse , gamma_coarse , pparbar_coarse , n_coarse , gamma_rel , pparbar , ngamma , npparbar ,& smoothing , f0_rel , is_rel , nspec_rel ) ! ! This soubroutine interpolates the grid with a polyharmonic thin-plate spline. ! ! Input: ! grid_coarse is a vector of length n_coarse that includes the values of f at each point i ! gamma_coarse is a vector of length n_coarse that includes the values of gamma at each point i ! pparbar_coarse is a vector of length n_coarse that includes the values of ppar at each point i ! n_coarse is the total number of points in the coarse grid (ngamma_coarse * npparbar_coarse) ! ! gamma_rel is the value of gamma in the fine grid. It is a field of rank (ngamma, npparbar) ! pparbar is the value of ppar in the fine grid. It is a field of rank (ngamma, npparbar) ! ngamma is the number of perpendicular data points in the fine grid ! npparbar is the number of parallel data points in the fine grid ! ! ! Output: ! f0_rel is the interpolated grid. It is a field of rank (ngamma, npparbar) ! ! This subroutine needs the LUPACK and BLAS libraries to evoke the dgesv subroutine\t! ! This is the Thin Plate Spline: ! We use these resources: ! http://cseweb.ucsd.edu/~sjb/eccv_tps.pdf ! http://www.univie.ac.at/nuhag-php/bibtex/open_files/po94_M%20J%20D%20Powell%2003%2093.pdf ! http://vision.ucsd.edu/sites/default/files/fulltext(4).pdf implicit none integer :: i , j , k , permutation_index ( n_coarse + 3 ) integer :: ngamma , npparbar , n_coarse , is_rel , nspec_rel double precision :: gamma_coarse ( n_coarse ), pparbar_coarse ( n_coarse ) double precision :: grid_coarse ( n_coarse ), f0_rel ( nspec_rel , 0 : ngamma , 0 : npparbar ) double precision :: fullmatrix ( n_coarse + 3 , n_coarse + 3 ) double precision :: grid_vector ( n_coarse + 3 ), weight_param ( n_coarse + 3 ) double precision :: gamma_rel ( nspec_rel , 0 : ngamma , 0 : npparbar ), pparbar ( nspec_rel , 0 : ngamma , 0 : npparbar ) double precision :: r , smoothing double precision :: INFO grid_vector = 0.d0 do i = 1 , n_coarse grid_vector ( i ) = grid_coarse ( i ) enddo ! grid_vector has three additional entries. The last three entries are all zero. fullmatrix = 0.d0 do i = 1 , n_coarse do j = 1 , n_coarse ! Do the K-matrix part first: r = sqrt (( gamma_coarse ( i ) - gamma_coarse ( j )) ** 2 + ( pparbar_coarse ( i ) - pparbar_coarse ( j )) ** 2 ) if ( r . GE . 1.d0 ) then fullmatrix ( i , j ) = r * r * log ( r ) elseif ( r . EQ . 0.d0 ) then fullmatrix ( i , j ) = 0.d0 else fullmatrix ( i , j ) = r * log ( r ** r ) endif enddo fullmatrix ( i , i ) = fullmatrix ( i , i ) + smoothing ! Now the P-matrix parts: fullmatrix ( i , n_coarse + 1 ) = 1.d0 fullmatrix ( i , n_coarse + 2 ) = gamma_coarse ( i ) fullmatrix ( i , n_coarse + 3 ) = pparbar_coarse ( i ) ! and the transposed P-matrix: fullmatrix ( n_coarse + 1 , i ) = 1.d0 fullmatrix ( n_coarse + 2 , i ) = gamma_coarse ( i ) fullmatrix ( n_coarse + 3 , i ) = pparbar_coarse ( i ) enddo weight_param = grid_vector call dgesv ( n_coarse + 3 , 1 , fullmatrix , n_coarse + 3 , permutation_index , weight_param , n_coarse + 3 , INFO ) f0_rel ( is_rel ,:,:) = 0.d0 do i = 0 , ngamma do j = 0 , npparbar do k = 1 , n_coarse r = sqrt (( gamma_rel ( is_rel , i , j ) - gamma_coarse ( k )) ** 2 + ( pparbar ( is_rel , i , j ) - pparbar_coarse ( k )) ** 2 ) if ( r . GE . 1.d0 ) then f0_rel ( is_rel , i , j ) = f0_rel ( is_rel , i , j ) + weight_param ( k ) * r * r * log ( r ) elseif ( r . EQ . 0.d0 ) then f0_rel ( is_rel , i , j ) = f0_rel ( is_rel , i , j ) else f0_rel ( is_rel , i , j ) = f0_rel ( is_rel , i , j ) + weight_param ( k ) * r * log ( r ** r ) endif enddo f0_rel ( is_rel , i , j ) = f0_rel ( is_rel , i , j ) + weight_param ( n_coarse + 1 ) + & weight_param ( n_coarse + 2 ) * gamma_rel ( is_rel , i , j ) + weight_param ( n_coarse + 3 ) * pparbar ( is_rel , i , j ) enddo enddo end subroutine !-=-=-=-=-=-= ! !-=-=-=-=-=-= ! This subroutine determines sproc_rel for the given process subroutine determine_sproc_rel ( sproc_rel ) use alps_var , only : relativistic , sproc , nspec integer :: is_rel , is , sproc_rel is_rel = 0 do is = 1 , nspec if ( relativistic ( is )) then is_rel = is_rel + 1 if ( is . EQ . sproc ) sproc_rel = is_rel endif enddo end subroutine ! This function does the relativistic integration around resonances if necessary: double complex function integrate_res_rel ( om , nn , mode ) use alps_var , only : ngamma , gamma_rel , pparbar_rel implicit none integer :: igamma integer :: nn , mode , sproc_rel double precision :: dgamma , dpparbar double complex :: ii , om integrate_res_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) call determine_sproc_rel ( sproc_rel ) dgamma = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ! At igamma=1, we are already missing the part from igamma=0, where we should actually start. ! Therefore, we use 2 instead of 1 in the trapezoid integration: do igamma = 1 , ngamma - 2 integrate_res_rel = integrate_res_rel + 2.d0 * integrate_resU_rel ( sproc_rel , om , nn , mode , igamma ) enddo igamma = ngamma - 1 integrate_res_rel = integrate_res_rel + integrate_resU_rel ( sproc_rel , om , nn , mode , igamma ) integrate_res_rel = integrate_res_rel * dgamma * 0.25d0 return end function integrate_res_rel ! This function performs the integration of the resU term in (gamma,pparbar) space at a constant igamma double complex function integrate_resU_rel ( sproc_rel , om , nn , mode , igamma ) use alps_var , only : npparbar , sproc , positions_principal , f0_rel , kpar , vA , ms , qs use alps_var , only : gamma_rel , pparbar_rel use alps_io , only : alps_error implicit none integer :: igamma , ipparbar , int_start , int_end integer :: nn , mode , ipparbar_res , sproc_rel , lowerlimit , upperlimit , ipparbar_lower , ipparbar_upper double precision :: dgamma , dpparbar double complex :: ii , om , pparbar_res logical :: found_res , found_lower , found_upper integrate_resU_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) dgamma = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ! determine the position of the resonance (i.e., the step LEFT of it): ipparbar = 0 ipparbar_res = 0 found_res = . FALSE . pparbar_res = ( gamma_rel ( sproc_rel , igamma , 1 ) * om - ( 1.d0 * nn ) * qs ( sproc ) / ms ( sproc )) * vA / kpar if (( real ( pparbar_res ) ** 2 ). LE .( gamma_rel ( sproc_rel , igamma , 1 ) ** 2 - 1.d0 )) then do while (( ipparbar . LT .( npparbar - 2 )). AND .(. NOT . found_res )) ipparbar = ipparbar + 1 if (( pparbar_rel ( sproc_rel , 2 , ipparbar + 1 ). GT . real ( pparbar_res )). and .& ( pparbar_rel ( sproc_rel , 2 , ipparbar ). LE . real ( pparbar_res ))) then ipparbar_res = ipparbar found_res = . TRUE . endif enddo endif ! Handle resonances that are right outside the integration domain: do ipparbar = 0 , positions_principal if (( real ( pparbar_res ). GE .( pparbar_rel ( sproc_rel , 2 , 0 ) - dpparbar * ipparbar )). AND .& ( real ( pparbar_res ). LT .( pparbar_rel ( sproc_rel , 2 , 0 ) - dpparbar * ( ipparbar - 1 )))) then ipparbar_res = - ipparbar found_res = . TRUE . endif if (( real ( pparbar_res ). GE .( pparbar_rel ( sproc_rel , 2 , npparbar - 1 ) + dpparbar * ipparbar )). AND .& ( real ( pparbar_res ). LT .( pparbar_rel ( sproc_rel , 2 , npparbar - 1 ) + dpparbar * ( ipparbar + 1 )))) then ipparbar_res = npparbar - 1 + ipparbar found_res = . TRUE . endif enddo ! determine the limits for the integration: ! What are the relevant ranges in pparbar: found_lower = . FALSE . found_upper = . FALSE . ipparbar_lower = 1 ipparbar_upper = npparbar - 1 do ipparbar = 1 , npparbar - 1 if ((. NOT . found_lower ). AND .( f0_rel ( sproc_rel , igamma , ipparbar - 1 ). LE . - 1.d0 ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 )) then ipparbar_lower = ipparbar found_lower = . TRUE . endif if ((. NOT . found_upper ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 ). AND .( f0_rel ( sproc_rel , igamma , ipparbar + 1 ). LE . - 1.d0 )) then ipparbar_upper = ipparbar found_upper = . TRUE . endif enddo ! define int_start, int_end, lowerlimit, and upperlimit: if ( found_res ) then ! These four are in general correct: int_start = ipparbar_lower int_end = ipparbar_upper lowerlimit = ipparbar_res - positions_principal upperlimit = ipparbar_res + positions_principal + 1 if (( ipparbar_res . GE . 0 ). and .( ipparbar_res . LE . npparbar )) then if ( abs ( real ( pparbar_res ) - pparbar_rel ( sproc_rel , 2 , ipparbar_res )). GT .( 0.5d0 * dpparbar )) upperlimit = upperlimit + 1 endif ! But there are special circumstances: if (( lowerlimit . LT . ipparbar_lower ). AND .( upperlimit . GT . ipparbar_upper )) then call alps_error ( 8 ) elseif ( lowerlimit . LE . ipparbar_lower ) then ! resonance outside or near the left end of the subluminal cone int_start = 1 lowerlimit = 0 !upperlimit = max(upperlimit, ipparbar_lower) upperlimit = ipparbar_lower elseif ( upperlimit . GE . ipparbar_upper ) then ! resonance outside or near the right end of the subluminal cone !lowerlimit = min(lowerlimit, ipparbar_upper) lowerlimit = ipparbar_upper upperlimit = npparbar int_end = npparbar - 1 endif else ! no resonance (only integrate from int_start to lowerlimit) int_start = ipparbar_lower lowerlimit = ipparbar_upper int_end = npparbar - 1 upperlimit = npparbar endif ! Now comes the normal integration: if ( int_start . LE . lowerlimit ) then ipparbar = int_start integrate_resU_rel = integrate_resU_rel + resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) endif do ipparbar = int_start + 1 , lowerlimit - 1 integrate_resU_rel = integrate_resU_rel + 2.d0 * resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) enddo if ( int_start . LT . lowerlimit ) then ipparbar = lowerlimit integrate_resU_rel = integrate_resU_rel + resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) endif if ( upperlimit . LE . int_end ) then ipparbar = upperlimit integrate_resU_rel = integrate_resU_rel + resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) endif do ipparbar = upperlimit + 1 , int_end - 1 integrate_resU_rel = integrate_resU_rel + 2.d0 * resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) enddo if ( upperlimit . LT . int_end ) then ipparbar = int_end integrate_resU_rel = integrate_resU_rel + resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) endif integrate_resU_rel = integrate_resU_rel * dpparbar ! And this is the resonance integration: if ( found_res . AND .( lowerlimit . GE . int_start ). AND .( upperlimit . LE . int_end )) & integrate_resU_rel = integrate_resU_rel + principal_integral_rel ( sproc_rel , om , nn , mode , igamma , ipparbar_res , upperlimit ) return end function integrate_resU_rel double complex function principal_integral_rel ( sproc_rel , om , nn , mode , igamma , ipparbar_res , upperlimit ) use alps_var , only : positions_principal , n_resonance_interval , sproc use alps_var , only : gamma_rel , pparbar_rel , vA , kpar , qs , ms , Tlim , pi implicit none double complex :: om , ii , pparbar_res , gprimetr double precision :: denomR , denomI , capDelta , smdelta , correction , pparbar , dpparbar integer :: nn , mode , ipparbar_res , ipparbar , igamma , upperlimit , sproc_rel , ntiny ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) principal_integral_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ! split the range between the resonance and the upper limit into n_resonance_interval steps: ! Now comes the resonance part: ! We call the function that needs to be integrated WITHOUT the resonance part funct_g. ! We linearize this function. Now we can calculate the even part of the integration. ! We set Delta so that it starts at ipparbar_res-positions_principal. In that way, there is only ! a tiny rest left on the right side that needs to be integrated. ! split the range between the resonance and the upper limit into n_resonance_interval steps: ! the denominator is: ! (pparbar - gamma * om/kpar + (1.d0*nn) * qs(sproc)/ms(sproc)) * vA /kpar ! we define ! denomR=real(gamma *om/kpar - (1.d0*nn) * qs(sproc)/ms(sproc))vA /kpar ) ! denomI=aimag(gamma * ms(sproc)*om/kpar) ! so that the denominator is ! (ppar-denomR-ii*denomI) denomR = real ( gamma_rel ( sproc_rel , igamma , ipparbar_res ) * om * vA / kpar - ( 1.d0 * nn ) * ( qs ( sproc ) / ms ( sproc )) * vA / kpar ) denomI = aimag ( gamma_rel ( sproc_rel , igamma , ipparbar_res ) * om * vA / kpar ) pparbar_res = denomR + denomI * ii capDelta = real ( pparbar_res ) - pparbar_rel ( sproc_rel , 1 , ipparbar_res - positions_principal ) smdelta = capDelta / ( 1.d0 * n_resonance_interval ) if ( abs ( denomI ). GT . Tlim ) then ! regular integration: ! Integrate the boundaries: pparbar = real ( pparbar_res ) principal_integral_rel = principal_integral_rel + 1.d0 * & funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI ) principal_integral_rel = principal_integral_rel - 1.d0 * & funct_g_rel ( sproc_rel , 2.d0 * denomR - pparbar , igamma , om , nn , mode ) / ( pparbar - denomR + ii * denomI ) pparbar = real ( pparbar_res ) + capDelta principal_integral_rel = principal_integral_rel + 1.d0 * & funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI ) principal_integral_rel = principal_integral_rel - 1.d0 * & funct_g_rel ( sproc_rel , 2.d0 * denomR - pparbar , igamma , om , nn , mode ) / ( pparbar - denomR + ii * denomI ) do ipparbar = 1 , n_resonance_interval - 1 pparbar = real ( pparbar_res ) + smdelta * ipparbar principal_integral_rel = principal_integral_rel + 2.d0 * & funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI ) principal_integral_rel = principal_integral_rel - 2.d0 * & funct_g_rel ( sproc_rel , 2.d0 * denomR - pparbar , igamma , om , nn , mode ) / ( pparbar - denomR + ii * denomI ) enddo else ! analytical approximation gprimetr = ( funct_g_rel ( sproc_rel , denomR + dpparbar , igamma , om , nn , mode )& - funct_g_rel ( sproc_rel , denomR - dpparbar , igamma , om , nn , mode )) / ( 2.d0 * dpparbar ) ! Integrate the edges: pparbar = real ( pparbar_res ) ! This case is when pparbar=denomR, so no contribution is needed. !if (denomI.NE.0.d0) then !\tprincipal_integral_rel=principal_integral_rel & !\t\t+ 2.d0 * gprimetr*(pparbar-denomR)**2 / ((pparbar-denomR)**2+denomI**2) !else !\tprincipal_integral_rel=principal_integral_rel + 2.d0 * gprimetr !endif pparbar = real ( pparbar_res ) + capDelta principal_integral_rel = principal_integral_rel & + 2.d0 * gprimetr * ( pparbar - denomR ) ** 2 / (( pparbar - denomR ) ** 2 + denomI ** 2 ) ! end of edges. do ipparbar = 1 , n_resonance_interval - 1 pparbar = real ( pparbar_res ) + smdelta * ipparbar principal_integral_rel = principal_integral_rel & + 2.d0 * 2.d0 * gprimetr * ( pparbar - denomR ) ** 2 / (( pparbar - denomR ) ** 2 + denomI ** 2 ) enddo ! The following lines account for Eq. (3.7) in the paper: ! the factor 2 is for normalization reasons in the trapezoidal rule if ( denomI . GT . 0.d0 ) then principal_integral_rel = principal_integral_rel & + 2.d0 * ii * pi * funct_g_rel ( sproc_rel , denomR , igamma , om , nn , mode ) / smdelta else if ( denomI . LT . 0.d0 ) then principal_integral_rel = principal_integral_rel & - 2.d0 * ii * pi * funct_g_rel ( sproc_rel , denomR , igamma , om , nn , mode ) / smdelta else if ( denomI . EQ . 0.d0 ) then principal_integral_rel = principal_integral_rel + 0.d0 endif endif ! There is a tiny rest left between the point real(pparbar_res)+capDelta and the position ! pparbar_rel(sproc_rel,iperp,upperlimit). We split this interval into steps of roughly size smdelta: ntiny = int (( pparbar_rel ( sproc_rel , igamma , upperlimit ) - real ( pparbar_res ) - capDelta ) / smdelta ) if ( ntiny . GT . 0 ) then ! Correct for the fact that smdelta is not exactly the step width in the tiny-rest integration: correction = (( pparbar_rel ( sproc_rel , igamma , upperlimit ) - real ( pparbar_res ) - capDelta ) / ( 1.d0 * ntiny )) / smdelta pparbar = real ( pparbar_res ) + capDelta principal_integral_rel = principal_integral_rel + 1.d0 * & correction * ( funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI )) pparbar = real ( pparbar_res ) + capDelta + correction * smdelta * ntiny principal_integral_rel = principal_integral_rel + 1.d0 * & correction * ( funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI )) do ipparbar = 1 , ntiny - 1 pparbar = real ( pparbar_res ) + capDelta + correction * smdelta * ipparbar principal_integral_rel = principal_integral_rel + 2.d0 * & correction * ( funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI )) enddo endif principal_integral_rel = principal_integral_rel * smdelta return end function ! Linearized integrand WITHOUT the resonance part. ! It is  resU * int_T * Omega but without the denominator. ! It can be evaluated at any real value of pp (ppar_real) between the grid around the resonance. double complex function funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) use alps_var , only : ms , qs , kpar , df0_rel , sproc , vA , npparbar , pparbar_rel , pi , f0_rel implicit none integer :: nn , mode , ipparbar , ipparbar_close , sproc_rel , igamma double complex :: om , integrandplus , integrandminus , integrand double precision :: pparbar , dpparbar dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ipparbar_close =- 2 ! determine the closest ipar (on the left) to this p_res_real: do ipparbar = 0 , npparbar - 1 if (( pparbar_rel ( sproc_rel , igamma , ipparbar + 1 ). GT . pparbar ). AND .( pparbar_rel ( sproc_rel , igamma , ipparbar ). LE . pparbar )) then ipparbar_close = ipparbar endif enddo if ( f0_rel ( sproc_rel , igamma , ipparbar_close + 1 ). LE . - 1.d0 ) ipparbar_close = ipparbar_close - 1 if ( f0_rel ( sproc_rel , igamma , ipparbar_close - 1 ). LE . - 1.d0 ) ipparbar_close = ipparbar_close + 1 if ( pparbar . EQ . pparbar_rel ( sproc_rel , igamma , npparbar )) ipparbar_close = npparbar - 2 if ( ipparbar_close . GE .( npparbar - 1 )) ipparbar_close = npparbar - 2 if ( ipparbar_close . LE . 1 ) ipparbar_close = 2 ! calculate the function on the grid (left and right of pparbar): integrandplus = - 2.d0 * pi * ( ms ( sproc ) / vA ) ** 3 * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * & ( om * df0_rel ( sproc_rel , igamma , ipparbar_close + 1 , 1 ) + & ( kpar / ( vA )) * df0_rel ( sproc_rel , igamma , ipparbar_close + 1 , 2 ))& * int_T_rel ( sproc_rel , nn , igamma , ipparbar_close + 1 , mode ) integrand = - 2.d0 * pi * ( ms ( sproc ) / vA ) ** 3 * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * & ( om * df0_rel ( sproc_rel , igamma , ipparbar_close , 1 ) + & ( kpar / ( vA )) * df0_rel ( sproc_rel , igamma , ipparbar_close , 2 ))& * int_T_rel ( sproc_rel , nn , igamma , ipparbar_close , mode ) integrandminus = - 2.d0 * pi * ( ms ( sproc ) / vA ) ** 3 * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * & ( om * df0_rel ( sproc_rel , igamma , ipparbar_close - 1 , 1 ) + & ( kpar / ( vA )) * df0_rel ( sproc_rel , igamma , ipparbar_close - 1 , 2 ))& * int_T_rel ( sproc_rel , nn , igamma , ipparbar_close - 1 , mode ) funct_g_rel = integrand + & 0.5d0 * (( integrandplus - integrandminus ) / dpparbar ) * ( pparbar - pparbar_rel ( sproc_rel , igamma , ipparbar_close )) return end function funct_g_rel double complex function landau_integrate_rel ( om , nn , mode ) use alps_var , only : ngamma , gamma_rel , pparbar_rel , pi , ms , qs , kpar , sproc , vA use alps_analyt , only : eval_fit implicit none !Passed double complex :: om !complex frequency integer :: nn !Bessel N integer :: mode !index in T tensor !Local integer :: igamma , sproc_rel double precision :: dgamma , dpparbar double precision :: h double complex :: ii double complex :: dfgamma_C , dfpparbar_C , pparbar_res ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) landau_integrate_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) call determine_sproc_rel ( sproc_rel ) dgamma = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ! Landau contour integral: do igamma = 1 , ngamma - 1 pparbar_res = gamma_rel ( sproc_rel , igamma , 1 ) * om * vA / kpar - ( 1.d0 * nn ) * qs ( sproc ) * vA / ( kpar * ms ( sproc )) if (( real ( pparbar_res ) ** 2 ). LE .( gamma_rel ( sproc_rel , igamma , 1 ) ** 2 - 1.d0 )) then h = 1.d0 ! At igamma=1, we are already missing the part from igamma=0, where we should actually start. ! Therefore, we use 4 instead of 2 in the trapezoid integration: if ( igamma . EQ .( ngamma - 1 )) h = 0.5d0 if ( igamma . EQ . 1 ) then dfgamma_C = ( eval_fit ( sproc , igamma + 1 , pparbar_res ) - eval_fit ( sproc , igamma , pparbar_res )) / dgamma else dfgamma_C = ( eval_fit ( sproc , igamma + 1 , pparbar_res ) - eval_fit ( sproc , igamma - 1 , pparbar_res )) / ( 2.d0 * dgamma ) endif dfpparbar_C = ( eval_fit ( sproc , igamma , pparbar_res + dpparbar ) - eval_fit ( sproc , igamma , pparbar_res - dpparbar )) / ( 2.d0 * dpparbar ) landau_integrate_rel = landau_integrate_rel - h * ( & om * dfgamma_C + ( kpar / ( vA )) * dfpparbar_C ) * int_T_res_rel ( sproc_rel , nn , igamma , pparbar_res , mode ) endif enddo landau_integrate_rel = landau_integrate_rel * ii * dgamma * pi * 2.d0 * pi & * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * ( ms ( sproc ) / vA ) ** 3 return end function landau_integrate_rel double complex function int_ee_rel ( om ) use alps_var , only : qs , ms , pi , f0_rel , df0_rel , vA , sproc , gamma_rel , pparbar_rel use alps_var , only : ngamma , npparbar implicit none double complex :: om !complex frequency integer :: sproc_rel , igamma , ipparbar integer :: ipparbar_lower , ipparbar_upper double precision :: dgamma , dpparbar logical :: found_lower , found_upper call determine_sproc_rel ( sproc_rel ) dgamma = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) int_ee_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) ! What are the relevant ranges in pparbar: igamma = ngamma - 1 found_lower = . FALSE . found_upper = . FALSE . ipparbar_lower = 1 ipparbar_upper = npparbar - 1 do ipparbar = 1 , npparbar - 1 if ((. NOT . found_lower ). AND .( f0_rel ( sproc_rel , igamma , ipparbar - 1 ). LE . - 1.d0 ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 )) then ipparbar_lower = ipparbar found_lower = . TRUE . endif if ((. NOT . found_upper ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 ). AND .( f0_rel ( sproc_rel , igamma , ipparbar + 1 ). LE . - 1.d0 )) then ipparbar_upper = ipparbar found_upper = . TRUE . endif enddo int_ee_rel = int_ee_rel + & pparbar_rel ( sproc_rel , igamma , ipparbar_lower ) * df0_rel ( sproc_rel , igamma , ipparbar_lower , 2 ) int_ee_rel = int_ee_rel + & pparbar_rel ( sproc_rel , igamma , ipparbar_upper ) * df0_rel ( sproc_rel , igamma , ipparbar_upper , 2 ) do ipparbar = ipparbar_lower + 1 , ipparbar_upper - 1 int_ee_rel = int_ee_rel + & 2.d0 * pparbar_rel ( sproc_rel , igamma , ipparbar ) * df0_rel ( sproc_rel , igamma , ipparbar , 2 ) enddo ! At igamma=1, we are already missing the part from igamma=0, where we should actually start. ! Therefore, we use 4 instead of 2 in the trapezoid integration: do igamma = 1 , ngamma - 2 found_lower = . FALSE . found_upper = . FALSE . ipparbar_lower = 1 ipparbar_upper = npparbar - 1 do ipparbar = 1 , npparbar - 1 if ((. NOT . found_lower ). AND .( f0_rel ( sproc_rel , igamma , ipparbar - 1 ). LE . - 1.d0 ). AND .& ( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 )) then ipparbar_lower = ipparbar found_lower = . TRUE . endif if ((. NOT . found_upper ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 ). AND .& ( f0_rel ( sproc_rel , igamma , ipparbar + 1 ). LE . - 1.d0 )) then ipparbar_upper = ipparbar found_upper = . TRUE . endif enddo do ipparbar = ipparbar_lower + 1 , ipparbar_upper - 1 int_ee_rel = int_ee_rel + & 4.d0 * pparbar_rel ( sproc_rel , igamma , ipparbar ) * df0_rel ( sproc_rel , igamma , ipparbar , 2 ) enddo int_ee_rel = int_ee_rel + & 2.d0 * pparbar_rel ( sproc_rel , igamma , ipparbar_lower ) * df0_rel ( sproc_rel , igamma , ipparbar_lower , 2 ) int_ee_rel = int_ee_rel + & 2.d0 * pparbar_rel ( sproc_rel , igamma , ipparbar_upper ) * df0_rel ( sproc_rel , igamma , ipparbar_upper , 2 ) enddo int_ee_rel = int_ee_rel * 2.d0 * pi * qs ( sproc ) / ( ms ( sproc )) int_ee_rel = int_ee_rel * dgamma * dpparbar * 0.25d0 * ( ms ( sproc ) / vA ) ** 3 return end function int_ee_rel !-=-=-=-=-=-= !Functions for resonant term in integral !-=-=-=-=-=-= !-=-=-=-=-=-= !Functions for resonant term in integral for the relativistic calculation: !-=-=-=-=-=-= double complex function resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) use ALPS_var , only : kpar , ms , qs , df0_rel , vA , sproc , gamma_rel use ALPS_var , only : pi , pparbar_rel implicit none !Passed integer :: nn !Bessel N integer :: sproc_rel , igamma , ipparbar double complex :: om !complex frequency !Local resU_rel = - 2.d0 * pi * ( ms ( sproc ) / vA ) ** 3 * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * & ( om * df0_rel ( sproc_rel , igamma , ipparbar , 1 ) + ( kpar / ( vA )) * df0_rel ( sproc_rel , igamma , ipparbar , 2 )) / & ( pparbar_rel ( sproc_rel , igamma , ipparbar ) - gamma_rel ( sproc_rel , igamma , ipparbar ) * om * vA / kpar & + ( 1.d0 * nn ) * qs ( sproc ) * vA / ( kpar * ms ( sproc ))) return end function resU_rel !-=-=-=-=-=-= !Functions for Tij- !-=-=-=-=-=-= !Function to pass T_ij into integrator double complex function int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) use ALPS_var , only : kperp , qs , sproc , pparbar_rel , gamma_rel , vA , ms implicit none !Passed integer :: nn , igamma , ipparbar , sproc_rel integer :: mode !index in T tensor !Local double precision :: z , zbar !Bessel Argument double precision :: pperpbar double precision :: bessel ! Bessel function for nn and z double precision :: besselP ! first derivative of Bessel function for nn and z double complex :: ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) !Bessel Fn Argument pperpbar = sqrt ( gamma_rel ( sproc_rel , igamma , ipparbar ) ** 2 - 1.d0 - pparbar_rel ( sproc_rel , igamma , ipparbar ) ** 2 ) z = ( kperp * ms ( sproc ) / ( vA * qs ( sproc ))) * pperpbar zbar = kperp * ms ( sproc ) / ( vA * qs ( sproc )) ! Look up array of Bessel functions: if ( nn . LT . 0 ) then bessel = (( - 1.d0 ) ** nn ) * BESSJ ( - nn , z ) else bessel = BESSJ ( nn , z ) endif ! determine derivative of Bessel function: if ( nn . GE . 1 ) then besselP = 0.5d0 * ( BESSJ ( nn - 1 , z ) - BESSJ ( nn + 1 , z )) else if ( nn . LT . - 1 ) then besselP = 0.5d0 * (((( - 1.d0 ) ** ( nn - 1 )) * BESSJ ( - ( nn - 1 ), z ))& - ((( - 1.d0 ) ** ( nn + 1 )) * BESSJ ( - ( nn + 1 ), z ))) else if ( nn . EQ . 0 ) then besselP = - BESSJ ( 1 , z ) else if ( nn . EQ . - 1 ) then besselP = 0.5d0 * ( BESSJ ( 2 , z ) - BESSJ ( 0 , z )) endif select case ( mode ) case ( 1 ) !T xx int_T_rel = 1.d0 * ( nn * nn ) * bessel * bessel / ( zbar * zbar ) case ( 2 ) !T yy int_T_rel = besselP * besselP * pperpbar * pperpbar case ( 3 ) !T zz int_T_rel = bessel * bessel * pparbar_rel ( sproc_rel , igamma , ipparbar ) ** 2 case ( 4 ) !T xy int_T_rel = ii * ( 1.d0 * ( nn )) * bessel * besselP * pperpbar / zbar case ( 5 ) !T xz int_T_rel = ( 1.d0 * nn ) * bessel * bessel * pparbar_rel ( sproc_rel , igamma , ipparbar ) / zbar case ( 6 ) !T yz int_T_rel = ( - 1.d0 * ii ) * bessel * besselP * pparbar_rel ( sproc_rel , igamma , ipparbar ) * pperpbar end select return end function int_T_rel !Function to pass T_ij into integrator double complex function int_T_res_rel ( sproc_rel , nn , igamma , pparbar , mode ) use ALPS_var , only : kperp , qs , sproc , gamma_rel , vA , ms implicit none !Passed integer :: nn , igamma , sproc_rel integer :: mode !index in T tensor !Local double precision :: zbar double complex :: z double complex :: pperpbar double complex :: bessel ! Bessel function for nn and z double complex :: besselP ! first derivative of Bessel function for nn and z double complex :: besselH ! Help variable double complex :: ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) double complex :: pparbar !Bessel Fn Argument pperpbar = sqrt ( gamma_rel ( sproc_rel , igamma , 1 ) ** 2 - 1.d0 - pparbar ** 2 ) z = ( kperp * ms ( sproc ) / ( vA * qs ( sproc ))) * pperpbar zbar = kperp * ms ( sproc ) / ( vA * qs ( sproc )) ! Look up array of Bessel functions: if ( nn . LT . 0 ) then call CBESSJ ( z , - nn , bessel ) bessel = bessel * ( - 1.d0 ) ** nn else call CBESSJ ( z , nn , bessel ) endif ! determine derivative of Bessel function: if ( nn . GE . 1 ) then call CBESSJ ( z , nn - 1 , besselP ) call CBESSJ ( z , nn + 1 , besselH ) besselP = 0.5d0 * ( besselP - besselH ) elseif ( nn . LT . - 1 ) then call CBESSJ ( z , - ( nn - 1 ), besselP ) call CBESSJ ( z , - ( nn + 1 ), besselH ) besselP = 0.5d0 * (((( - 1.d0 ) ** ( nn - 1 )) * besselP )& - ((( - 1.d0 ) ** ( nn + 1 )) * besselH )) elseif ( nn . EQ . 0 ) then call CBESSJ ( z , 1 , besselP ) besselP = - besselP elseif ( nn . EQ . - 1 ) then call CBESSJ ( z , 2 , besselP ) call CBESSJ ( z , 0 , besselH ) besselP = 0.5d0 * ( besselP - besselH ) endif select case ( mode ) case ( 1 ) !T xx int_T_res_rel = 1.d0 * ( nn * nn ) * bessel * bessel / ( zbar * zbar ) case ( 2 ) !T yy int_T_res_rel = besselP * besselP * pperpbar * pperpbar case ( 3 ) !T zz int_T_res_rel = bessel * bessel * pparbar ** 2 case ( 4 ) !T xy int_T_res_rel = ii * ( 1.d0 * ( nn )) * bessel * besselP * pperpbar / zbar case ( 5 ) !T xz int_T_res_rel = ( 1.d0 * nn ) * bessel * bessel * pparbar / zbar case ( 6 ) !T yz int_T_res_rel = ( - 1.d0 * ii ) * bessel * besselP * pparbar * pperpbar end select return end function int_T_res_rel ! Calculate the complex Bessel function subroutine CBESSJ ( z , nu , z1 ) !--------------------------------------------------- !                       inf.     (-z&#94;2/4)&#94;k !   Jnu(z) = (z/2)&#94;nu x Sum  ------------------ !                       k=0  k! x Gamma(nu+k+1) !  (nu must be >= 0). !--------------------------------------------------- implicit none double complex :: z , z1 integer :: k , MAXK , nu double complex :: sum , tmp double precision :: ZERO parameter ( MAXK = 20 , ZERO = 0.d0 ) sum = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) do k = 0 , MAXK !calculate (-z**2/4)**k tmp = ( - z * z / 4.d0 ) ** k !divide by k! tmp = tmp / Fact ( k ) !divide by Gamma(nu+k+1) tmp = tmp / Gamma ( 1.d0 * ( nu + k + 1 )) !actualize sum sum = sum + tmp end do !calculate (z/2)**nu tmp = ( z / 2.d0 ) ** nu !multiply (z/2)**nu by sum z1 = tmp * sum return end subroutine double precision function Fact ( K ) implicit none integer :: i , k double precision :: f f = 1.d0 do i = 2 , k f = f * ( 1.d0 * i ) end do Fact = f return end function DOUBLE PRECISION FUNCTION BESSJ ( N , X ) !double precision FUNCTION BESSJ (N,X) !     This subroutine calculates the first kind Bessel function !     of integer order N, for any REAL X. We use here the classical !     recursion formula, when X > N. For X < N, the Miller's algorithm !     is used to avoid overflows. !     REFERENCE: !     C.W.CLENSHAW, CHEBYSHEV SERIES FOR MATHEMATICAL FUNCTIONS, !     MATHEMATICAL TABLES, VOL.5, 1962. IMPLICIT NONE INTEGER , PARAMETER :: IACC = 40 REAL * 8 , PARAMETER :: BIGNO = 1.D10 , BIGNI = 1.D-10 INTEGER M , N , J , JSUM !REAL *8 X,BESSJ,TOX,BJM,BJ,BJP,SUM REAL * 8 X , TOX , BJM , BJ , BJP , SUM !REAL *8 X,BESSJ0,BESSJ1,TOX,BJM,BJ,BJP,SUM !      REAL *8 X,BESSJ,BESSJ0,BESSJ1,TOX,BJM,BJ,BJP,SUM !write(*,*)'z: ', x IF ( N . EQ . 0 ) THEN BESSJ = BESSJ0 ( X ) RETURN ENDIF IF ( N . EQ . 1 ) THEN BESSJ = BESSJ1 ( X ) RETURN ENDIF IF ( X . EQ . 0. ) THEN BESSJ = 0. RETURN ENDIF TOX = 2. / X IF ( X . GT . FLOAT ( N )) THEN BJM = BESSJ0 ( X ) BJ = BESSJ1 ( X ) DO 11 J = 1 , N - 1 BJP = J * TOX * BJ - BJM BJM = BJ BJ = BJP 11 CONTINUE BESSJ = BJ ELSE M = 2 * (( N + INT ( SQRT ( FLOAT ( IACC * N )))) / 2 ) BESSJ = 0. JSUM = 0 SUM = 0. BJP = 0. BJ = 1. DO 12 J = M , 1 , - 1 BJM = J * TOX * BJ - BJP BJP = BJ BJ = BJM IF ( ABS ( BJ ). GT . BIGNO ) THEN BJ = BJ * BIGNI BJP = BJP * BIGNI BESSJ = BESSJ * BIGNI SUM = SUM * BIGNI ENDIF IF ( JSUM . NE . 0 ) SUM = SUM + BJ JSUM = 1 - JSUM IF ( J . EQ . N ) BESSJ = BJP 12 CONTINUE SUM = 2. * SUM - BJ BESSJ = BESSJ / SUM ENDIF RETURN END FUNCTION !double precision FUNCTION BESSJ0 (X) DOUBLE PRECISION FUNCTION BESSJ0 ( X ) IMPLICIT NONE REAL * 8 X , AX , FR , FS , Z , FP , FQ , XX !REAL *8 X,BESSJ0,AX,FR,FS,Z,FP,FQ,XX !     This subroutine calculates the First Kind Bessel Function of !     order 0, for any real number X. The polynomial approximation by !     series of Chebyshev polynomials is used for 0<X<8 and 0<8/X<1. !     REFERENCES: !     M.ABRAMOWITZ,I.A.STEGUN, HANDBOOK OF MATHEMATICAL FUNCTIONS, 1965. !     C.W.CLENSHAW, NATIONAL PHYSICAL LABORATORY MATHEMATICAL TABLES, !     VOL.5, 1962. REAL * 8 Y , P1 , P2 , P3 , P4 , P5 , R1 , R2 , R3 , R4 , R5 , R6 & , Q1 , Q2 , Q3 , Q4 , Q5 , S1 , S2 , S3 , S4 , S5 , S6 DATA P1 , P2 , P3 , P4 , P5 / 1.D0 , - . 1098628627 D - 2 ,. 2734510407 D - 4 , & - . 2073370639 D - 5 ,. 2093887211 D - 6 / DATA Q1 , Q2 , Q3 , Q4 , Q5 /- . 1562499995 D - 1 ,. 1430488765 D - 3 , & - . 6911147651 D - 5 ,. 7621095161 D - 6 , - . 9349451520 D - 7 / DATA R1 , R2 , R3 , R4 , R5 , R6 / 5756849057 4.D0 , - 1336259035 4.D0 , & 65161964 0.7D0 , - 1121442 4.18D0 , 7739 2.33017D0 , - 18 4.9052456D0 / DATA S1 , S2 , S3 , S4 , S5 , S6 / 5756849041 1.D0 , 102953298 5.D0 , & 949468 0.718D0 , 5927 2.64853D0 , 26 7.8532712D0 , 1.D0 / IF ( X . EQ . 0.D0 ) GO TO 1 AX = ABS ( X ) IF ( AX . LT . 8.D0 ) THEN Y = X * X FR = R1 + Y * ( R2 + Y * ( R3 + Y * ( R4 + Y * ( R5 + Y * R6 )))) FS = S1 + Y * ( S2 + Y * ( S3 + Y * ( S4 + Y * ( S5 + Y * S6 )))) BESSJ0 = FR / FS ELSE Z = 8.D0 / AX Y = Z * Z XX = AX - . 785398164 D0 FP = P1 + Y * ( P2 + Y * ( P3 + Y * ( P4 + Y * P5 ))) FQ = Q1 + Y * ( Q2 + Y * ( Q3 + Y * ( Q4 + Y * Q5 ))) BESSJ0 = SQRT (. 636619772 D0 / AX ) * ( FP * COS ( XX ) - Z * FQ * SIN ( XX )) ENDIF RETURN 1 BESSJ0 = 1.D0 RETURN END FUNCTION BESSJ0 ! --------------------------------------------------------------------------- !double precision FUNCTION BESSJ1 (X) double precision FUNCTION BESSJ1 ( X ) IMPLICIT NONE !REAL *8 X,BESSJ1,AX,FR,FS,Z,FP,FQ,XX REAL * 8 X , AX , FR , FS , Z , FP , FQ , XX !     This subroutine calculates the First Kind Bessel Function of !     order 1, for any real number X. The polynomial approximation by !     series of Chebyshev polynomials is used for 0<X<8 and 0<8/X<1. !     REFERENCES: !     M.ABRAMOWITZ,I.A.STEGUN, HANDBOOK OF MATHEMATICAL FUNCTIONS, 1965. !     C.W.CLENSHAW, NATIONAL PHYSICAL LABORATORY MATHEMATICAL TABLES, !     VOL.5, 1962. REAL * 8 Y , P1 , P2 , P3 , P4 , P5 , P6 , R1 , R2 , R3 , R4 , R5 , R6 & , Q1 , Q2 , Q3 , Q4 , Q5 , S1 , S2 , S3 , S4 , S5 , S6 DATA P1 , P2 , P3 , P4 , P5 / 1.D0 ,. 183105 D - 2 , - . 3516396496 D - 4 , & . 2457520174 D - 5 , - . 240337019 D - 6 / , P6 / . 636619772 D0 / DATA Q1 , Q2 , Q3 , Q4 , Q5 / . 04687499995 D0 , - . 2002690873 D - 3 , & . 8449199096 D - 5 , - . 88228987 D - 6 ,. 105787412 D - 6 / DATA R1 , R2 , R3 , R4 , R5 , R6 / 7236261423 2.D0 , - 789505923 5.D0 , & 24239685 3.1D0 , - 297261 1.439D0 , 1570 4.48260D0 , - 3 0.16036606D0 / DATA S1 , S2 , S3 , S4 , S5 , S6 / 14472522844 2.D0 , 230053517 8.D0 , & 1858330 4.74D0 , 9944 7.43394D0 , 37 6.9991397D0 , 1.D0 / AX = ABS ( X ) IF ( AX . LT . 8. ) THEN Y = X * X FR = R1 + Y * ( R2 + Y * ( R3 + Y * ( R4 + Y * ( R5 + Y * R6 )))) FS = S1 + Y * ( S2 + Y * ( S3 + Y * ( S4 + Y * ( S5 + Y * S6 )))) BESSJ1 = X * ( FR / FS ) ELSE Z = 8. / AX Y = Z * Z XX = AX - 2.35619491 FP = P1 + Y * ( P2 + Y * ( P3 + Y * ( P4 + Y * P5 ))) FQ = Q1 + Y * ( Q2 + Y * ( Q3 + Y * ( Q4 + Y * Q5 ))) BESSJ1 = SQRT ( P6 / AX ) * ( COS ( XX ) * FP - Z * SIN ( XX ) * FQ ) * SIGN ( S6 , X ) ENDIF RETURN END FUNCTION BESSJ1 !******************************************* !*           FUNCTION  GAMMA(X)            * !* --------------------------------------- * !* Returns the value of Gamma(x) in double * !* precision as EXP(LN(GAMMA(X))) for X>0. * !******************************************* double precision Function Gamma ( xx ) implicit none double precision :: xx , ONE , FPF , HALF double precision :: cof ( 6 ) double precision :: stp , x , tmp , ser integer :: j parameter ( ONE = 1.d0 , FPF = 5.5d0 , HALF = 0.5d0 ) cof ( 1 ) = 7 6.18009173d0 cof ( 2 ) =- 8 6.50532033d0 cof ( 3 ) = 2 4.01409822d0 cof ( 4 ) =- 1.231739516d0 cof ( 5 ) = 0.120858003d-2 cof ( 6 ) =- 0.536382d-5 stp = 2.50662827465d0 x = xx - ONE tmp = x + FPF tmp = ( x + HALF ) * LOG ( tmp ) - tmp ser = ONE do j = 1 , 6 x = x + ONE ser = ser + cof ( j ) / x end do Gamma = EXP ( tmp + LOG ( stp * ser )) return end function end module alps_fns_rel","tags":"","loc":"sourcefile/alps_fns_rel.f90.html"},{"title":"ALPS.f90 – ALPS","text":"Contents Programs alps Source Code ALPS.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== program alps use alps_var , only : nproc , iproc , ierror , proc0 , sproc use alps_var , only : use_map , unit_error , scan_option use alps_var , only : writeOut , f0 , nperp , npar , nspec , n_scan use alps_io , only : init_param , read_f0 , get_unused_unit use alps_io , only : alps_error , alps_error_init , output_time , display_credits use alps_fns , only : derivative_f0 , disp , secant use alps_fns , only : refine_guess use alps_fns , only : determine_nmax , split_processes , determine_bessel_array use alps_fns , only : map_search use alps_fns , only : om_scan , om_double_scan use alps_com , only : pass_instructions , pass_distribution use alps_analyt , only : determine_param_fit use alps_check , only : check_parameters use mpi implicit none integer :: ik !! Index for iterating through wavevector scans with [[om_scan(subroutine)]] !! or [[om_double_scan(subroutine)]] !Initialize MPI message passing: call mpi_init ( ierror ) call mpi_comm_size ( mpi_comm_world , nproc , ierror ) call mpi_comm_rank ( mpi_comm_world , iproc , ierror ) !Set logical proc0=true if iproc=0: proc0 = ( iproc == 0 ) if ( proc0 ) then call alps_error_init !alps_io write ( * , '(a)' ) 'Starting ALPS===================================' write ( * , '(a)' ) \"Time:\" call output_time !alps_io write ( * , '(a)' ) '================================================' call display_credits !alps_io endif call mpi_barrier ( mpi_comm_world , ierror ) if ( proc0 ) write ( * , '(a)' ) 'All processes are up and running.' !Check to be sure nproc is even and greater than 2, otherwise shutdown: if (( mod ( nproc , 2 ) . ne . 0 ). or .( nproc . le . 2 )) call alps_error ( 0 ) !alps_io !Read parameters: if ( proc0 ) call init_param !alps_io !Split Problem Amongst Processors. !Pass relevant information from readin: call pass_instructions !alps_com if ( proc0 ) then !Allocate background distribution function f0: allocate ( f0 ( 1 : nspec , 0 : nperp , 0 : npar )); f0 = 0.d0 !Read in f0: call read_f0 !alps_io !Calculate pperp, ppar derivatives of f0: call derivative_f0 !alps_fns !Calculate best fit to f0: call determine_param_fit !alps_analyt !f0 not needed for dispersion calculation. !Deallocate to save space: deallocate ( f0 ) !Check Input Parameters and Distributions: call check_parameters !alps_check endif !Distribute input and derived parameters: call pass_distribution ! alps_com ! Once we know kperp, we can determine nmax and split the processes. ! The following three routines will also be called when kperp changes: call determine_nmax ! alps_fns call split_processes ! alps_fns ! All processes determine their Bessel function array: if (. NOT .( sproc . EQ . 0 )) call determine_bessel_array ! alps_fns call mpi_barrier ( mpi_comm_world , ierror ) !Either: !use_map=.true.  : !    use a scan over (omega,gamma) to local dispersion solutions: !OR !use_map=.false. : !    use user input roots as initial guesses for dispersion solutions: if ( use_map ) then if ( writeOut . and . proc0 ) & write ( * , '(a)' ) 'Map Search' call map_search !alps_fns else if ( writeOut . and . proc0 ) & write ( * , '(a)' ) 'Starting Secant Method' call refine_guess !alps_fns endif if ( n_scan . gt . 0 ) then !setting n_scan=0 turns off wavevector scanning select case ( scan_option ) case ( 1 ) !scan along perscribed paths in wavevector space: do ik = 1 , n_scan call om_scan ( ik ) !alps_fns enddo case ( 2 ) !scan along a plane in wavevector space: if ( n_scan == 2 ) then call om_double_scan !alps_fns else call alps_error ( 4 ) !alps_io endif case default !scan_option not selected call alps_error ( 3 ) !alps_io end select endif !Finalize MPI message passing call mpi_finalize ( ierror ) if ( proc0 ) then write ( * , '(a)' ) 'Finishing ALPS===================================' write ( * , '(a)' ) \"Time:\" call output_time write ( * , '(a)' ) '================================================' write ( unit_error , '(a)' ) 'Run completed without fatal error.' close ( unit_error ) endif end program alps","tags":"","loc":"sourcefile/alps.f90.html"},{"title":"ALPS_NHDS.f90 – ALPS","text":"Contents Modules alps_nhds Source Code ALPS_NHDS.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_nhds implicit none private :: calc_ypsilon , besselI , BESSI , BESSI0 , BESSI1 , WOFZ , dispfunct public :: calc_chi contains ! This file is part of NHDS ! Copyright (C) 2020 Daniel Verscharen (d.verscharen@ucl.ac.uk) !All rights reserved. ! !Redistribution and use in source and binary forms, with or without !modification, are permitted provided that the following conditions are met: ! !1. Redistributions of source code must retain the above copyright notice, this !   list of conditions and the following disclaimer. !2. Redistributions in binary form must reproduce the above copyright notice, !   this list of conditions and the following disclaimer in the documentation !   and/or other materials provided with the distribution. ! !THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND !ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED !WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE !DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR !ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES !(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; !LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND !ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT !(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS !SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! !The views and conclusions contained in the software and documentation are those !of the authors and should not be interpreted as representing official policies, !either expressed or implied, of the NHDS project. subroutine calc_chi ( chi , j , kz , kperp , x ) use alps_var , only : bMnmaxs , bMBessel_zeros , bMbetas , bMalphas , bMpdrifts use alps_var , only : ms , qs , ns implicit none double complex :: chi ( 3 , 3 ), Y ( 3 , 3 ), Ynew ( 3 , 3 ), x double precision :: kz , kperp , z double precision :: Omega , ell , vtherm , Bessel_zero , vdrift integer :: j , n , i , k , nmaxrun logical :: Bessel_run integer :: nmax Omega = qs ( j ) / ms ( j ) ell = sqrt ( ms ( j ) / ( ns ( j ) * qs ( j ) * qs ( j ))) vtherm = sqrt ( bMbetas ( j ) / ( ns ( j ) * ms ( j ))) nmax = bMnmaxs ( j ) Bessel_zero = bMBessel_zeros ( j ) vdrift = bMpdrifts ( j ) / ms ( j ) z = 0.5d0 * ( kperp * vtherm / Omega ) * ( kperp * vtherm / Omega ) * bMalphas ( j ) do i = 1 , 3 do k = 1 , 3 Y ( i , k ) = 0.d0 enddo enddo !determine maximum n for Besselfunction: nmaxrun = nmax n = 0 Bessel_run = . TRUE . do while ( Bessel_run ) if (( n . GE . nmax ). OR .( besselI ( n , z ). LT . Bessel_zero )) then nmaxrun = n Bessel_run = . FALSE . endif n = n + 1 enddo do n =- nmaxrun , nmaxrun call calc_ypsilon ( Ynew , j , n , kz , kperp , x ) do i = 1 , 3 do k = 1 , 3 Y ( i , k ) = Y ( i , k ) + exp ( - z ) * Ynew ( i , k ) enddo enddo enddo chi ( 1 , 1 ) = Y ( 1 , 1 ) / ( ell * ell ) chi ( 1 , 2 ) = Y ( 1 , 2 ) / ( ell * ell ) chi ( 1 , 3 ) = Y ( 1 , 3 ) / ( ell * ell ) chi ( 2 , 1 ) = Y ( 2 , 1 ) / ( ell * ell ) chi ( 2 , 2 ) = Y ( 2 , 2 ) / ( ell * ell ) chi ( 2 , 3 ) = Y ( 2 , 3 ) / ( ell * ell ) chi ( 3 , 1 ) = Y ( 3 , 1 ) / ( ell * ell ) chi ( 3 , 2 ) = Y ( 3 , 2 ) / ( ell * ell ) chi ( 3 , 3 ) = 2.d0 * x * vdrift / ( ell * ell * kz * vtherm * vtherm * bMalphas ( j )) + Y ( 3 , 3 ) / ( ell * ell ) end subroutine subroutine calc_ypsilon ( Y , j , n , kz , kperp , x ) use alps_var , only : bMbetas , bMalphas , bMpdrifts use alps_var , only : ms , qs , ns implicit none double complex , parameter :: uniti = ( 0.d0 , 1.d0 ) double complex :: zeta , x , Y ( 3 , 3 ), An , Bn , resfac double precision :: kz , kperp , BInz , z double precision :: Omega , ell , vtherm , vdrift !double precision :: besselI double precision :: dBInzdz integer :: n , j logical :: kpos kpos = . TRUE . if ( kz . LT . 0.d0 ) kpos = . FALSE . Omega = qs ( j ) / ms ( j ) ell = sqrt ( ms ( j ) / ( ns ( j ) * qs ( j ) * qs ( j ))) vtherm = sqrt ( bMbetas ( j ) / ( ns ( j ) * ms ( j ))) vdrift = bMpdrifts ( j ) / ms ( j ) zeta = ( x - kz * vdrift - 1.d0 * n * Omega ) / ( kz * vtherm ) resfac = x - kz * vdrift - 1.d0 * n * Omega z = 0.5d0 * ( kperp * vtherm / Omega ) * ( kperp * vtherm / Omega ) * bMalphas ( j ) An = ( bMalphas ( j ) - 1.d0 ) An = An + ( 1.d0 / ( kz * vtherm )) * ( bMalphas ( j ) * resfac + 1.d0 * n * Omega ) * dispfunct ( zeta , kpos ) Bn = ( bMalphas ( j ) * ( x - 1.d0 * n * Omega ) - ( kz * vdrift - 1.d0 * n * Omega )) / kz Bn = Bn + (( x - 1.d0 * n * Omega ) * ( bMalphas ( j ) * resfac + 1.d0 * n * Omega ) / ( kz * kz * vtherm ) ) * dispfunct ( zeta , kpos ) if ( n . GE . 0 ) then BInz = 1.d0 * besselI ( n , z ) dBInzdz = besselI ( n + 1 , z ) + 1.d0 * n * BInz / z else BInz = 1.d0 * besselI ( - n , z ) dBInzdz = besselI ( - n - 1 , z ) + 1.d0 * n * BInz / z endif ! The tensor in Stix's (10-57) Y ( 1 , 1 ) = 1.d0 * ( n * n ) * BInz * An / z Y ( 1 , 2 ) =- uniti * n * ( BInz - dBInzdz ) * An Y ( 1 , 3 ) = kperp * n * BInz * Bn / ( Omega * z ) Y ( 2 , 1 ) = uniti * n * ( BInz - dBInzdz ) * An Y ( 2 , 2 ) = ( 1.d0 * ( n * n ) * BInz / z + 2.d0 * z * BInz - 2.d0 * z * dBInzdz ) * An Y ( 2 , 3 ) = uniti * kperp * ( BInz - dBInzdz ) * Bn / Omega Y ( 3 , 1 ) = kperp * BInz * n * Bn / ( Omega * z ) Y ( 3 , 2 ) =- uniti * kperp * ( BInz - dBInzdz ) * Bn / Omega Y ( 3 , 3 ) = 2.d0 * ( x - 1.d0 * n * Omega ) * BInz * Bn / ( kz * vtherm * vtherm * bMalphas ( j )) end subroutine double precision function besselI ( n , x ) implicit none double precision :: x integer :: n if ( n . LT . 0 ) then besselI = BESSI ( - n , x ) else besselI = BESSI ( n , x ) endif end function ! ! Calculate the dispersion function: ! double complex function dispfunct ( zeta , kpos ) implicit none double complex , parameter :: uniti = ( 0.d0 , 1.d0 ) double complex :: zeta logical :: flag , kpos double precision :: U , V , XI , YI double precision :: M_PI = 4.d0 * atan ( 1.d0 ) XI = 1.d0 * real ( zeta ) YI = 1.d0 * aimag ( zeta ) if ( kpos ) then call WOFZ ( XI , YI , U , V , flag ) dispfunct = uniti * sqrt ( M_PI ) * ( U + uniti * V ) else call WOFZ ( - XI , - YI , U , V , flag ) dispfunct = - uniti * sqrt ( M_PI ) * ( U + uniti * V ) endif end function !Based on !G.P.M. Poppe, C.M.J. Wijers, \"More Efficient Computation of the Complex Error-Function\", !ACM Trans. Math. Software 16, 47 (1990). !C      ALGORITHM 680, COLLECTED ALGORITHMS FROM ACM. !C      THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE, !C      VOL. 16, NO. 1, PP. 47 SUBROUTINE WOFZ ( XI , YI , U , V , FLAG ) !C !C  GIVEN A COMPLEX NUMBER Z = (XI,YI), THIS SUBROUTINE COMPUTES !C  THE VALUE OF THE FADDEEVA-FUNCTION W(Z) = EXP(-Z**2)*ERFC(-I*Z), !C  WHERE ERFC IS THE COMPLEX COMPLEMENTARY ERROR-FUNCTION AND I !C  MEANS SQRT(-1). !C  THE ACCURACY OF THE ALGORITHM FOR Z IN THE 1ST AND 2ND QUADRANT !C  IS 14 SIGNIFICANT DIGITS; IN THE 3RD AND 4TH IT IS 13 SIGNIFICANT !C  DIGITS OUTSIDE A CIRCULAR REGION WITH RADIUS 0.126 AROUND A ZERO !C  OF THE FUNCTION. !C  ALL REAL VARIABLES IN THE PROGRAM ARE DOUBLE PRECISION. !C !C !C  THE CODE CONTAINS A FEW COMPILER-DEPENDENT PARAMETERS : !C     RMAXREAL = THE MAXIMUM VALUE OF RMAXREAL EQUALS THE ROOT OF !C                RMAX = THE LARGEST NUMBER WHICH CAN STILL BE !C                IMPLEMENTED ON THE COMPUTER IN DOUBLE PRECISION !C                FLOATING-POINT ARITHMETIC !C     RMAXEXP  = LN(RMAX) - LN(2) !C     RMAXGONI = THE LARGEST POSSIBLE ARGUMENT OF A DOUBLE PRECISION !C                GONIOMETRIC FUNCTION (DCOS, DSIN, ...) !C  THE REASON WHY THESE PARAMETERS ARE NEEDED AS THEY ARE DEFINED WILL !C  BE EXPLAINED IN THE CODE BY MEANS OF COMMENTS !C !C !C  PARAMETER LIST !C     XI     = REAL      PART OF Z !C     YI     = IMAGINARY PART OF Z !C     U      = REAL      PART OF W(Z) !C     V      = IMAGINARY PART OF W(Z) !C     FLAG   = AN ERROR FLAG INDICATING WHETHER OVERFLOW WILL !C              OCCUR OR NOT; TYPE LOGICAL; !C              THE VALUES OF THIS VARIABLE HAVE THE FOLLOWING !C              MEANING : !C              FLAG=.FALSE. : NO ERROR CONDITION !C              FLAG=.TRUE.  : OVERFLOW WILL OCCUR, THE ROUTINE !C                             BECOMES INACTIVE !C  XI, YI      ARE THE INPUT-PARAMETERS !C  U, V, FLAG  ARE THE OUTPUT-PARAMETERS !C !C  FURTHERMORE THE PARAMETER FACTOR EQUALS 2/SQRT(PI) !C !C  THE ROUTINE IS NOT UNDERFLOW-PROTECTED BUT ANY VARIABLE CAN BE !C  PUT TO 0 UPON UNDERFLOW; !C !C  REFERENCE - GPM POPPE, CMJ WIJERS; MORE EFFICIENT COMPUTATION OF !C  THE COMPLEX ERROR-FUNCTION, ACM TRANS. MATH. SOFTWARE. !C !* !* !* !* IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) IMPLICIT INTEGER ( I - N ) LOGICAL A , B , FLAG PARAMETER ( FACTOR = 1.12837916709551257388D0 , RMAXREAL = 0.5D+154 , RMAXEXP = 70 8.503061461606D0 ,& & RMAXGONI = 3.53711887601422D+15 ) FLAG = . FALSE . XABS = DABS ( XI ) YABS = DABS ( YI ) X = XABS / 6.3 Y = YABS / 4.4 !* !C !C     THE FOLLOWING IF-STATEMENT PROTECTS !C     QRHO = (X**2 + Y**2) AGAINST OVERFLOW !C IF (( XABS . GT . RMAXREAL ). OR .( YABS . GT . RMAXREAL )) GOTO 100 QRHO = X ** 2 + Y ** 2 XABSQ = XABS ** 2 XQUAD = XABSQ - YABS ** 2 YQUAD = 2 * XABS * YABS A = QRHO . LT . 0.085264D0 IF ( A ) THEN !C !C  IF (QRHO.LT.0.085264D0) THEN THE FADDEEVA-FUNCTION IS EVALUATED !C  USING A POWER-SERIES (ABRAMOWITZ/STEGUN, EQUATION (7.1.5), P.297) !C  N IS THE MINIMUM NUMBER OF TERMS NEEDED TO OBTAIN THE REQUIRED !C  ACCURACY !C QRHO = ( 1 - 0.85 * Y ) * DSQRT ( QRHO ) N = IDNINT ( 6 + 72 * QRHO ) J = 2 * N + 1 XSUM = 1.0 / J YSUM = 0.0D0 DO 10 I = N , 1 , - 1 J = J - 2 XAUX = ( XSUM * XQUAD - YSUM * YQUAD ) / I YSUM = ( XSUM * YQUAD + YSUM * XQUAD ) / I XSUM = XAUX + 1.0 / J 10 CONTINUE U1 = - FACTOR * ( XSUM * YABS + YSUM * XABS ) + 1.0 V1 = FACTOR * ( XSUM * XABS - YSUM * YABS ) DAUX = DEXP ( - XQUAD ) U2 = DAUX * DCOS ( YQUAD ) V2 = - DAUX * DSIN ( YQUAD ) U = U1 * U2 - V1 * V2 V = U1 * V2 + V1 * U2 ELSE !C !C  IF (QRHO.GT.1.O) THEN W(Z) IS EVALUATED USING THE LAPLACE !C  CONTINUED FRACTION !C  NU IS THE MINIMUM NUMBER OF TERMS NEEDED TO OBTAIN THE REQUIRED !C  ACCURACY !C !C  IF ((QRHO.GT.0.085264D0).AND.(QRHO.LT.1.0)) THEN W(Z) IS EVALUATED !C  BY A TRUNCATED TAYLOR EXPANSION, WHERE THE LAPLACE CONTINUED FRACTION !C  IS USED TO CALCULATE THE DERIVATIVES OF W(Z) !C  KAPN IS THE MINIMUM NUMBER OF TERMS IN THE TAYLOR EXPANSION NEEDED !C  TO OBTAIN THE REQUIRED ACCURACY !C  NU IS THE MINIMUM NUMBER OF TERMS OF THE CONTINUED FRACTION NEEDED !C  TO CALCULATE THE DERIVATIVES WITH THE REQUIRED ACCURACY ! IF ( QRHO . GT . 1.0 ) THEN H = 0.0D0 KAPN = 0 QRHO = DSQRT ( QRHO ) NU = IDINT ( 3 + ( 1442 / ( 26 * QRHO + 77 ))) ELSE QRHO = ( 1 - Y ) * DSQRT ( 1 - QRHO ) H = 1.88 * QRHO H2 = 2 * H KAPN = IDNINT ( 7 + 34 * QRHO ) NU = IDNINT ( 16 + 26 * QRHO ) ENDIF B = ( H . GT . 0.0 ) IF ( B ) QLAMBDA = H2 ** KAPN RX = 0.0 RY = 0.0 SX = 0.0 SY = 0.0 DO 11 N = NU , 0 , - 1 NP1 = N + 1 TX = YABS + H + NP1 * RX TY = XABS - NP1 * RY C = 0.5 / ( TX ** 2 + TY ** 2 ) RX = C * TX RY = C * TY IF (( B ). AND .( N . LE . KAPN )) THEN TX = QLAMBDA + SX SX = RX * TX - RY * SY SY = RY * TX + RX * SY QLAMBDA = QLAMBDA / H2 ENDIF 11 CONTINUE IF ( H . EQ . 0.0 ) THEN U = FACTOR * RX V = FACTOR * RY ELSE U = FACTOR * SX V = FACTOR * SY END IF IF ( YABS . EQ . 0.0 ) U = DEXP ( - XABS ** 2 ) END IF !C  EVALUATION OF W(Z) IN THE OTHER QUADRANTS IF ( YI . LT . 0.0 ) THEN IF ( A ) THEN U2 = 2 * U2 V2 = 2 * V2 ELSE XQUAD = - XQUAD !         THE FOLLOWING IF-STATEMENT PROTECTS 2*EXP(-Z**2) !        AGAINST OVERFLOW IF (( YQUAD . GT . RMAXGONI ). OR . ( XQUAD . GT . RMAXEXP )) GOTO 100 W1 = 2 * DEXP ( XQUAD ) U2 = W1 * DCOS ( YQUAD ) V2 = - W1 * DSIN ( YQUAD ) END IF U = U2 - U V = V2 - V IF ( XI . GT . 0.0 ) V = - V ELSE IF ( XI . LT . 0.0 ) V = - V END IF RETURN 100 FLAG = . TRUE . RETURN END !************************************************************************ !*                                                                      * !*    Program to calculate the first kind modified Bessel function of   * !*    integer order N, for any REAL X, using the function BESSI(N,X).   * !*                                                                      * !* -------------------------------------------------------------------- * !* -------------------------------------------------------------------- * !*   Reference: From Numath Library By Tuan Dang Trong in Fortran 77.   * !*                                                                      * !*                               F90 Release 1.1 By J-P Moreau, Paris.  * !*                                                                      * !*   Version 1.1: corected value of P4 in BESSIO (P4=1.2067492 and not  * !*                1.2067429) Aug. 2011.                                 * !************************************************************************ ! ---------------------------------------------------------------------- double precision FUNCTION BESSI ( N , X ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) IMPLICIT INTEGER ( I - N ) !     This subroutine calculates the first kind modified Bessel function !     of integer order N, for any REAL X. We use here the classical !     recursion formula, when X > N. For X < N, the Miller's algorithm !     is used to avoid overflows. !     REFERENCE: !     C.W.CLENSHAW, CHEBYSHEV SERIES FOR MATHEMATICAL FUNCTIONS, !     MATHEMATICAL TABLES, VOL.5, 1962. ! PARAMETER ( IACC = 40 , BIGNO = 1.D10 , BIGNI = 1.D-10 ) REAL * 8 X , TOX , BIM , BI , BIP IF ( N . EQ . 0 ) THEN BESSI = BESSI0 ( X ) RETURN ENDIF IF ( N . EQ . 1 ) THEN BESSI = BESSI1 ( X ) RETURN ENDIF IF ( X . EQ . 0.D0 ) THEN BESSI = 0.D0 RETURN ENDIF TOX = 2.D0 / X BIP = 0.D0 BI = 1.D0 BESSI = 0.D0 M = 2 * (( N + INT ( SQRT ( FLOAT ( IACC * N ))))) DO 12 J = M , 1 , - 1 BIM = BIP + DFLOAT ( J ) * TOX * BI BIP = BI BI = BIM IF ( ABS ( BI ). GT . BIGNO ) THEN BI = BI * BIGNI BIP = BIP * BIGNI BESSI = BESSI * BIGNI ENDIF IF ( J . EQ . N ) BESSI = BIP 12 CONTINUE BESSI = BESSI * BESSI0 ( X ) / BI RETURN END ! ---------------------------------------------------------------------- ! Auxiliary Bessel functions for N=0, N=1 double precision FUNCTION BESSI0 ( X ) REAL * 8 X , Y , P1 , P2 , P3 , P4 , P5 , P6 , P7 , & Q1 , Q2 , Q3 , Q4 , Q5 , Q6 , Q7 , Q8 , Q9 , AX , BX DATA P1 , P2 , P3 , P4 , P5 , P6 , P7 / 1.D0 , 3.5156229D0 , 3.0899424D0 , 1.2067492D0 , & 0.2659732D0 , 0.360768D-1 , 0.45813D-2 / DATA Q1 , Q2 , Q3 , Q4 , Q5 , Q6 , Q7 , Q8 , Q9 / 0.39894228D0 , 0.1328592D-1 , & 0.225319D-2 , - 0.157565D-2 , 0.916281D-2 , - 0.2057706D-1 , & 0.2635537D-1 , - 0.1647633D-1 , 0.392377D-2 / IF ( ABS ( X ). LT . 3.75D0 ) THEN Y = ( X / 3.75D0 ) ** 2 BESSI0 = P1 + Y * ( P2 + Y * ( P3 + Y * ( P4 + Y * ( P5 + Y * ( P6 + Y * P7 ))))) ELSE AX = ABS ( X ) Y = 3.75D0 / AX BX = EXP ( AX ) / SQRT ( AX ) AX = Q1 + Y * ( Q2 + Y * ( Q3 + Y * ( Q4 + Y * ( Q5 + Y * ( Q6 + Y * ( Q7 + Y * ( Q8 + Y * Q9 ))))))) BESSI0 = AX * BX ENDIF RETURN END ! ---------------------------------------------------------------------- double precision FUNCTION BESSI1 ( X ) REAL * 8 X , Y , P1 , P2 , P3 , P4 , P5 , P6 , P7 , & Q1 , Q2 , Q3 , Q4 , Q5 , Q6 , Q7 , Q8 , Q9 , AX , BX DATA P1 , P2 , P3 , P4 , P5 , P6 , P7 / 0.5D0 , 0.87890594D0 , 0.51498869D0 , & 0.15084934D0 , 0.2658733D-1 , 0.301532D-2 , 0.32411D-3 / DATA Q1 , Q2 , Q3 , Q4 , Q5 , Q6 , Q7 , Q8 , Q9 / 0.39894228D0 , - 0.3988024D-1 , & - 0.362018D-2 , 0.163801D-2 , - 0.1031555D-1 , 0.2282967D-1 , & - 0.2895312D-1 , 0.1787654D-1 , - 0.420059D-2 / IF ( ABS ( X ). LT . 3.75D0 ) THEN Y = ( X / 3.75D0 ) ** 2 BESSI1 = X * ( P1 + Y * ( P2 + Y * ( P3 + Y * ( P4 + Y * ( P5 + Y * ( P6 + Y * P7 )))))) ELSE AX = ABS ( X ) Y = 3.75D0 / AX BX = EXP ( AX ) / SQRT ( AX ) AX = Q1 + Y * ( Q2 + Y * ( Q3 + Y * ( Q4 + Y * ( Q5 + Y * ( Q6 + Y * ( Q7 + Y * ( Q8 + Y * Q9 ))))))) BESSI1 = AX * BX ENDIF RETURN END ! ---------------------------------------------------------------------- end module alps_nhds","tags":"","loc":"sourcefile/alps_nhds.f90.html"},{"title":"ALPS_check.f90 – ALPS","text":"Contents Modules alps_check Source Code ALPS_check.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_check !! Verification of input parameters and distributions. implicit none public :: check_parameters !private :: contains subroutine check_parameters !! Verifies input parameters and distributions. !! @todo !! Add !! - [ ] Quasi-Neutrality !! - [ ] Zero Net Current !! - [ ] ... !! @endtodo implicit none write ( * , '(a)' ) \"Running parameter checks...\" write ( * , '(a)' ) \" Parameter checks completed.\" write ( * , '(a)' ) \"-=-=-=-=-=-=-=-=-\" end subroutine end module","tags":"","loc":"sourcefile/alps_check.f90.html"},{"title":"ALPS_io.f90 – ALPS","text":"Contents Modules alps_io Source Code ALPS_io.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_io implicit none !Numbers for identifying input/output files integer :: unit integer , parameter :: stdout_unit = 6 integer , save :: input_unit_no , error_unit_no = stdout_unit private :: get_runname , get_indexed_namelist_unit private :: input_unit_exist , input_unit private :: map_read , solution_read , spec_read , scan_read , bM_read public :: init_param , read_f0 , get_unused_unit , alps_error public :: output_time , display_credits , isnancheck contains !-=-=-=-=- !Read in System parameters from *.in file !Only processor 0 calls this routine !-=-=-=-=- subroutine init_param use alps_var , only : runname , foldername , kperp , kpar , option , nroots , D_prec , D_gap use alps_var , only : kperp_last , kpar_last , kperp_0 , kpar_0 use alps_var , only : use_map , writeOut , wroots , nspec , numroots use alps_var , only : nperp , npar , arrayName , fit_check , param_fit , fit_type , perp_correction use alps_var , only : ns , qs , ms , vA , Bessel_zero , numiter , D_threshold , positions_principal use alps_var , only : determine_minima , n_resonance_interval , ngamma , npparbar , Tlim use alps_var , only : scan_option , n_scan , scan , relativistic , logfit , usebM use alps_var , only : maxsteps_fit , n_fits , lambda_initial_fit , lambdafac_fit , epsilon_fit use alps_var , only : bMnmaxs , bMBessel_zeros , bMbetas , bMalphas , bMpdrifts implicit none integer :: ik , is , ifit , ip !Solution, species, fit, additional index !Namelist read in from input file. nameList / system / & kperp , kpar , nspec , option , nroots , use_map , writeOut ,& nperp , npar , ngamma , npparbar , vA , arrayName , Bessel_zero , numiter , D_threshold , & D_prec , D_gap , positions_principal , Tlim , & maxsteps_fit , lambda_initial_fit , lambdafac_fit , epsilon_fit , fit_check , & determine_minima , n_resonance_interval , scan_option , n_scan !Get a unassigned unit number for input/output call get_unused_unit ( input_unit_no ) !Read in system parameters !runname called earlier in alps_error_init unit = input_unit_no open ( unit = unit , file = trim ( foldername ) // trim ( runname ) // \".in\" , status = 'old' , action = 'read' ) read ( unit = unit , nml = system ) if ( writeOut ) & write ( * , '(2a)' ) & 'Reading from Input File: ' , trim ( runname ) !save initial kperp,kpar values kperp_last = kperp ; kpar_last = kpar kperp_0 = kperp ; kpar_0 = kpar !Allocate solution space for nroots dispersion solutions allocate ( wroots ( 1 : numroots )); wroots = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) !Read in map scan parameters if ( use_map ) then if ( writeOut ) & write ( * , '(a)' ) 'MAP ROUTINE' ik = 1 !Either read in parameters for complex frequency map !Some FORTRAN compliers require namelists to be the first !declared item, thus requiring a separate subroutine unit = input_unit_no call get_indexed_namelist_unit ( unit , \"maps\" , ik ) call map_read close ( unit ) else !OR !read in guesses for solutions if ( writeOut ) & write ( * , '(a)' ) 'GUESS ROUTINE: ' do ik = 1 , nroots unit = input_unit_no call get_indexed_namelist_unit ( unit , \"guess\" , ik ) !Some FORTRAN compliers require namelists to be the first !declared item, thus requiring a separate subroutine) call solution_read ( ik ) write ( * , '(a,i3,a,2es14.4)' ) 'Intial Guess ' , ik , ' : ' , wroots ( ik ) close ( unit ) enddo endif !read in species density, charge, and mass from input file if ( writeOut ) & write ( * , '(a)' ) 'SPECIES PARAMETERS: ' allocate ( ns ( 1 : nspec )); ns = 0.d0 allocate ( qs ( 1 : nspec )); qs = 0.d0 allocate ( ms ( 1 : nspec )); ms = 0.d0 allocate ( n_fits ( 1 : nspec )); n_fits = 1 allocate ( relativistic ( 1 : nspec )); relativistic = . FALSE . allocate ( logfit ( 1 : nspec )); logfit = . TRUE . allocate ( usebM ( 1 : nspec )); usebM = . TRUE . allocate ( bMnmaxs ( 1 : nspec )); bMnmaxs = 500 allocate ( bMBessel_zeros ( 1 : nspec )); bMBessel_zeros = 1.d-50 allocate ( bMbetas ( 1 : nspec )); bMbetas = 1.d0 allocate ( bMalphas ( 1 : nspec )); bMalphas = 1.d0 allocate ( bMpdrifts ( 1 : nspec )); bMpdrifts = 0.d0 do is = 1 , nspec !READ IN SPECIES PARAMETERS unit = input_unit_no call get_indexed_namelist_unit ( unit , \"spec\" , is ) !Some FORTRAN compliers require namelists to be the first !declared item, thus requiring a separate subroutine) call spec_read ( is ) write ( * , '(a,i3,a)' ) 'Species ' , is , ' : ' write ( * , '(a,es11.4,a,es11.4,a,es11.4)' )& ' ns/nREF = ' , ns ( is ), ' | qs/qREF = ' , qs ( is ), ' | ms/mREF = ' , ms ( is ) write ( * , '(a,i4)' )& ' Number of fitted functions = ' , n_fits ( is ) if ( n_fits ( is ). EQ . 0 ) & write ( * , '(a)' ) ' Using function defined in distribution/distribution_analyt.f90' write ( * , '(a,l1)' )& ' Relativistic effects = ' , relativistic ( is ) close ( unit ) enddo !I assume that n_fits for any species won't be more than 10 smaller !than the n_fits(ref). KGK -------> If we do it here, we don't have to assume that. DV 2016-05-18 !Quite right. A much cleaner solution. KGK- 2016-05-18 allocate ( param_fit ( 1 : nspec , 0 : max ( nperp , ngamma ), 5 , maxval ( n_fits ))) allocate ( fit_type ( 1 : nspec , maxval ( n_fits ))) allocate ( perp_correction ( 1 : nspec , maxval ( n_fits ))) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' do is = 1 , nspec !READ IN SPECIES FIT PARAMETERS if ( usebM ( is )) then write ( * , '(a,i2,a)' ) 'Species ' , is , ' uses bi-Maxwellian calculation...skipping fits. Parameters:' call get_indexed_namelist_unit ( unit , \"bM_spec\" , is ) call bM_read ( is ) write ( * , '(a,i4,a,es11.4)' )& '  nmax = ' , bMnmaxs ( is ), ',        Bessel_zero = ' , bMBessel_zeros ( is ) write ( * , '(a,es11.4,a,es11.4,a,es11.4)' )& '  beta = ' , bMbetas ( is ), ', alpha = ' , bMalphas ( is ), ', drift momentum = ' , bMpdrifts ( is ) close ( unit ) else do ifit = 1 , n_fits ( is ) !call get_indexed_namelist_unit (unit, \"ffit\", ifit) call get_indexed_double_namelist_unit ( unit , \"ffit\" , is , ifit ) call fit_read ( is , ifit ) select case ( fit_type ( is , ifit )) case ( 1 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', Maxwellian fit: ' case ( 2 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', kappa fit: ' case ( 3 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', Juettner fit (pperp and ppar): ' case ( 4 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', Juettner fit (gamma-dependent only): ' case ( 5 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', Juettner fit (gamma and pparbar): ' case ( 6 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', bi-Moyal fit: ' case default write ( * , '(a)' )& 'Function fit undefined' stop end select do ip = 1 , 5 write ( * , '(a,i2,a,es14.4)' )& ' Initial fit parameter ' , ip , ' = ' , param_fit ( is , 0 , ip , ifit ) enddo write ( * , '(a,es14.4)' )& ' Perpendicular correction:  ' , perp_correction ( is , ifit ) close ( unit ) enddo endif enddo !Read in selection for scan paramter if ( n_scan . gt . 0 ) then write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' allocate ( scan ( n_scan )) do ip = 1 , n_scan unit = input_unit_no call get_indexed_namelist_unit ( unit , \"scan_input\" , ip ) call scan_read ( ip ) close ( unit ) enddo write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' endif close ( unit ) end subroutine init_param !-=-=-=-=- !-=-=-=-=- !-=-=-=-=- !Subroutine for reading in map parameters !-=-=-=-=- subroutine map_read !KGK use alps_var , only : loggridw , loggridg , omi , omf , gami , gamf , ni , nr implicit none nameList / maps / & loggridw , loggridg , omi , omf , gami , gamf , ni , nr read ( unit = unit , nml = maps ) end subroutine map_read !-=-=-=-=- !-=-=-=-=- !-=-=-=-=- !Subroutine for reading in initial guesses for dispersion solutions !-=-=-=-=- subroutine solution_read ( ik ) use alps_var , only : wroots implicit none !Passed integer :: ik !solution index !Local double precision :: g_om , g_gam !Guesses for (real, imaginary) solution nameList / guess / & g_om , g_gam read ( unit = unit , nml = guess ) wroots ( ik ) = cmplx ( g_om , g_gam , kind ( 1.d0 )) end subroutine solution_read !-=-=-=-=- !-=-=-=-=- !-=-=-=-=- !Subroutine for reading in species parameters !-=-=-=-=- subroutine spec_read ( is ) use alps_var , only : ns , qs , ms , n_fits , relativistic , logfit , usebM implicit none !Passed integer :: is !species index !Local double precision :: nn , qq , mm ! Read in values for ns, qs, ms integer :: ff !read in value for number of fitted functions for species logical :: relat = . false . logical :: log_fit = . true . logical :: use_bM = . false . nameList / spec / & nn , qq , mm , ff , relat , log_fit , use_bM read ( unit = unit , nml = spec ) ns ( is ) = nn ; qs ( is ) = qq ; ms ( is ) = mm ; n_fits ( is ) = ff ; relativistic ( is ) = relat ; & logfit ( is ) = log_fit ; usebM ( is ) = use_bM end subroutine spec_read !-=-=-=-=- !-=-=-=-=- !Subroutine for reading in bi-Maxwellian parameters !-=-=-=-=- subroutine bM_read ( is ) use alps_var , only : bMnmaxs , bMBessel_zeros , bMbetas , bMalphas , bMpdrifts implicit none !Passed integer :: is !species index !Local integer :: bM_nmaxs double precision :: bM_Bessel_zeros , bM_betas , bM_alphas , bM_pdrifts nameList / bM_spec / & bM_nmaxs , bM_Bessel_zeros , bM_betas , bM_alphas , bM_pdrifts read ( unit = unit , nml = bM_spec ) bMnmaxs ( is ) = bM_nmaxs ; bMBessel_zeros ( is ) = bM_Bessel_zeros ; bMbetas ( is ) = bM_betas ; & bMalphas ( is ) = bM_alphas ; bMpdrifts ( is ) = bM_pdrifts end subroutine bM_read !-=-=-=-=- !-=-=-=-=- !Subroutine for reading in wavevector scan parameters !-=-=-=-=- subroutine scan_read ( is ) use alps_var , only : scan , kperp_last , kpar_last implicit none !Passed integer :: is !scan index !Local integer :: scan_type , ns , nres double precision :: swi , swf logical :: swlog , heating , eigen double precision :: theta_0 double precision :: k_0 nameList / scan_input / & scan_type , swi , swf , swlog , ns , nres ,& heating , eigen read ( unit = unit , nml = scan_input ) scan ( is )% range_i = swi scan ( is )% range_f = swf scan ( is )% log_scan = swlog scan ( is )% type_s = scan_type scan ( is )% n_out = ns scan ( is )% n_res = nres scan ( is )% eigen_s = eigen scan ( is )% heat_s = heating !calculate step size select case ( scan_type ) case ( 0 ) !scan from k_0 to k_1 write ( * , '(a,i0,a,es12.3,a,es12.3,a,es12.3,a,es12.3,a)' )& 'Scan ' , is , ': (kpar,kperp) from (' ,& kperp_last , ',' , kpar_last , ') to (' , swi , ',' , swf , ')' if ( swlog ) then scan ( is )% diff = ( log10 ( swi ) - log10 ( kperp_last )) / ( 1.d0 * ns * nres ) scan ( is )% diff2 = ( log10 ( swf ) - log10 ( kpar_last )) / ( 1.d0 * ns * nres ) else scan ( is )% diff = ( swi - kperp_last ) / ( 1.d0 * ns * nres ) scan ( is )% diff2 = ( swf - kpar_last ) / ( 1.d0 * ns * nres ) endif kperp_last = swi ; kpar_last = swf case ( 1 ) !scan from theta_0 to theta_1 theta_0 = atan ( kperp_last / kpar_last ); k_0 = sqrt ( kperp_last ** 2 + kpar_last ** 2 ) write ( * , '(a,i0,a,es12.3,a,es12.3)' )& 'Scan ' , is , ': theta from ' ,& theta_0 * 18 0.d0 / ( 4.d0 * atan ( 1.d0 )), ' to ' , swf if ( swlog ) then scan ( is )% diff = ( log10 ( swf * 4.d0 * atan ( 1.d0 ) / 18 0. ) - log10 ( theta_0 )) / ( 1.d0 * ns * nres ) else scan ( is )% diff = (( swf * 4.d0 * atan ( 1.d0 ) / 18 0. ) - theta_0 ) / ( 1.d0 * ns * nres ) endif kpar_last = k_0 * cos ( swf * 4.d0 * atan ( 1.d0 ) / 18 0.d0 ) kperp_last = k_0 * sin ( swf * 4.d0 * atan ( 1.d0 ) / 18 0.d0 ) case ( 2 ) !scan from |k_0| to |k_1| at constant theta theta_0 = atan ( kperp_last / kpar_last ); k_0 = sqrt ( kperp_last ** 2 + kpar_last ** 2 ) write ( * , '(a,i0,a,es12.3,a,es12.3,a,es12.3,a,es12.3,a)' )& 'Scan ' , is , ': |k| from ' ,& k_0 , ' to ' , swf , ' at theta=' , theta_0 * 18 0.d0 / ( 4.d0 * atan ( 1.d0 )) if ( swlog ) then scan ( is )% diff = ( log10 ( swf * sin ( theta_0 )) - log10 ( kperp_last )) / ( 1.d0 * ns * nres ) scan ( is )% diff2 = ( log10 ( swf * cos ( theta_0 )) - log10 ( kpar_last )) / ( 1.d0 * ns * nres ) else scan ( is )% diff = ( swf * sin ( theta_0 ) - kperp_last ) / ( 1.d0 * ns * nres ) scan ( is )% diff2 = ( swf * cos ( theta_0 ) - kpar_last ) / ( 1.d0 * ns * nres ) endif kpar_last = swf * cos ( theta_0 ) kperp_last = swf * sin ( theta_0 ) case ( 3 ) !scan of kperp; kpar constant write ( * , '(a,i0,a,es12.3,a,es12.3)' )& 'Scan ' , is , ': kperp from ' , kperp_last , ' to ' , swf if ( swlog ) then scan ( is )% diff = ( log10 ( swf ) - log10 ( kperp_last )) / ( 1.d0 * ns * nres ) else scan ( is )% diff = ( swf - kperp_last ) / ( 1.d0 * ns * nres ) endif kperp_last = swf case ( 4 ) !scan of kpar; kperp constant write ( * , '(a,i0,a,es12.3,a,es12.3)' )& 'Scan ' , is , ': kpar from ' , kpar_last , ' to ' , swf if ( swlog ) then scan ( is )% diff = ( log10 ( swf ) - log10 ( kpar_last )) / ( 1.d0 * ns * nres ) else scan ( is )% diff = ( swf - kpar_last ) / ( 1.d0 * ns * nres ) endif kpar_last = swf end select end subroutine scan_read !-=-=-=-=- !-=-=-=-=- !-=-=-=-=- !Subroutine for reading in species parameters !-=-=-=-=- subroutine fit_read ( is , ifit ) use alps_var , only : fit_type , param_fit , perp_correction implicit none !Passed integer :: is , ifit !species,  index !Local double precision :: fit_1 , fit_2 , fit_3 , fit_4 , fit_5 ! Read in values for fit functions double precision :: perpcorr integer :: fit_type_in !read in value for type of analytic function nameList / ffit / & fit_type_in , fit_1 , fit_2 , fit_3 , fit_4 , fit_5 , perpcorr fit_1 = 0.d0 ; fit_2 = 0.d0 ; fit_3 = 0.d0 ; fit_4 = 0.d0 ; fit_5 = 0.d0 ; perpcorr = 0.d0 read ( unit = unit , nml = ffit ) fit_type ( is , ifit ) = fit_type_in param_fit ( is , 0 , 1 , ifit ) = fit_1 param_fit ( is , 0 , 2 , ifit ) = fit_2 param_fit ( is , 0 , 3 , ifit ) = fit_3 param_fit ( is , 0 , 4 , ifit ) = fit_4 param_fit ( is , 0 , 5 , ifit ) = fit_5 perp_correction ( is , ifit ) = perpcorr end subroutine fit_read !-=-=-=-=- !-=-=-=-=- !-=-=-=-=- ! Get runname for output files from input argument !-=-=-=-=- subroutine get_runname ( runname , foldername ) implicit none integer :: l integer :: pathend character ( 500 ) :: arg character ( 500 ), intent ( out ) :: runname character ( 500 ), intent ( out ) :: foldername !Get the first argument of the program execution command call getarg ( 1 , arg ) pathend = 0 !Check if this is the input file and trim .in extension to get runname !Also remove any folder structure from the runname: l = len_trim ( arg ) pathend = scan ( arg , \"/\" , . true .) if ( l > 3 . and . arg ( l - 2 : l ) == \".in\" ) then runname = arg ( pathend + 1 : l - 3 ) foldername = arg ( 1 : pathend ) end if end subroutine get_runname !-=-=-=-=- !-=-=-=-=- !-=-=-=-=- ! Subroutine for reading in background distribution function !-=-=-=-=- subroutine read_f0 use alps_var , only : nperp , npar , arrayName , f0 , pp , nspec use alps_var , only : writeOut , usebM implicit none !Local integer :: iperp , ipar !parallel and perpendicular indices integer :: is !species index character ( 100 ) :: readname if ( writeOut ) & write ( * , '(2a)' )& 'Attempting to read f0 array from file: ' , trim ( arrayName ) call get_unused_unit ( input_unit_no ) unit = input_unit_no !The f0 arrays are stored in the distribution folder !arrayName is read in from *.in input file !each species is has a unique file for f0 and pp do is = 1 , nspec if ( usebM ( is )) then write ( * , '(a,i2)' ) ' Bi-Maxwellian calcuation: not reading f0 array for species ' , is f0 ( is ,:,:) = 0.d0 pp ( is ,:,:,:) = 0.d0 else write ( readname , '(3a,i0,a)' ) & \"distribution/\" , trim ( arrayName ), '.' , is , \".array\" open ( unit = unit , file = trim ( readname ), status = 'old' , action = 'read' ) do iperp = 0 , nperp do ipar = 0 , npar !read in: pperp, ppar, f0 read ( unit , * ) pp ( is , iperp , ipar , 1 ), pp ( is , iperp , ipar , 2 ), f0 ( is , iperp , ipar ) enddo enddo close ( unit ) endif enddo end subroutine read_f0 !-=-=-=-=- !-=-=-=-=- !-=-=-=-=-=- !The following routines: !    get_indexed_namelist_unit !    input_unit_exist !    get_unused_unit !    input_unit !were all adopted from the Astrophysical Gyrokinetic Code (AGK) !as a means of allowing arbitrary namelist group name input. !A bit of hassle, but worth the effort. !-=-=-=-=-=- subroutine get_indexed_namelist_unit ( unit , nml , index_in ) use alps_var , only : runname implicit none integer , intent ( out ) :: unit character ( * ), intent ( in ) :: nml integer , intent ( in ) :: index_in character ( 500 ) :: line integer :: iunit , iostat , in_file integer :: ind_slash logical :: exist call get_unused_unit ( unit ) ind_slash = index ( runname , \"/\" ,. True .) if ( ind_slash . EQ . 0 ) then !No slash in name !Original behaviour open ( unit = unit , file = '.' // trim ( runname ) // '.scratch' ) else !General behaviour open ( unit = unit , file = trim ( runname ( 1 : ind_slash )) // \".\" // trim ( runname ( ind_slash + 1 :)) // \".scratch\" ) endif write ( line , * ) index_in line = nml // \"_\" // trim ( adjustl ( line )) in_file = input_unit_exist ( trim ( line ), exist ) if ( exist ) then iunit = input_unit ( trim ( line )) else call alps_error ( 1 ) !return end if read ( unit = iunit , fmt = \"(a)\" ) line write ( unit = unit , fmt = \"('&',a)\" ) nml do read ( unit = iunit , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 . or . trim ( adjustl ( line )) == \"/\" ) exit write ( unit = unit , fmt = \"(a)\" ) trim ( line ) end do write ( unit = unit , fmt = \"('/')\" ) rewind ( unit = unit ) end subroutine get_indexed_namelist_unit !KGK- a work around to allow fit parameter readins for !an arbitrary number of species for an arbitrary number of fitted functions subroutine get_indexed_double_namelist_unit ( unit , nml , spec_in , index_in ) use alps_var , only : runname implicit none integer , intent ( out ) :: unit character ( * ), intent ( in ) :: nml integer , intent ( in ) :: index_in integer , intent ( in ) :: spec_in character ( 500 ) :: line , lines integer :: iunit , iostat , in_file integer :: ind_slash logical :: exist call get_unused_unit ( unit ) ind_slash = index ( runname , \"/\" ,. True .) if ( ind_slash . EQ . 0 ) then !No slash in name !Original behaviour open ( unit = unit , file = '.' // trim ( runname ) // '.scratch' ) else !General behaviour open ( unit = unit , file = trim ( runname ( 1 : ind_slash )) // \".\" // trim ( runname ( ind_slash + 1 :)) // \".scratch\" ) endif write ( line , * ) index_in write ( lines , * ) spec_in line = nml // \"_\" // trim ( adjustl ( lines )) // \"_\" // trim ( adjustl ( line )) in_file = input_unit_exist ( trim ( line ), exist ) if ( exist ) then iunit = input_unit ( trim ( line )) else call alps_error ( 1 ) end if read ( unit = iunit , fmt = \"(a)\" ) line write ( unit = unit , fmt = \"('&',a)\" ) nml do read ( unit = iunit , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 . or . trim ( adjustl ( line )) == \"/\" ) exit write ( unit = unit , fmt = \"(a)\" ) trim ( line ) end do write ( unit = unit , fmt = \"('/')\" ) rewind ( unit = unit ) end subroutine get_indexed_double_namelist_unit function input_unit_exist ( nml , exist ) implicit none character ( * ), intent ( in ) :: nml logical , intent ( out ) :: exist integer :: input_unit_exist , iostat character ( 500 ) :: line intrinsic adjustl , trim input_unit_exist = input_unit_no exist = . true . if ( input_unit_no > 0 ) then rewind ( unit = input_unit_no ) do read ( unit = input_unit_no , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) then rewind ( unit = input_unit_no ) exit end if if ( trim ( adjustl ( line )) == \"&\" // nml ) then backspace ( unit = input_unit_no ) return end if end do end if exist = . false . end function input_unit_exist function input_unit ( nml ) implicit none character ( * ), intent ( in ) :: nml integer :: input_unit , iostat character ( 500 ) :: line intrinsic adjustl , trim input_unit = input_unit_no if ( input_unit_no > 0 ) then rewind ( unit = input_unit_no ) do read ( unit = input_unit_no , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) then rewind ( unit = input_unit_no ) exit end if if ( trim ( adjustl ( line )) == \"&\" // nml ) then backspace ( unit = input_unit_no ) return end if end do end if write ( unit = error_unit_no , fmt = \"('Couldn''t find namelist: ',a)\" ) nml write ( unit =* , fmt = \"('Couldn''t find namelist: ',a)\" ) nml end function input_unit subroutine get_unused_unit ( unit ) implicit none integer , intent ( out ) :: unit logical :: od unit = 50 do inquire ( unit = unit , opened = od ) if (. not . od ) return unit = unit + 1 end do end subroutine get_unused_unit !-=-=-=-=-=- !Open a file for the error log subroutine alps_error_init use alps_var , only : unit_error , runname , foldername implicit none call get_unused_unit ( unit_error ) !Get the run name, which comes from the name !of the input file appended after the executable: !mpirun -np 8 ./alps.e sample.in !yields a run name of 'sample' call get_runname ( runname , foldername ) open ( unit = unit_error , file = trim ( foldername ) // trim ( runname ) // \".log\" , status = 'replace' ) end subroutine alps_error_init !Error catching subroutine subroutine alps_error ( error_id ) use alps_var , only : ierror , unit_error , nproc , scan_option use mpi implicit none integer :: error_id !    if (proc0) then select case ( error_id ) case ( 0 ) !seen by all processors write ( * , '(a,i6)' ) 'ERROR: Number of processors must be even and greater than 2: nproc= ' , nproc write ( unit_error , '(a,i6)' ) 'ERROR: Number of processors must be even and greater than 2: nproc= ' , nproc case ( 1 ) !seen by proc0 write ( * , '(2a)' ) \"get_indexed_namelist: required input namelist not found \" write ( unit_error , '(2a)' ) \"get_indexed_namelist: required input namelist not found \" case ( 2 ) !seen by proc0 write ( * , '(a)' ) \"ERROR: More fit parameters than data points.\" write ( unit_error , '(a)' ) \"ERROR: More fit parameters than data points.\" case ( 3 ) !seen by all processors write ( * , '(a,i6)' )& 'ERROR: scan_option not set to allowable value:' , scan_option write ( unit_error , '(a,i6)' )& 'ERROR: scan_option not set to allowable value:' , scan_option case ( 4 ) !seen by all processors write ( * , '(a)' )& 'ERROR: n_scan .ne.2 for scan_option=2' write ( unit_error , '(a)' )& 'ERROR: n_scan .ne.2 for scan_option=2' case ( 5 ) !seen by all processors write ( * , '(a)' )& 'ERROR: scan(1)%type_s==scan(2)%type_s for double k scan' write ( unit_error , '(a)' )& 'ERROR: scan(1)%type_s==scan(2)%type_s for double k scan' case ( 6 ) !seen by all processors write ( * , '(a)' )& 'ERROR: scan(*)%type_s=0 not allowed for double k scan' write ( unit_error , '(a)' )& 'ERROR: scan(*)%type_s=0 not allowed for double k scan' case ( 7 ) !seen by all processors write ( * , '(a)' )& 'ERROR: Fit for analytical continuation failed. Adjustment of perpcorr may resolve this problem.' write ( unit_error , '(a)' )& 'ERROR: Fit for analytical continuation failed. Adjustment of perpcorr may resolve this problem.' case ( 8 ) !seen by all processors write ( * , '(a)' )& 'ERROR: Resonance integration covers entire subluminal cone.' write ( * , '(a)' )& '       Adjustment of positions_principal, npar, or a non-relativistic run may resolve this problem.' write ( unit_error , '(a)' )& 'ERROR: Resonance integration covers entire subluminal cone.' write ( unit_error , '(a)' )& '       Adjustment of positions_principal, npar, or a non-relativistic run may resolve this problem.' case ( 9 ) !seen by all processors write ( * , '(a)' )& 'ERROR: All roots diverged. Adjustment of initial guesses or step width may resolve this problem.' write ( unit_error , '(a)' )& 'ERROR: All roots diverged. Adjustment of initial guesses or step width may resolve this problem.' case default write ( * , '(a)' ) 'ERROR: Unspecified...' write ( unit_error , '(a)' ) 'ERROR: Unspecified...' end select write ( * , '(a)' ) 'Finishing ALPS==================================' write ( * , '(a)' ) \"Time:\" call output_time write ( * , '(a)' ) '================================================' !   endif close ( unit_error ) call mpi_abort ( MPI_COMM_WORLD , error_id , ierror ) stop end subroutine alps_error !checks if double precision number input is NaN logical function isnancheck ( input ) implicit none double precision :: input isnancheck = . FALSE . if ( abs ( input ). GE . huge ( 1.d0 )) isnancheck = . TRUE . !if ((input+1.d0).EQ.input) isnancheck=.TRUE. if ( input . NE . input ) isnancheck = . TRUE . end function isnancheck !-=-=-=-=-=-= !Output the date and time in a given format !-=-=-=-=-=-= subroutine output_time implicit none character ( 8 ) :: date character ( 10 ) :: time character ( 5 ) :: zone integer , dimension ( 8 ) :: value call date_and_time ( date , time , zone , value ) write ( * , '(i4,a,i2.2,a,i2.2,a,i2.2,a,i2.2,a,i2.2)' ) value ( 1 ), \"-\" , value ( 2 ), \"-\" , value ( 3 ), \" -- \" , value ( 5 ), \":\" , value ( 6 ), \":\" , value ( 7 ) end subroutine !-=-=-=-=-=-= !write the opening credits !-=-=-=-=-=-= subroutine display_credits implicit none write ( * , * ) \"===========================================================\" write ( * , * ) \"I                                                         I\" write ( * , * ) \"I                       A  L  P  S                        I\" write ( * , * ) \"I              Arbitrary Linear Plasma Solver             I\" write ( * , * ) \"I                                                         I\" write ( * , * ) \"I                       Version 1.0                       I\" write ( * , * ) \"I                                                         I\" write ( * , * ) \"I  Kristopher Klein   (kgklein@arizone.edu)               I\" write ( * , * ) \"I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)            I\" write ( * , * ) \"I                                                         I\" write ( * , * ) \"===========================================================\" end subroutine end module alps_io","tags":"","loc":"sourcefile/alps_io.f90.html"},{"title":"ALPS_com.f90 – ALPS","text":"Contents Modules alps_com Source Code ALPS_com.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_com implicit none public :: pass_instructions public :: pass_distribution contains !-=-=-=-=-=-=-=-=-= !Routine for passing information !-=-=-=-=-=-=-=-=-= subroutine pass_instructions use alps_var , only : proc0 , ierror , nroots , n_fits , param_fit , fit_type , perp_correction use alps_var , only : writeOut , nperp , npar , nmax , nlim , nspec , numroots , ngamma , npparbar use alps_var , only : ns , qs , ms , wroots , kperp , kpar , bessel_zero , D_prec use alps_var , only : wave , chi0 , pp , df0 , vA , pi , numiter , D_threshold , D_gap use alps_var , only : use_map use alps_var , only : ni , nr , omi , omf , gami , gamf , loggridg , loggridw use alps_var , only : determine_minima , n_resonance_interval , positions_principal , Tlim use alps_var , only : n_scan , scan , scan_option , relativistic , logfit , usebM use alps_var , only : bMnmaxs , bMBessel_zeros , bMbetas , bMalphas , bMpdrifts use mpi implicit none !Local integer :: is !Broadcast Global Variables needed for code execution call mpi_bcast ( nperp , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( npar , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( ngamma , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( npparbar , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( nspec , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( nroots , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( numiter , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( n_resonance_interval , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( positions_principal , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( writeOut , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( kperp , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( kpar , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( vA , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bessel_zero , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( D_threshold , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( D_prec , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( D_gap , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( Tlim , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( use_map , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( n_scan , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan_option , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) if ( use_map ) then call mpi_bcast ( omi , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( omf , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( gami , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( gamf , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( loggridw , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( loggridg , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( ni , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( nr , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( determine_minima , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) endif pi = 4.d0 * atan ( 1.d0 ) allocate ( nmax ( 1 : nspec )); nmax = 0 nlim = 0 !Point to Point Communication: if ( proc0 ) then !+ Send instructions !wroots allocated for proc0 in ALPS_io !to allow for reading in of guesses for the dispersion solution else !+ Receive instructions allocate ( ns ( 1 : nspec )); ns = 0.d0 allocate ( qs ( 1 : nspec )); qs = 0.d0 allocate ( ms ( 1 : nspec )); ms = 0.d0 allocate ( n_fits ( 1 : nspec )) allocate ( relativistic ( 1 : nspec )); relativistic = . FALSE . allocate ( logfit ( 1 : nspec )); logfit = . TRUE . allocate ( usebM ( 1 : nspec )); usebM = . TRUE . allocate ( bMnmaxs ( 1 : nspec )); bMnmaxs = 500 allocate ( bMBessel_zeros ( 1 : nspec )); bMBessel_zeros = 1.d-50 allocate ( bMbetas ( 1 : nspec )); bMbetas = 1.d0 allocate ( bMalphas ( 1 : nspec )); bMalphas = 1.d0 allocate ( bMpdrifts ( 1 : nspec )); bMpdrifts = 0.d0 !Allocate solution space for nroots dispersion solutions allocate ( wroots ( 1 : numroots )); wroots = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) if ( n_scan . gt . 0 ) allocate ( scan ( n_scan )) endif call mpi_bcast ( ns (:), size ( ns (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( qs (:), size ( qs (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( ms (:), size ( ms (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( n_fits (:), size ( n_fits (:)),& MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( relativistic (:), size ( relativistic (:)),& MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( logfit (:), size ( logfit (:)),& MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( usebM (:), size ( usebM (:)),& MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMnmaxs (:), size ( bMnmaxs (:)),& MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMBessel_zeros (:), size ( bMBessel_zeros (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMbetas (:), size ( bMbetas (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMalphas (:), size ( bMalphas (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMpdrifts (:), size ( bMpdrifts (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( wroots (:), size ( wroots (:)),& MPI_DOUBLE_COMPLEX , 0 , MPI_COMM_WORLD , ierror ) !There is a 'better' way to do this with derived data types and mpi, but this way works, !and only has to be called once. if ( n_scan . gt . 0 ) then do is = 1 , n_scan call mpi_bcast ( scan ( is )% range_i , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% range_f , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% diff , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% diff2 , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% log_scan , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% eigen_s , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% heat_s , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% type_s , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% n_out , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% n_res , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) enddo endif !Allocation of Arrays: if (. true .. neqv . proc0 ) then allocate ( param_fit ( 1 : nspec , 0 :( max ( nperp , ngamma )), 5 , maxval ( n_fits ))) allocate ( fit_type ( 1 : nspec , maxval ( n_fits ))) allocate ( perp_correction ( 1 : nspec , maxval ( n_fits ))) endif !Allocate Wave Equation Tensor !  Only needed on proc0 if ( proc0 ) then allocate ( wave ( 1 : 3 , 1 : 3 )) !KGK: added chi0 as global character allocate ( chi0 ( nspec , 1 : 3 , 1 : 3 )) wave = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) endif !Allocate derivative of f0 allocate ( df0 ( 1 : nspec , 1 : nperp - 1 , 1 : npar - 1 , 1 : 2 )); df0 = 0.d0 !Allocate fit parameters !Allocate velocity grid allocate ( pp ( 1 : nspec , 0 : nperp , 0 : npar , 1 : 2 )); pp = 0.d0 end subroutine pass_instructions !-=-=-=-=-=-=-=-=-= !Routine for passing distribution function parameters !-=-=-=-=-=-=-=-=-= subroutine pass_distribution use alps_var , only : df0 , pp , param_fit , fit_type , perp_correction , proc0 , writeOut , ierror use alps_var , only : df0_rel , gamma_rel , pparbar_rel , f0_rel use alps_var , only : relativistic , nspec , ngamma , npparbar use mpi implicit none integer :: is_rel , is , nspec_rel logical :: any_relativistic !+ Broadcast derivative array if ( writeOut . and . proc0 )& write ( * , '(a)' ) 'Broadcasting df0/dp...' any_relativistic = . FALSE . is_rel = 0 do is = 1 , nspec if ( relativistic ( is )) then any_relativistic = . TRUE . is_rel = is_rel + 1 endif enddo if ( any_relativistic ) then nspec_rel = is_rel if (. not .( proc0 )) then ! Allocate the relativistic fields: allocate ( gamma_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) allocate ( pparbar_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) allocate ( df0_rel ( nspec_rel , 0 : ngamma , 0 : npparbar , 2 )) allocate ( f0_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) endif call mpi_bcast ( f0_rel (:,:,:), size ( f0_rel (:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( df0_rel (:,:,:,:), size ( df0_rel (:,:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( gamma_rel (:,:,:), size ( gamma_rel (:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( pparbar_rel (:,:,:), size ( pparbar_rel (:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) endif call mpi_bcast ( df0 (:,:,:,:), size ( df0 (:,:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( pp (:,:,:,:), size ( pp (:,:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( param_fit (:,:,:,:), size ( param_fit (:,:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( fit_type (:,:), size ( fit_type (:,:)),& MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( perp_correction (:,:), size ( perp_correction (:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) if ( writeOut . and . proc0 )& write ( * , '(a)' ) ' df0/dp received' end subroutine pass_distribution end module alps_com","tags":"","loc":"sourcefile/alps_com.f90.html"},{"title":"ALPS_analyt.f90 – ALPS","text":"Contents Modules alps_analyt Source Code ALPS_analyt.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_analyt !! This module contains functions and subroutines for the hybrid analytical continuation. implicit none public :: eval_fit , determine_param_fit private :: fit_function , output_fit , determine_JT , LM_nonlinear_fit contains double complex function eval_fit ( is , iperp , ppar_valC ) !! This function evaluates the fit to f0 at and the complex parallel !! momentum [[ppar_valC]]. It requires the fit parameters that will be determined !! by the subroutine [[determine_param_fit(subroutine)]]. use alps_var , only : fit_type , pp , param_fit , n_fits , gamma_rel , nspec , relativistic use alps_distribution_analyt , only : distribution_analyt implicit none integer , intent ( in ) :: is !! Index of species for which [[eval_fit(function)]] is executed. integer , intent ( in ) :: iperp !! Index of perpendicular momentum at which [[eval_fit(function)]] is executed. double complex , intent ( in ) :: ppar_valC !! Complex parallel momentum at which [[eval_fit(function)]] is executed. double precision :: pperp_val !! Perpendicular momentum corrsponding to index [[iperp(variable)]]. integer :: par_ind !! Parameter index for the fit parameters. integer :: ifit !! Index for the fits that add up to the total fit for a given species. integer :: n_params !! Total number of fit parameters for a given species. integer :: is_rel !! Index for relativistic species (if any). integer :: sproc_rel !! MPI process number for relativistic species. integer :: is_run !! Running variable over species to determine relativistic evaluation. double precision , allocatable , dimension (:) :: params !! Array of fit parameters. ! Use the pre-coded distribution from distribution/distribution_analyt.f90 if ( n_fits ( is ). EQ . 0 ) then eval_fit = distribution_analyt ( is , pp ( is , iperp , 1 , 1 ), ppar_valC ) return endif n_params = 0 ! total number of fit_parameters do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) n_params = n_params + 3 ! Maxwell if ( fit_type ( is , ifit ). EQ . 2 ) n_params = n_params + 5 ! kappa if ( fit_type ( is , ifit ). EQ . 3 ) n_params = n_params + 3 ! Juettner with pperp and ppar if ( fit_type ( is , ifit ). EQ . 4 ) n_params = n_params + 1 ! Juettner with gamma and pparbar, constant in pparbar if ( fit_type ( is , ifit ). EQ . 5 ) n_params = n_params + 3 ! Juettner with gamma and pparbar with pparbar-dependence if ( fit_type ( is , ifit ). EQ . 6 ) n_params = n_params + 4 ! Bi-Moyal distribution enddo allocate ( params ( n_params )) par_ind = 0 do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell pperp_val = pp ( is , iperp , 1 , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa pperp_val = pp ( is , iperp , 1 , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) params ( ifit + par_ind + 3 ) = param_fit ( is , iperp , 4 , ifit ) params ( ifit + par_ind + 4 ) = param_fit ( is , iperp , 5 , ifit ) par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner in pperp and ppar pperp_val = pp ( is , iperp , 1 , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner in gamma and pparbar, constant in pparbar ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo pperp_val = gamma_rel ( sproc_rel , iperp , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) par_ind = par_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner in gamma and pparbar with pparbar-dependence ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo pperp_val = gamma_rel ( sproc_rel , iperp , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! Bi-Moyal pperp_val = pp ( is , iperp , 1 , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) params ( ifit + par_ind + 3 ) = param_fit ( is , iperp , 4 , ifit ) par_ind = par_ind + 3 endif enddo eval_fit = fit_function ( is , n_params , params , pperp_val , ppar_valC ) deallocate ( params ) return end function double complex function fit_function ( is , n_params , params , pperp_val , ppar_val ) !! This function evaluates the fit to f0 at real [[pperp_val]] and complex [[ppar_val]], !! provided that the one-dimensional fit-parameter array [[params]] is fed into the !! function. This is only used during the fitting. For the evaluation in ALPS, !! use [[eval_fit(function)]]. use alps_var , only : fit_type , n_fits , ms , vA , perp_correction implicit none integer , intent ( in ) :: is !! Index of species for which [[eval_fit(function)]] is executed. integer , intent ( in ) :: n_params !! Total number of fit parameters for a given species. double precision , intent ( in ) :: params ( n_params ) !! Array of fit parameters. double precision , intent ( in ) :: pperp_val !! Perpendicular momentum. double complex , intent ( in ) :: ppar_val !! Complex parallel momentum. integer :: ifit !! Index for the fits that add up to the total fit for a given species. integer :: par_ind !! Parameter index to loop over fits. double complex :: sqrtpart !! Square-root part of Juettner distribution. double complex :: kappapart !! Kappa part of the kappa distribution. fit_function = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) par_ind = 0 do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( - perp_correction ( is , ifit ) * pperp_val ** 2 )& * exp ( - params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa kappapart = 1.d0 + params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 & + perp_correction ( is , ifit ) * params ( ifit + par_ind + 4 ) * pperp_val ** 2 fit_function = fit_function + params ( ifit + par_ind + 0 ) * kappapart ** params ( ifit + par_ind + 3 ) par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner in pperp and ppar sqrtpart = sqrt ( 1.d0 + ( pperp_val ** 2 + ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) * vA * vA / ( ms ( is ) * ms ( is ))) fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( - params ( ifit + par_ind + 1 ) * sqrtpart ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner in gamma only, constant in pparbar fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( - perp_correction ( is , ifit ) * pperp_val ) par_ind = par_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner in gamma and pparbar with pparbar-dependence fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( - perp_correction ( is , ifit ) * pperp_val ) * & exp ( - params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! Bi-Moyal fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( 0.5d0 * ( params ( ifit + par_ind + 3 ) * & perp_correction ( is , ifit ) * pperp_val ** 2 + params ( ifit + par_ind + 1 ) * & ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 - & exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) )) par_ind = par_ind + 3 endif enddo return end function subroutine determine_param_fit !! This is the fitting routine for the hybrid analytic continuation. It determines !! the full field [[alps_var(module):param_fit(variable)]]. use alps_var , only : writeOut , fit_type , param_fit , n_fits , nspec , f0 , nperp , npar , logfit , runname use alps_var , only : relativistic , npparbar , f0_rel , ngamma , perp_correction , gamma_rel , usebM implicit none integer :: ifit !! Index for the fits that add up to the total fit for a given species. integer :: n_params !! Total number of fit parameters for a given species. integer :: par_ind !! Parameter index for the fit parameters. integer :: iperp !! Index of perpendicular momentum. integer :: is !! Index of species. integer :: is_run !! Running variable over species to determine relativistic evaluation. integer :: is_rel !! Index for relativistic species (if any). integer :: sproc_rel !! Local process index for relativistic calculation. integer :: nJT !! First dimension of matrix nJT [[determine_JT(subroutine):: JT(variable)]]. integer :: ipparbar !! Index of parallel momentum (relativistic). integer :: ipparbar_lower !! Lower index of parallel momentum (relativistic). integer :: ipparbar_upper !! Upper index of parallel momentum (relativistic). integer :: upperlimit !! Upper limit of iperp space (relativistic and non-relativistic). integer :: unit_spec !! Unit to write fit parameters to file. logical :: found_lower !! Check whether lower boundary was found. logical :: found_upper !! Check whether upper boundary was found. double precision :: quality !! Quality of the individual fit result. double precision :: qualitytotal !! Quality of the total fit result. logical , allocatable , dimension (:) :: param_mask !! Bit mask for required fit parameters. double precision , allocatable , dimension (:) :: g !! Array of function to be fitted. double precision , allocatable , dimension (:) :: params !! Array of fit parameters. character ( 10 ) :: specwrite !! File name to write fit parameters to file. if ( writeOut ) then write ( * , '(a)' ) 'Determine fit parameters for hybrid analytic continuation...' endif qualitytotal = 0.d0 do is = 1 , nspec if ( usebM ( is )) then write ( * , '(a,i2)' ) ' Bi-Maxwellian calcuation: no fits necessary for species ' , is param_fit ( is ,:,:,:) = 0.d0 fit_type ( is ,:) = 1 perp_correction ( is ,:) = 1.d0 elseif ( n_fits ( is ). EQ . 0 ) then write ( * , '(a,i2)' ) ' Using analytical function from distribution/distribution_analyt.f90: no fits necessary for species ' , is param_fit ( is ,:,:,:) = 0.d0 fit_type ( is ,:) = 1 perp_correction ( is ,:) = 1.d0 else ! For all fit types that include a fit parameter for the perpendicular momentum (kappa and Moyal), ! we must not fit this parameter when pperp=0. Otherwise, the LM matrix is singular: n_params = 0 ! total number of fit_parameters do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) n_params = n_params + 3 ! Maxwell if ( fit_type ( is , ifit ). EQ . 2 ) n_params = n_params + 5 ! kappa if ( fit_type ( is , ifit ). EQ . 3 ) n_params = n_params + 3 ! Juettner with pperp and ppar if ( fit_type ( is , ifit ). EQ . 4 ) n_params = n_params + 1 ! Juettner with gamma and pparbar, constant in pparbar if ( fit_type ( is , ifit ). EQ . 5 ) n_params = n_params + 3 ! Juettner with gamma and pparbar with pparbar-dependence if ( fit_type ( is , ifit ). EQ . 6 ) n_params = n_params + 4 ! Bi-Moyal enddo allocate ( params ( n_params )) allocate ( param_mask ( n_params )) if ( relativistic ( is )) then upperlimit = ngamma else upperlimit = nperp endif unit_spec = 2500 + is write ( specwrite , '(i0)' ) is open ( unit = unit_spec , file = 'distribution/' // trim ( runname ) // '.fit_parameters.' // trim ( specwrite ) // '.out' , status = 'replace' ) do iperp = 0 , upperlimit ! Every step that is not iperp = 0 should use the previous result as a start value: if ( iperp . NE . 0 ) param_fit ( is , iperp ,:,:) = param_fit ( is , iperp - 1 ,:,:) par_ind = 0 nJT = 0 param_mask = . TRUE . do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) params ( ifit + par_ind + 3 ) = param_fit ( is , iperp , 4 , ifit ) params ( ifit + par_ind + 4 ) = param_fit ( is , iperp , 5 , ifit ) if ( iperp . EQ . 0 ) then nJT = nJT - 1 param_mask ( ifit + par_ind + 4 ) = . FALSE . endif par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner in pperp and ppar params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner in gamma and pparbar, constant in pparbar params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) par_ind = par_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner in gamma and pparbar with pparbar-dependence params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! Bi-Moyal params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) params ( ifit + par_ind + 3 ) = param_fit ( is , iperp , 4 , ifit ) if ( iperp . EQ . 0 ) then nJT = nJT - 1 param_mask ( ifit + par_ind + 3 ) = . FALSE . endif par_ind = par_ind + 3 endif enddo nJT = nJT + n_params ! Fit and return everything in one array \"params\": if ( relativistic ( is )) then ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo ! What are the relevant ranges in pparbar: found_lower = . FALSE . found_upper = . FALSE . ipparbar_lower = 1 ipparbar_upper = npparbar - 1 do ipparbar = 1 , npparbar - 1 if ((. NOT . found_lower ). AND .( f0_rel ( sproc_rel , iperp , ipparbar - 1 ). LE . - 1.d0 ). AND .( f0_rel ( sproc_rel , iperp , ipparbar ). GT . - 1.d0 )) then ipparbar_lower = ipparbar found_lower = . TRUE . endif if ((. NOT . found_upper ). AND .( f0_rel ( sproc_rel , iperp , ipparbar ). GT . - 1.d0 ). AND .( f0_rel ( sproc_rel , iperp , ipparbar + 1 ). LE . - 1.d0 )) then ipparbar_upper = ipparbar found_upper = . TRUE . endif enddo if (( ipparbar_upper - ipparbar_lower ). GT . 2 ) then allocate ( g ( 0 : ipparbar_upper - ipparbar_lower )) if ( logfit ( is )) then g = log ( f0_rel ( sproc_rel , iperp , ipparbar_lower : ipparbar_upper )) else g = f0_rel ( sproc_rel , iperp , ipparbar_lower : ipparbar_upper ) endif call LM_nonlinear_fit ( is , g , n_params , nJT , params , param_mask , iperp ,& ( ipparbar_upper - ipparbar_lower ), ipparbar_lower , quality ) deallocate ( g ) else par_ind = 0 do ifit = 1 , n_fits ( is ) params ( ifit + par_ind + 0 ) = f0_rel ( sproc_rel , iperp ,( ipparbar_upper + ipparbar_lower ) / 2 ) / & exp ( - perp_correction ( is , ifit ) * gamma_rel ( sproc_rel , iperp , 1 )) if ( fit_type ( is , ifit ). EQ . 5 ) then params ( ifit + par_ind + 1 ) = 1.d-12 params ( ifit + par_ind + 2 ) = 0.d0 par_ind = par_ind + 2 endif enddo endif else ! non-relativistic allocate ( g ( 0 : npar )) if ( logfit ( is )) then g = log ( f0 ( is , iperp ,:)) else g = f0 ( is , iperp ,:) endif call LM_nonlinear_fit ( is , g , n_params , nJT , params , param_mask , iperp , npar , 0 , quality ) deallocate ( g ) endif qualitytotal = qualitytotal + quality ! Write  Fit parameters to output files write ( unit_spec , * ) iperp , params ! Fill it back into the param_fit field: par_ind = 0 do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) param_fit ( is , iperp , 4 , ifit ) = params ( ifit + par_ind + 3 ) param_fit ( is , iperp , 5 , ifit ) = params ( ifit + par_ind + 4 ) par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner in pperp and ppar param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner in gamma and pparbar, constant in pparbar param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) par_ind = par_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner in gamma and pparbar with pparbar-dependence param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! Bi-Moyal param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) param_fit ( is , iperp , 4 , ifit ) = params ( ifit + par_ind + 3 ) par_ind = par_ind + 3 endif enddo enddo ! End loop over iperp close ( unit_spec ) deallocate ( params ) deallocate ( param_mask ) endif enddo ! End loop over is if ( writeOut ) then call output_fit ( qualitytotal ) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' endif end subroutine subroutine output_fit ( qualitytotal ) !! This subroutine outputs the fit parameters for iperp=0 to stdout to monitor the fit. use alps_io , only : isnancheck , alps_error use alps_var , only : fit_type , param_fit , n_fits , nspec , nperp , npar , pp , f0 , pi , vA , runname use alps_var , only : relativistic , gamma_rel , pparbar_rel , ngamma , npparbar , f0_rel , ms , usebM implicit none double precision , intent ( in ) :: qualitytotal !! Quality of the total fit result. integer :: is !! Index of species. integer :: ifit !! Index for the fits that add up to the total fit for a given species. integer :: n_params !! Total number of fit parameters for a given species. integer :: iparam !! Variable running over fit parameters. integer :: unit_spec !! Unit to write fit results to file. integer :: ipar !! Index of parallel momentum. integer :: iperp !! Index of perpendicular momentum. integer :: is_rel !! Index for relativistic species (if any). integer :: sproc_rel !! Local process index for relativistic calculation. integer :: igamma !! Index of gamma (relativistic). integer :: ipparbar !! Index of pparbar (relativistic). integer :: is_run !! Index for relativistic species (if any). double precision :: integrate !! Integration of fit result. double precision :: dpperp !! Step size in pperp for integration of fit result. double precision :: dppar !! Step size in ppar for integration of fit result. double precision :: dgamma !! Step size in gamma for integration of relativistic fit result. double precision :: dpparbar !! Step size in pparbar for integration of relativistic fit result. double complex :: ppar_comp !! Complex parallel momentum to evaluate fit function at. character ( 10 ) :: specwrite !! File name to write fit results to file. write ( * , '(a)' ) ' Results of the fit for hybrid analytic continuation at iperp = 1:' do is = 1 , nspec do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) n_params = 3 if ( fit_type ( is , ifit ). EQ . 2 ) n_params = 5 if ( fit_type ( is , ifit ). EQ . 3 ) n_params = 3 if ( fit_type ( is , ifit ). EQ . 4 ) n_params = 1 if ( fit_type ( is , ifit ). EQ . 5 ) n_params = 3 if ( fit_type ( is , ifit ). EQ . 6 ) n_params = 4 if (. not . usebM ( is )) then do iparam = 1 , n_params write ( * , '(a,i2,a,i2,a,i2,a,2es14.4)' ) '  param_fit(' , is , ', 1,' , iparam , ',' , ifit , ') = ' , param_fit ( is , 1 , iparam , ifit ) enddo write ( * , '(a)' ) ' ' endif enddo enddo write ( * , '(a,es14.4)' ) ' Sum of all least-squares: ' , qualitytotal write ( * , '(a,es14.4)' ) ' Standard error of the estimate: ' , sqrt ( qualitytotal / ( 1.d0 * ( nspec * nperp * npar ))) if ( isnancheck ( qualitytotal )) call alps_error ( 7 ) write ( * , '(a)' ) ' Writing fit result to files' do is = 1 , nspec if (. not . usebM ( is )) then unit_spec = 2000 + is write ( specwrite , '(i0)' ) is open ( unit = unit_spec , file = 'distribution/' // trim ( runname ) // '.fit_result.' // trim ( specwrite ) // '.out' , status = 'replace' ) integrate = 0.d0 if ( relativistic ( is )) then ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo dgamma = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) do igamma = 0 , ngamma do ipparbar = 0 , npparbar ppar_comp = pparbar_rel ( sproc_rel , igamma , ipparbar ) if ( f0_rel ( sproc_rel , igamma , ipparbar ). EQ . - 1.d0 ) then write ( unit_spec , * ) gamma_rel ( sproc_rel , igamma , ipparbar ), pparbar_rel ( sproc_rel , igamma , ipparbar ),& \"-1.0\" , abs ( - 1.d0 - f0_rel ( sproc_rel , igamma , ipparbar )) else write ( unit_spec , * ) gamma_rel ( sproc_rel , igamma , ipparbar ), pparbar_rel ( sproc_rel , igamma , ipparbar ),& real ( eval_fit ( is , igamma , ppar_comp )),& abs ( real ( eval_fit ( is , igamma , ppar_comp )) - f0_rel ( sproc_rel , igamma , ipparbar )) / f0_rel ( sproc_rel , igamma , ipparbar ) integrate = integrate + & gamma_rel ( is_rel , igamma , ipparbar ) * real ( eval_fit ( is , igamma , ppar_comp )) * & 2.d0 * pi * dgamma * dpparbar * ( ms ( is ) / vA ) ** 3 endif enddo enddo else ! non-relativistic: dpperp = pp ( is , 2 , 2 , 1 ) - pp ( is , 1 , 2 , 1 ) dppar = pp ( is , 2 , 2 , 2 ) - pp ( is , 2 , 1 , 2 ) do iperp = 0 , nperp do ipar = 0 , npar ppar_comp = pp ( is , iperp , ipar , 2 ) write ( unit_spec , * ) pp ( is , iperp , ipar , 1 ), pp ( is , iperp , ipar , 2 ), real ( eval_fit ( is , iperp , ppar_comp )), & abs ( real ( eval_fit ( is , iperp , ppar_comp )) - f0 ( is , iperp , ipar )) / f0 ( is , iperp , ipar ) integrate = integrate + pp ( is , iperp , ipar , 1 ) * real ( eval_fit ( is , iperp , ppar_comp )) * & 2.d0 * pi * dpperp * dppar enddo enddo endif close ( unit_spec ) write ( * , '(a,i3,a, 2es14.4)' ) ' Integration of fit/analytical function for species' , is , ':' , integrate endif enddo end subroutine subroutine determine_JT ( is , n_params , nJT , JT , params , iperp , upper_limit , ipparbar_lower ) !! This subroutine calculates the transposed Jacobian matrix of the fit function with respect to the !! fit parameter array. use alps_var , only : fit_type , n_fits , pp , ms , vA , perp_correction use alps_var , only : gamma_rel , pparbar_rel , nspec , relativistic implicit none integer , intent ( in ) :: is !! Index of species for which [[determine_JT]] is executed. integer , intent ( in ) :: n_params !! Total number of fit parameters for a given species. integer , intent ( in ) :: nJT !! First dimension of matrix nJT [[JT(variable)]]. double precision , intent ( out ) :: JT ( nJT , 0 : upper_limit ) !! Transposed Jacobian matrix of the fit function. double precision , intent ( in ) :: params ( n_params ) !! Array of fit parameters. integer , intent ( in ) :: iperp !! Index of perpendicular momentum at which [[JT(variable)]] is evaluated. integer , intent ( in ) :: upper_limit !! Upper limit of iperp space (relativistic and non-relativistic). integer , intent ( in ) :: ipparbar_lower !! Lower index of parallel momentum (relativistic). integer :: ifit !! Index for the fits that add up to the total fit for a given species. integer :: par_ind !! Parameter index to loop over fits. integer :: ipar !! Index of parallel momentum. integer :: is_rel !! Index for relativistic species (if any). integer :: sproc_rel !! Local process index for relativistic calculation. integer :: is_run !! Index for relativistic species (if any). integer :: JT_ind !! Index running over [[JT]] double precision :: ppar_val !! Parallel momentum. double precision :: pperp_val !! Perpendicular momentum. double precision :: sqrtpart !! Square-root part of Juettner distribution. double precision :: expterm !! Exponential part of the Maxwellian distribution. double precision :: kappapart !! Kappa part of the kappa distribution. if ( relativistic ( is )) then ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo endif do ipar = 0 , upper_limit if ( relativistic ( is )) then pperp_val = gamma_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) ppar_val = pparbar_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) else pperp_val = pp ( is , iperp , ipar , 1 ) ppar_val = pp ( is , iperp , ipar , 2 ) endif par_ind = 0 JT_ind = 0 do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell expterm = exp ( - params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 & - perp_correction ( is , ifit ) * pperp_val ** 2 ) JT ( ifit + JT_ind + 0 , ipar ) = expterm JT ( ifit + JT_ind + 1 , ipar ) =- (( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) * params ( ifit + par_ind + 0 ) * expterm JT ( ifit + JT_ind + 2 , ipar ) = 2.d0 * params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) * & params ( ifit + par_ind + 0 ) * expterm par_ind = par_ind + 2 JT_ind = JT_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa kappapart = 1.d0 + params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 & + perp_correction ( is , ifit ) * params ( ifit + par_ind + 4 ) * pperp_val ** 2 JT ( ifit + JT_ind + 0 , ipar ) = kappapart ** params ( ifit + par_ind + 3 ) JT ( ifit + JT_ind + 1 , ipar ) = params ( ifit + par_ind + 0 ) * params ( ifit + par_ind + 3 ) * kappapart ** ( params ( ifit + par_ind + 3 ) - 1.d0 ) * & ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 JT ( ifit + JT_ind + 2 , ipar ) = params ( ifit + par_ind + 0 ) * params ( ifit + par_ind + 3 ) * kappapart ** ( params ( ifit + par_ind + 3 ) - 1.d0 ) * & 2.d0 * params ( ifit + par_ind + 1 ) * ( params ( ifit + par_ind + 2 ) - ppar_val ) JT ( ifit + JT_ind + 3 , ipar ) = log ( kappapart ) * params ( ifit + par_ind + 0 ) * kappapart ** params ( ifit + par_ind + 3 ) if ( iperp . EQ . 0 ) then JT_ind = JT_ind + 3 else JT ( ifit + JT_ind + 4 , ipar ) = params ( ifit + par_ind + 0 ) * params ( ifit + par_ind + 3 ) * & kappapart ** ( params ( ifit + par_ind + 3 ) - 1.d0 ) * perp_correction ( is , ifit ) * pperp_val ** 2 JT_ind = JT_ind + 4 endif par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner with pperp and ppar sqrtpart = sqrt ( 1.d0 + ( pperp_val ** 2 + ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) * vA * vA / ( ms ( is ) * ms ( is ))) JT ( ifit + JT_ind + 0 , ipar ) = exp ( - params ( ifit + par_ind + 1 ) * sqrtpart ) JT ( ifit + JT_ind + 1 , ipar ) =- params ( ifit + par_ind + 0 ) * exp ( - params ( ifit + par_ind + 1 ) * sqrtpart ) * sqrtpart JT ( ifit + JT_ind + 2 , ipar ) = params ( ifit + par_ind + 0 ) * exp ( - params ( ifit + par_ind + 1 ) * sqrtpart ) * & ( params ( ifit + par_ind + 1 ) / sqrtpart ) * ( ppar_val - params ( ifit + par_ind + 2 )) * vA * vA / ( ms ( is ) * ms ( is )) par_ind = par_ind + 2 JT_ind = JT_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner with gamma and pparbar, constant in pparbar JT ( ifit + JT_ind + 0 , ipar ) = exp ( - perp_correction ( is , ifit ) * pperp_val ) par_ind = par_ind + 0 JT_ind = JT_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner with gamma and pparbar with pparbar-dependence expterm = exp ( - params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) * & exp ( - perp_correction ( is , ifit ) * pperp_val ) JT ( ifit + JT_ind + 0 , ipar ) = expterm JT ( ifit + JT_ind + 1 , ipar ) =- params ( ifit + par_ind + 0 ) * expterm * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 JT ( ifit + JT_ind + 2 , ipar ) = 2.d0 * params ( ifit + par_ind + 0 ) * ( ppar_val - params ( ifit + par_ind + 2 )) * & params ( ifit + par_ind + 1 ) * expterm par_ind = par_ind + 2 JT_ind = JT_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! bi-Moyal expterm = exp ( 0.5d0 * ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 - & exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) )) JT ( ifit + JT_ind + 0 , ipar ) = expterm JT ( ifit + JT_ind + 1 , ipar ) = params ( ifit + par_ind + 0 ) * expterm * 0.5d0 * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 * & ( 1.d0 - exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) ) JT ( ifit + JT_ind + 2 , ipar ) = params ( ifit + par_ind + 0 ) * expterm * params ( ifit + par_ind + 1 ) * & ( params ( ifit + par_ind + 2 ) - ppar_val ) * & ( 1.d0 - exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) ) if ( iperp . EQ . 0 ) then JT_ind = JT_ind + 2 else JT ( ifit + JT_ind + 3 , ipar ) = params ( ifit + par_ind + 0 ) * expterm * 0.5d0 * perp_correction ( is , ifit ) * pperp_val ** 2 * & ( 1.d0 - exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) ) JT_ind = JT_ind + 3 endif par_ind = par_ind + 3 endif enddo enddo end subroutine subroutine LM_nonlinear_fit ( is , g , n_params , nJT , params , param_mask , iperp , npar , ipparbar_lower , quality ) !! This subroutine processes the nonlinear Levenberg-Marquart algorithm and returns !! the one-dimensional array [[params]] at a given iperp. !! The variable [[quality]] is the sum of the squares of all residuals. use alps_var , only : lambda_initial_fit , pp , lambdafac_fit , logfit use alps_var , only : epsilon_fit , maxsteps_fit use alps_var , only : gamma_rel , pparbar_rel , relativistic , nspec use alps_io , only : alps_error use mpi implicit none integer , intent ( in ) :: is !! Index of species for which [[LM_nonlinear_fit]] is executed. double precision , intent ( in ) :: g ( 0 : npar ) !! Array of function to be fitted. integer , intent ( in ) :: n_params !! Total number of fit parameters for a given species. integer , intent ( in ) :: nJT !! First dimension of matrix nJT [[determine_JT(subroutine):JT(variable)]]. double precision , intent ( inout ) :: params ( n_params ) !! Array of fit parameters. logical , intent ( in ) :: param_mask ( n_params ) !! Bit mask for required fit parameters. integer , intent ( in ) :: iperp !! Index of perpendicular momentum. integer , intent ( in ) :: npar !! Number of steps in parallel momentum integer , intent ( in ) :: ipparbar_lower !! Lower index of parallel momentum (relativistic). double precision , intent ( out ) :: quality !! Quality of the individual fit result. logical :: converged !! Check whether fit has converged. integer :: ipar !! Index running over parallel momentum. integer :: k !! Index running over entries of [[JT]]. integer :: counter !! Count of fit iterations. integer :: is_rel !! Index for relativistic species (if any). integer :: is_run !! Index for relativistic species (if any). integer :: sproc_rel !! Local process index for relativistic calculation. integer :: l !! Index running over the delta's in the L-M fit. integer :: ipiv ( nJT ) !! Integer array required for matrix inversion. integer :: info !! Integer required for matrix inversion. double precision :: LSQ !! Least squares for L-M fit. double precision :: LSQnew !! Next iteration of least squares for L-M fit. double precision :: lambda_fit !! Lambda in L-M fit. double precision :: pperp_val !! Perpendicular momentum. double precision :: ppar_val !! Parallel momentum. double precision :: residuals ( 0 : npar ) !! Array of residuals. double precision :: deltaparam_fit ( nJT ) !! delta's in the L-M fit. double precision :: JTJ ( nJT , nJT ) !! Matrix product of JT and J. double precision :: JT ( nJT , 0 : npar ) !! Transposed Jacobian matrix of the fit function. double precision :: diagmat ( nJT , nJT ) !! Diagonal matrix of JT. double precision :: Amat ( nJT , nJT ) !! Matrix to be inverted. double precision :: work_array ( nJT ) !! Work array for matrix inversion. converged = . FALSE . counter = 0 lambda_fit = lambda_initial_fit if (( 1 + npar ). LT . n_params ) call alps_error ( 2 ) if ( relativistic ( is )) then ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo endif do while (. NOT . converged ) counter = counter + 1 LSQ = 0.d0 ! Determine the transposed Jacobian and the residuals: call determine_JT ( is , n_params , nJT , JT , params , iperp , npar , ipparbar_lower ) do ipar = 0 , npar if ( relativistic ( is )) then pperp_val = gamma_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) ppar_val = pparbar_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) else pperp_val = pp ( is , iperp , ipar , 1 ) ppar_val = pp ( is , iperp , ipar , 2 ) endif if ( logfit ( is )) then do k = 1 , nJT JT ( k , ipar ) = JT ( k , ipar ) / fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 ))) enddo residuals ( ipar ) = g ( ipar ) - log ( real ( fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 ))))) else residuals ( ipar ) = g ( ipar ) - real ( fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 )))) endif ! Least squares: LSQ = LSQ + residuals ( ipar ) * residuals ( ipar ) enddo JTJ = matmul ( JT , transpose ( JT )) diagmat = 0.d0 do k = 1 , nJT diagmat ( k , k ) = JTJ ( k , k ) enddo Amat = JTJ + lambda_fit * diagmat ! The following routine is from LAPACK to invert the matrix: call dgetrf ( nJT , nJT , Amat , nJT , ipiv , info ) if ( info . NE . 0 ) stop \"Fit matrix is numerically singular.\" call dgetri ( nJT , Amat , nJT , ipiv , work_array , nJT , info ) if ( info . NE . 0 ) stop \"Fit matrix inversion failed.\" ! Now Amat is the inverse of JTJ+lambda_fit*diagmat deltaparam_fit = matmul ( Amat , matmul ( JT , residuals )) l = 0 do k = 1 , n_params if ( param_mask ( k )) then l = l + 1 params ( k ) = params ( k ) + deltaparam_fit ( l ) endif enddo ! With the new param_fit, what is the new mean square error: LSQnew = 0.d0 do ipar = 0 , npar if ( relativistic ( is )) then pperp_val = gamma_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) ppar_val = pparbar_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) else pperp_val = pp ( is , iperp , ipar , 1 ) ppar_val = pp ( is , iperp , ipar , 2 ) endif if ( logfit ( is )) then residuals ( ipar ) = g ( ipar ) - log ( real ( fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 ))))) else residuals ( ipar ) = g ( ipar ) - real ( fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 )))) endif ! Least squares: LSQnew = LSQnew + residuals ( ipar ) * residuals ( ipar ) enddo if ( LSQnew . GT . LSQ ) then l = 0 do k = 1 , n_params if ( param_mask ( k )) then l = l + 1 params ( k ) = params ( k ) - deltaparam_fit ( l ) endif enddo lambda_fit = lambda_fit * lambdafac_fit else lambda_fit = lambda_fit / lambdafac_fit endif ! Check if it converged (we can add further break criteria): if ( abs ( LSQnew - LSQ ). LT . epsilon_fit ) converged = . TRUE . if ( counter . EQ . maxsteps_fit ) converged = . TRUE . enddo quality = LSQ end subroutine end module alps_analyt","tags":"","loc":"sourcefile/alps_analyt.f90.html"},{"title":"ALPS_fns.f90 – ALPS","text":"Contents Modules alps_fns Source Code ALPS_fns.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_fns implicit none private :: int_T , int_T_res , integrate private :: integrate_res , landau_integrate , resU public :: derivative_f0 , disp , determine_bessel_array public :: determine_nmax , split_processes , secant , map_search public :: om_scan , om_double_scan contains !-=-=-=-=- !Calculate parallel and perpendicular derivative !of background velocity distribution functions !-=-=-=-=- subroutine derivative_f0 use alps_var , only : f0 , pp , df0 , nperp , npar , nspec , arrayName use alps_var , only : f0_rel , gamma_rel , pparbar_rel , nspec_rel , df0_rel , ngamma , npparbar use alps_var , only : writeOut , pi , relativistic , usebM use alps_io , only : get_unused_unit use alps_fns_rel , only : derivative_f0_rel implicit none !Local integer :: iperp , ipar , is , is_rel logical :: OutDF !T-> output df0/dv to file logical :: any_relativistic character ( 50 ) :: fmt !Output format character ( 100 ) :: writename double precision :: integrate , dpperp , dppar integer :: unit_f if ( writeOut ) then write ( * , '(a)' )& '-=-=-=-=-=-=-=-=-' write ( * , '(a)' )& 'Calculating df0/dpperp, df0/ppar if necessary...' endif do is = 1 , nspec if ( usebM ( is )) then write ( * , '(a,i2)' ) ' Bi-Maxwellian calcuation: no derivatives necessary for species ' , is df0 ( is ,:,:,:) = 0.d0 else do iperp = 1 , nperp - 1 do ipar = 1 , npar - 1 !index 1-> vperp derivative df0 ( is , iperp , ipar , 1 ) = & ( f0 ( is , iperp + 1 , ipar ) - f0 ( is , iperp - 1 , ipar )) / & ( pp ( is , iperp + 1 , ipar , 1 ) - pp ( is , iperp - 1 , ipar , 1 )) !index 2-> vpar derivative df0 ( is , iperp , ipar , 2 ) = & ( f0 ( is , iperp , ipar + 1 ) - f0 ( is , iperp , ipar - 1 )) / & ( pp ( is , iperp , ipar + 1 , 2 ) - pp ( is , iperp , ipar - 1 , 2 )) enddo enddo endif enddo write ( * , * ) 'Derivatives calculated' !Output df/dv to file OutDF = . false . if ( OutDF ) then if ( writeOut ) & write ( * , '(a)' ) 'Outputing df0/dpperp, df0/dppar' write ( fmt , '(a)' ) '(2es14.4,2es14.4)' do is = 1 , nspec if (. not . usebM ( is )) then dpperp = pp ( is , 2 , 2 , 1 ) - pp ( is , 1 , 2 , 1 ) dppar = abs ( pp ( is , 2 , 2 , 2 ) - pp ( is , 2 , 1 , 2 )) write ( writeName , '(3a,i0,a)' )& 'distribution/' , trim ( arrayName ), '_dfdv.' , is , '.array' call get_unused_unit ( unit_f ) open ( unit = unit_f , file = trim ( writeName ), status = 'replace' ) do iperp = 1 , nperp - 1 do ipar = 1 , npar - 1 write ( unit_f , fmt ) pp ( is , iperp , ipar , 1 ), pp ( is , iperp , ipar , 2 ),& df0 ( is , iperp , ipar , 1 ), df0 ( is , iperp , ipar , 2 ) enddo write ( unit_f , * ) enddo close ( unit_f ) endif enddo endif !End output do is = 1 , nspec integrate = 0.d0 dpperp = pp ( is , 2 , 2 , 1 ) - pp ( is , 1 , 2 , 1 ) dppar = abs ( pp ( is , 2 , 2 , 2 ) - pp ( is , 2 , 1 , 2 )) do iperp = 0 , nperp do ipar = 0 , npar integrate = integrate + & pp ( is , iperp , ipar , 1 ) * f0 ( is , iperp , ipar ) * & 2.d0 * pi * dpperp * dppar enddo enddo write ( * , '(a,i3,a, 2es14.4)' ) 'Integration of species' , is , ':' , integrate enddo if ( writeOut ) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' if ( writeOut ) write ( * , '(a)' ) 'Determine if relativistic calculation necessary' any_relativistic = . FALSE . is_rel = 0 do is = 1 , nspec if ( relativistic ( is )) then any_relativistic = . TRUE . is_rel = is_rel + 1 write ( * , '(a,i3,a,i3)' ) 'Species' , is , ' requires relativistic calculation. is_rel=' , is_rel endif enddo if ( any_relativistic ) then if ( writeOut ) write ( * , '(a,i4)' ) \"ngamma   = \" , ngamma if ( writeOut ) write ( * , '(a,i4)' ) \"npparbar = \" , npparbar nspec_rel = is_rel ! Allocate the relativistic fields (only on proc0 for now): allocate ( gamma_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) allocate ( pparbar_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) allocate ( f0_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) allocate ( df0_rel ( nspec_rel , 0 : ngamma , 0 : npparbar , 2 )) is_rel = 0 do is = 1 , nspec if ( relativistic ( is )) then is_rel = is_rel + 1 call derivative_f0_rel ( is , is_rel ) endif enddo else nspec_rel = 0 write ( * , '(a)' ) 'No relativistic calculation necessary.' if ( writeOut ) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' endif end subroutine derivative_f0 !-=-=-=-=-=-= ! !-=-=-=-=-=-= double complex function disp ( om ) use alps_var , only : nlim , proc0 , nspec , ierror , sproc , relativistic use alps_var , only : wave , kperp , kpar , ns , qs , vA , chi0 , usebM use alps_nhds , only : calc_chi use alps_fns_rel , only : int_ee_rel use mpi implicit none !Passed double complex :: om !frequency for dispersion solution !Local double complex :: chi_NHDS ( 3 , 3 ) double complex , dimension ( 1 : nspec , 1 : 3 , 1 : 3 ) :: schi , chi double complex , dimension ( 1 : 3 , 1 : 3 ) :: eps double complex :: enx2 , enz2 , enxnz !Indices of refraction integer :: is , nn !Indices for species, bessel n double complex , dimension ( 1 : nspec ) :: norm !normalization for tensors logical :: found_res_plus , found_res_minus chi = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) if ( proc0 ) chi0 = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) schi = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) if ( proc0 ) then !-=-=-=-=-=- !proc0 doesn't concern itself with the task !of integration, or the calculation of chi_ns !-=-=-=-=-=- !Indices of refraction for the dispersion relation ! old NHDS normalization !enx2=((kperp/(om))**2) !enz2=((kpar/(om))**2) !enxnz=(kperp*kpar/(om**2)) !new NHDS normalization enx2 = kperp ** 2 enz2 = kpar ** 2 enxnz = kperp * kpar !PLUME normalization !enx2=((kperp/(om*vA))**2) !enz2=((kpar/(om*vA))**2) !enxnz=(kperp*kpar/(om*vA)**2) else !integrate !c.f. Stix Equation 10.48; pg 255 !Calculate only for assigned species sproc !-=-=-=-=-=- !The processor runs over the n indicies defined by split_processes !-=-=-=-=-= ! Split into NHDS or ALPS routines: ! Only run the NHDS routine if useBM is on for the species !   and if you are handling n=0 according to split_processes if ( usebM ( sproc ). and .( nlim ( 2 ). GE . 0 ). and .( nlim ( 1 ). EQ . 0 )) then ! This is the case to use NHDS for the calculation of chi: call calc_chi ( chi_NHDS , sproc , kpar , kperp , om ) ! Account for norm below, which is already included in NHDS: schi ( sproc , 1 , 1 ) = chi_NHDS ( 1 , 1 ) / ( ns ( sproc ) * qs ( sproc )) schi ( sproc , 2 , 2 ) = chi_NHDS ( 2 , 2 ) / ( ns ( sproc ) * qs ( sproc )) schi ( sproc , 3 , 3 ) = chi_NHDS ( 3 , 3 ) / ( ns ( sproc ) * qs ( sproc )) schi ( sproc , 1 , 2 ) = chi_NHDS ( 1 , 2 ) / ( ns ( sproc ) * qs ( sproc )) schi ( sproc , 1 , 3 ) = chi_NHDS ( 1 , 3 ) / ( ns ( sproc ) * qs ( sproc )) schi ( sproc , 2 , 3 ) = chi_NHDS ( 2 , 3 ) / ( ns ( sproc ) * qs ( sproc )) else do nn = nlim ( 1 ), nlim ( 2 ) call determine_resonances ( om , nn , found_res_plus , found_res_minus ) !CHIij(nn) function calls if ( nn == 0 ) then !xx term is zero !xy term is zero !xz term is zero !yy term schi ( sproc , 2 , 2 ) = schi ( sproc , 2 , 2 ) + & full_integrate ( om , nn , 2 , found_res_plus ) !zz term schi ( sproc , 3 , 3 ) = schi ( sproc , 3 , 3 ) + & full_integrate ( om , nn , 3 , found_res_plus ) !yz term schi ( sproc , 2 , 3 ) = schi ( sproc , 2 , 3 ) + & full_integrate ( om , nn , 6 , found_res_plus ) !if (sproc==2) then !   write(*,'(i4,6es14.4)') nn,schi(sproc,2,2),schi(sproc,2,3),schi(sproc,3,3) !endif else !n != 0 loop !xx term schi ( sproc , 1 , 1 ) = schi ( sproc , 1 , 1 ) + & full_integrate ( om , nn , 1 , found_res_plus ) + & full_integrate ( om , - nn , 1 , found_res_minus ) !yy term schi ( sproc , 2 , 2 ) = schi ( sproc , 2 , 2 ) + & full_integrate ( om , nn , 2 , found_res_plus ) + & full_integrate ( om , - nn , 2 , found_res_minus ) !zz term schi ( sproc , 3 , 3 ) = schi ( sproc , 3 , 3 ) + & full_integrate ( om , nn , 3 , found_res_plus ) + & full_integrate ( om , - nn , 3 , found_res_minus ) !xy term schi ( sproc , 1 , 2 ) = schi ( sproc , 1 , 2 ) + & full_integrate ( om , nn , 4 , found_res_plus ) + & full_integrate ( om , - nn , 4 , found_res_minus ) !xz term schi ( sproc , 1 , 3 ) = schi ( sproc , 1 , 3 ) + & full_integrate ( om , nn , 5 , found_res_plus ) + & full_integrate ( om , - nn , 5 , found_res_minus ) !yz term schi ( sproc , 2 , 3 ) = schi ( sproc , 2 , 3 ) + & full_integrate ( om , nn , 6 , found_res_plus ) + & full_integrate ( om , - nn , 6 , found_res_minus ) !End n != 0 loop endif !if (sproc==2) then !   write(*,'(i4,12es14.4)') nn,schi(sproc,1,1),schi(sproc,2,2),schi(sproc,3,3),& !        schi(sproc,1,2),schi(sproc,1,3),schi(sproc,2,3) !endif enddo !End n index loop !-=-=-=-=-=- !add in non-T zz term !(if processor is responsible for the n=0 term) !EDIT: Add in ee term !-=-=-=-=-=- if ( nlim ( 1 ) == 0 ) then if ( relativistic ( sproc )) then schi ( sproc , 3 , 3 ) = schi ( sproc , 3 , 3 ) + int_ee_rel ( om ) else schi ( sproc , 3 , 3 ) = schi ( sproc , 3 , 3 ) + int_ee ( om ) endif endif !-=-=-=-=-=- endif ! NOTE ON NORMALISATION: ! NOW WE ARE WORKING WITH A NEW NORMALISATION: ! WE HAVE ALREADY MULTIPLIED THE schi TERMS AND THE int_ee TERMS INTERNALLY ! BY om. The following norm factors account for this: ! old NHDS normalization !norm(sproc) = ns(sproc) * qs(sproc) / (om*om) !new NHDS normalization norm ( sproc ) = ns ( sproc ) * qs ( sproc ) !PLUME normalization !norm(sproc) = ns(sproc) * qs(sproc)/(om*om*vA**2) !-=-=-=-=-=- !Multiply chi_s by the desired normalization !-=-=-=-=-=- schi ( sproc , 1 , 1 ) = schi ( sproc , 1 , 1 ) * norm ( sproc ) schi ( sproc , 2 , 2 ) = schi ( sproc , 2 , 2 ) * norm ( sproc ) schi ( sproc , 3 , 3 ) = schi ( sproc , 3 , 3 ) * norm ( sproc ) schi ( sproc , 1 , 2 ) = schi ( sproc , 1 , 2 ) * norm ( sproc ) schi ( sproc , 1 , 3 ) = schi ( sproc , 1 , 3 ) * norm ( sproc ) schi ( sproc , 2 , 3 ) = schi ( sproc , 2 , 3 ) * norm ( sproc ) !-=-=-=-=-=- endif ! Return the schi to proc0 call MPI_REDUCE ( schi , chi , size ( chi ),& MPI_DOUBLE_COMPLEX , MPI_SUM , 0 , MPI_COMM_WORLD , ierror ) if ( proc0 ) then !Calculate eps !eps  = (1 0 0)         ( chi_xx  chi_xy  chi_xz ) !       (0 1 0) + SUM_s ( chi_yx  chi_yy  chi_yz ) !       (0 0 1)         ( chi_zx  chi_zy  chi_zz )|s !The global variable 'chi0' is used !for heating & eigenfunction calculation !old NHDS normalization !chi0=chi/(vA*vA) !new NHDS normalization chi0 = chi / ( om * om * vA * vA ) !PLUME normalization !chi0=chi chi0 (:, 2 , 1 ) =- chi0 (:, 1 , 2 ) chi0 (:, 3 , 1 ) =- chi0 (:, 1 , 3 ) chi0 (:, 3 , 2 ) =- chi0 (:, 2 , 3 ) wave = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) eps = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) !Sum over species! do is = 1 , nspec eps ( 1 , 1 ) = eps ( 1 , 1 ) + chi ( is , 1 , 1 ) eps ( 2 , 2 ) = eps ( 2 , 2 ) + chi ( is , 2 , 2 ) eps ( 3 , 3 ) = eps ( 3 , 3 ) + chi ( is , 3 , 3 ) eps ( 1 , 2 ) = eps ( 1 , 2 ) + chi ( is , 1 , 2 ) eps ( 1 , 3 ) = eps ( 1 , 3 ) + chi ( is , 1 , 3 ) eps ( 2 , 3 ) = eps ( 2 , 3 ) + chi ( is , 2 , 3 ) enddo !-=-=-=-=-=- !The susceptibility tensor has !    a nice symmetry !-=-=-=-=-=- eps ( 2 , 1 ) = - eps ( 1 , 2 ) eps ( 3 , 1 ) = eps ( 1 , 3 ) eps ( 3 , 2 ) = - eps ( 2 , 3 ) !-=-=-=-=-=- !-=-=-=-=-=-=-=-=-= !Add the unit tensor- !-=-=-=-=-=-=-=-=-= !NHDS normalization !eps(1,1) = eps(1,1) + vA**2 !eps(2,2) = eps(2,2) + vA**2 !eps(3,3) = eps(3,3) + vA**2 !NHDS normalization multiplied with om**2 eps ( 1 , 1 ) = eps ( 1 , 1 ) + ( om * vA ) ** 2 eps ( 2 , 2 ) = eps ( 2 , 2 ) + ( om * vA ) ** 2 eps ( 3 , 3 ) = eps ( 3 , 3 ) + ( om * vA ) ** 2 !PLUME normalization !eps(1,1) = eps(1,1) + 1.d0 !eps(2,2) = eps(2,2) + 1.d0 !eps(3,3) = eps(3,3) + 1.d0 !-=-=-=-=-=-=-=-=-= !Calculate wave !wave = ( eps_xx - nz&#94;2  eps_xy              eps_xz + nxnz ) !       ( eps_yx         eps_yy -nz&#94;2 -nx&#94;2  eps_yz        ) !       ( eps_zx + nxnz  eps_zy              eps_zz - nx&#94;2 ) wave ( 1 , 1 ) = eps ( 1 , 1 ) - enz2 wave ( 2 , 2 ) = eps ( 2 , 2 ) - enz2 - enx2 wave ( 3 , 3 ) = eps ( 3 , 3 ) - enx2 wave ( 1 , 3 ) = eps ( 1 , 3 ) + enxnz wave ( 1 , 2 ) = eps ( 1 , 2 ) wave ( 2 , 3 ) = eps ( 2 , 3 ) !-=-=-=-=-=- !The wave tensor has !    a nice symmetry !-=-=-=-=-=- wave ( 2 , 1 ) = - wave ( 1 , 2 ) wave ( 3 , 1 ) = wave ( 1 , 3 ) wave ( 3 , 2 ) = - wave ( 2 , 3 ) !-=-=-=-=-=- !Calculate D(k,omega) !The below relies on the symmetries of the T_n tensor: !Again, c.f. Stix Equation 10.48; pg 255 !--------------------------------------------------------------------- disp = wave ( 1 , 1 ) * ( wave ( 2 , 2 ) * wave ( 3 , 3 ) + wave ( 2 , 3 ) ** 2 ) + & 2.d0 * wave ( 1 , 2 ) * wave ( 2 , 3 ) * wave ( 1 , 3 ) - wave ( 1 , 3 ) ** 2 * wave ( 2 , 2 ) + & wave ( 1 , 2 ) ** 2 * wave ( 3 , 3 ) !--------------------------------------------------------------------- !write(*,'(a,2es14.4)')'disp: ',disp endif call mpi_bcast ( disp , 1 , MPI_DOUBLE_COMPLEX , 0 , MPI_COMM_WORLD , ierror ) !Make sure all processors have completed calculation to !cross contamination with map and root searches call mpi_barrier ( mpi_comm_world , ierror ) return end function disp !-=-=-=-=-=-= ! Determine if there are resonances !-=-=-=-=-=-= subroutine determine_resonances ( om , nn , found_res_plus , found_res_minus ) use alps_var , only : npar , pp , vA , ms , qs , sproc , kpar , nperp use alps_var , only : positions_principal , relativistic use alps_io , only : alps_error implicit none integer :: nn , ipar , iperp logical :: found_res_plus , found_res_minus double precision :: dppar , gamma double complex :: p_res , om dppar = pp ( sproc , 2 , 2 , 2 ) - pp ( sproc , 2 , 1 , 2 ) found_res_plus = . FALSE . found_res_minus = . FALSE . if ( relativistic ( sproc )) then !call determine_sproc_rel(sproc_rel) !do igamma=0,ngamma ! Note that this is pparbar in reality, but it does not make a difference for this section: ! positive n: !p_res = gamma_rel(sproc_rel,igamma,1)*om*vA/kpar - (1.d0*nn)*qs(sproc)*vA/(kpar*ms(sproc)) !if ((real(p_res)**2).LE.(gamma_rel(sproc_rel,igamma,1)**2-1.d0)) found_res_plus = .TRUE. ! negative n: !p_res = gamma_rel(sproc_rel,igamma,1)*om*vA/kpar + (1.d0*nn)*qs(sproc)*vA/(kpar*ms(sproc)) !if ((real(p_res)**2).LE.(gamma_rel(sproc_rel,igamma,1)**2-1.d0)) found_res_minus = .TRUE. !\tenddo ! The following checks for resonances in (pperp,ppar)-space rather than in (Gamma,pparbar)-space: do iperp = 0 , nperp do ipar = 0 , npar - 1 gamma = sqrt (( pp ( sproc , iperp , ipar , 1 ) ** 2 + & pp ( sproc , iperp , ipar , 2 ) ** 2 ) * vA ** 2 / ms ( sproc ) ** 2 + 1.d0 ) ! positive n: p_res = ( gamma * ms ( sproc ) * om - 1.d0 * nn * qs ( sproc )) / kpar if (( pp ( sproc , 2 , ipar , 2 ). LE . real ( p_res )). and .& ( pp ( sproc , 2 , ipar + 1 , 2 ). GT . real ( p_res ))) found_res_plus = . TRUE . ! negative n: p_res = ( gamma * ms ( sproc ) * om + 1.d0 * nn * qs ( sproc )) / kpar if (( pp ( sproc , 2 , ipar , 2 ). LE . real ( p_res )). and .& ( pp ( sproc , 2 , ipar + 1 , 2 ). GT . real ( p_res ))) found_res_minus = . TRUE . enddo enddo else ! non-relativistic case: ! positive n ipar = 0 p_res = ( ms ( sproc ) * om - 1.d0 * nn * qs ( sproc )) / kpar do while (( ipar . LE .( npar - 2 )). AND .(. NOT . found_res_plus )) ipar = ipar + 1 if (( pp ( sproc , 2 , ipar , 2 ). LE . real ( p_res )). and .& ( pp ( sproc , 2 , ipar + 1 , 2 ). GT . real ( p_res ))) found_res_plus = . TRUE . enddo ! negative n: ipar = 0 p_res = ( ms ( sproc ) * om + 1.d0 * nn * qs ( sproc )) / kpar do while (( ipar . LE .( npar - 2 )). AND .(. NOT . found_res_minus )) ipar = ipar + 1 if (( pp ( sproc , 2 , ipar , 2 ). LE . real ( p_res )). and .& ( pp ( sproc , 2 , ipar + 1 , 2 ). GT . real ( p_res ))) found_res_minus = . TRUE . enddo ! Check if there is a resonance right outside the integration domain: p_res = ( ms ( sproc ) * om - 1.d0 * nn * qs ( sproc )) / kpar if (( real ( p_res ). LT . pp ( sproc , 2 , 1 , 2 )). AND .& ( real ( p_res ). GE .( pp ( sproc , 2 , 1 , 2 ) - ( 1.d0 * positions_principal ) * dppar ))) found_res_plus = . TRUE . if (( real ( p_res ). GE . pp ( sproc , 2 , npar - 1 , 2 )). AND .& ( real ( p_res ). LT .( pp ( sproc , 2 , npar - 1 , 2 ) + ( 1.d0 * positions_principal ) * dppar ))) found_res_plus = . TRUE . p_res = ( ms ( sproc ) * om + 1.d0 * nn * qs ( sproc )) / kpar if (( real ( p_res ). LT . pp ( sproc , 2 , 1 , 2 )). AND .& ( real ( p_res ). GE .( pp ( sproc , 2 , 1 , 2 ) - ( 1.d0 * positions_principal ) * dppar ))) found_res_minus = . TRUE . if (( real ( p_res ). GE . pp ( sproc , 2 , npar - 1 , 2 )). AND .& ( real ( p_res ). LT .( pp ( sproc , 2 , npar - 1 , 2 ) + ( 1.d0 * positions_principal ) * dppar ))) found_res_minus = . TRUE . endif end subroutine determine_resonances !-=-=-=-=-=-= !THE INTEGRATOR !-=-=-=-=-=-= double complex function full_integrate ( om , nn , mode , found_res ) use alps_var , only : npar , relativistic , sproc use alps_fns_rel , only : integrate_res_rel , landau_integrate_rel implicit none !Passed double complex :: om !complex frequency integer :: nn !Bessel N integer :: mode !index in T tensor logical :: found_res !use brute force integral or landau & principal value full_integrate = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) if (. not . found_res ) then !Brute force integrate full_integrate = integrate ( om , nn , mode , 1 , npar - 1 ) elseif ( found_res . and . relativistic ( sproc )) then if ( aimag ( om ). GT . 0.d0 ) then full_integrate = integrate_res_rel ( om , nn , mode ) elseif ( aimag ( om ). LT . 0.d0 ) then full_integrate = integrate_res_rel ( om , nn , mode ) + 2.d0 * landau_integrate_rel ( om , nn , mode ) elseif ( aimag ( om ). EQ . 0.d0 ) then full_integrate = integrate_res_rel ( om , nn , mode ) + landau_integrate_rel ( om , nn , mode ) endif elseif (( found_res ). and .( aimag ( om ). GT . 0.d0 )) then !Brute force integrate full_integrate = integrate_res ( om , nn , mode ) elseif (( found_res ). and .( aimag ( om ). LT . 0.d0 )) then !Landau Integral full_integrate = integrate_res ( om , nn , mode ) + 2.d0 * landau_integrate ( om , nn , mode ) elseif (( found_res ). and .( aimag ( om ). EQ . 0.d0 )) then full_integrate = integrate_res ( om , nn , mode ) + landau_integrate ( om , nn , mode ) endif return end function full_integrate double complex function integrate ( om , nn , mode , iparmin , iparmax ) use alps_var , only : nperp , pp , pi , sproc implicit none !Passed double complex :: om !complex frequency integer :: nn !Bessel N integer :: mode !index in T tensor integer :: iparmin , iparmax !Local integer :: iperp , ipar !p_perp, p_par index double precision :: dpperp , dppar !delta p_perp, delta p_par !choose numerical integration method... integrate = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) dpperp = pp ( sproc , 2 , 2 , 1 ) - pp ( sproc , 1 , 2 , 1 ) dppar = abs ( pp ( sproc , 2 , 2 , 2 ) - pp ( sproc , 2 , 1 , 2 )) integrate = integrate + & 2.d0 * resU ( om , nn , 1 , iparmin ) * int_T ( nn , 1 , iparmin , mode ) + & 2.d0 * resU ( om , nn , 1 , iparmax ) * int_T ( nn , 1 , iparmax , mode ) + & resU ( om , nn , nperp - 1 , iparmin ) * int_T ( nn , nperp - 1 , iparmin , mode ) + & resU ( om , nn , nperp - 1 , iparmax ) * int_T ( nn , nperp - 1 , iparmax , mode ) do iperp = 2 , nperp - 2 do ipar = iparmin + 1 , iparmax - 1 integrate = integrate + 4.d0 * resU ( om , nn , iperp , ipar ) * int_T ( nn , iperp , ipar , mode ) enddo integrate = integrate + & 2.d0 * ( resU ( om , nn , iperp , iparmin ) * int_T ( nn , iperp , iparmin , mode ) + & resU ( om , nn , iperp , iparmax ) * int_T ( nn , iperp , iparmax , mode ) ) enddo do ipar = iparmin + 1 , iparmax - 1 integrate = integrate + & 2.d0 * ( 2.d0 * resU ( om , nn , 1 , ipar ) * int_T ( nn , 1 , ipar , mode ) + & resU ( om , nn , nperp - 1 , ipar ) * int_T ( nn , nperp - 1 , ipar , mode ) ) enddo integrate = 2.d0 * pi * integrate * dpperp * dppar * 0.25d0 return end function integrate ! This function does the integration around resonances if necessary: double complex function integrate_res ( om , nn , mode ) use alps_var , only : nperp , npar , pp , ms , qs , kpar , pi , sproc use alps_var , only : positions_principal , n_resonance_interval , Tlim implicit none integer :: ipar_res , ipar , iperp , ntiny integer :: lowerlimit , upperlimit , nn , mode double precision :: dpperp , dppar , capDelta , smdelta , denomR , denomI , ppar , correction double complex :: p_res , ii , om , integrate_norm , gprimetr logical :: found_res dpperp = pp ( sproc , 2 , 2 , 1 ) - pp ( sproc , 1 , 2 , 1 ) dppar = pp ( sproc , 2 , 2 , 2 ) - pp ( sproc , 2 , 1 , 2 ) integrate_res = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) integrate_norm = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) ! determine the position of the resonance (i.e., the step LEFT of it): ipar = 0 ipar_res = 0 found_res = . FALSE . p_res = ( ms ( sproc ) * om - 1.d0 * nn * qs ( sproc )) / kpar do while (( ipar . LT .( npar - 2 )). AND .(. NOT . found_res )) ipar = ipar + 1 if (( pp ( sproc , 2 , ipar + 1 , 2 ). GT . real ( p_res )). and .& ( pp ( sproc , 2 , ipar , 2 ). LE . real ( p_res ))) then ipar_res = ipar found_res = . TRUE . endif enddo ! Handle resonances that are right outside the integration domain: p_res = ( ms ( sproc ) * om - ( 1.d0 * nn ) * qs ( sproc )) / kpar do ipar = 0 , positions_principal if (( real ( p_res ). GE .( pp ( sproc , 2 , 0 , 2 ) - dppar * ipar )). AND .& ( real ( p_res ). LT .( pp ( sproc , 2 , 0 , 2 ) - dppar * ( ipar - 1 )))) ipar_res = - ipar if (( real ( p_res ). GE .( pp ( sproc , 2 , npar - 1 , 2 ) + dppar * ipar )). AND .& ( real ( p_res ). LT .( pp ( sproc , 2 , npar - 1 , 2 ) + dppar * ( ipar + 1 )))) ipar_res = npar - 1 + ipar enddo ! If the resonance is close to the edge, just do the normal integration: if (( ipar_res - positions_principal ). LE . 2 ) then integrate_res = integrate ( om , nn , mode , ipar_res + positions_principal , npar - 1 ) return endif if (( ipar_res + positions_principal ). GE .( npar - 2 )) then integrate_res = integrate ( om , nn , mode , 1 , ipar_res - positions_principal ) return endif ! positions_principal defines how close we can go to ipar_res with the \"normal\" integration. ! the following part is basically the normal function \"integrate\" on the left and on the right of ipar_res: ! left: lowerlimit = ipar_res - positions_principal integrate_norm = integrate ( om , nn , mode , 1 , lowerlimit ) ! right: if ( abs ( real ( p_res ) - pp ( sproc , 2 , ipar_res , 2 )). LT .( 0.5d0 * dppar )) then upperlimit = ipar_res + positions_principal + 1 else upperlimit = ipar_res + positions_principal + 2 endif integrate_norm = integrate_norm + integrate ( om , nn , mode , upperlimit , npar - 1 ) ! The following part includes the analytic switch described in the paper! ! Now comes the resonance part: ! We call the function that needs to be integrated WITHOUT the resonance part funct_g. ! We linearize this function. Now we can calculate the even part of the integration. ! We set Delta so that it starts at ipar_res-positions_principal. In that way, there is only ! a tiny rest left on the right side that needs to be integrated. ! split the range between the resonance and the upper limit into n_resonance_interval steps: ! the denominator is: ! (ppar - gamma * ms(sproc)*om/kpar + (1.d0*nn) * qs(sproc) /kpar ) ! we define ! denomR=real(gamma * ms(sproc)*om/kpar - (1.d0*nn) * qs(sproc) /kpar ) ! denomI=aimag(gamma * ms(sproc)*om/kpar) ! so that the denominator is ! (ppar-denomR-ii*denomI) denomR = real ( ms ( sproc ) * om / kpar - ( 1.d0 * nn ) * qs ( sproc ) / kpar ) denomI = aimag ( ms ( sproc ) * om / kpar ) capDelta = real ( p_res ) - pp ( sproc , 1 , ipar_res - positions_principal , 2 ) smdelta = capDelta / ( 1.d0 * n_resonance_interval ) if ( abs ( denomI ). GT . Tlim ) then ! regular integration: ! Integrate the boundaries: ppar = real ( p_res ) ! left end of integration interval ! At iperp=1, we are already missing the part from iperp=0, where we should actually start. Therefore, we use 4 instead of 2 in the trapezoid integration: integrate_res = integrate_res + 2.d0 * funct_g ( ppar , 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - 2.d0 * funct_g ( 2.d0 * denomR - ppar , 1 , om , nn , mode ) / ( ppar - denomR + ii * denomI ) integrate_res = integrate_res + funct_g ( ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - funct_g ( 2.d0 * denomR - ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR + ii * denomI ) ppar = capDelta + real ( p_res ) ! right end of integration interval integrate_res = integrate_res + 2.d0 * funct_g ( ppar , 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - 2.d0 * funct_g ( 2.d0 * denomR - ppar , 1 , om , nn , mode ) / ( ppar - denomR + ii * denomI ) integrate_res = integrate_res + funct_g ( ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - funct_g ( 2.d0 * denomR - ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR + ii * denomI ) ! end of edges. do iperp = 2 , nperp - 2 do ipar = 1 , n_resonance_interval - 1 ppar = real ( p_res ) + smdelta * ipar integrate_res = integrate_res + 4.d0 * funct_g ( ppar , iperp , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - 4.d0 * funct_g ( 2.d0 * denomR - ppar , iperp , om , nn , mode ) / ( ppar - denomR + ii * denomI ) enddo ppar = real ( p_res ) + smdelta ppar = real ( p_res ) integrate_res = integrate_res + 2.d0 * funct_g ( ppar , iperp , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - 2.d0 * funct_g ( 2.d0 * denomR - ppar , iperp , om , nn , mode ) / ( ppar - denomR + ii * denomI ) ppar = real ( p_res ) + capDelta integrate_res = integrate_res + 2.d0 * funct_g ( ppar , iperp , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - 2.d0 * funct_g ( 2.d0 * denomR - ppar , iperp , om , nn , mode ) / ( ppar - denomR + ii * denomI ) enddo do ipar = 1 , n_resonance_interval - 1 ppar = real ( p_res ) + smdelta * ipar ! At iperp=1, we are already missing the part from iperp=0, where we should actually start. Therefore, we use 4 instead of 2 in the trapezoid integration: integrate_res = integrate_res + 4.d0 * funct_g ( ppar , 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - 4.d0 * funct_g ( 2.d0 * denomR - ppar , 1 , om , nn , mode ) / ( ppar - denomR + ii * denomI ) integrate_res = integrate_res + 2.d0 * funct_g ( ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - 2.d0 * funct_g ( 2.d0 * denomR - ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR + ii * denomI ) enddo else ! analytic approximation ! Integrate the edges: ppar = real ( p_res ) ! left end of integration interval ! At iperp=1, we are already missing the part from iperp=0, where we should actually start. Therefore, we use 4 instead of 2 in the trapezoid integration: gprimetr = ( funct_g ( denomR + dppar , 1 , om , nn , mode ) - funct_g ( denomR - dppar , 1 , om , nn , mode )) / ( 2.d0 * dppar ) if ( denomI . NE . 0.d0 ) then integrate_res = integrate_res + 2.d0 * 2.d0 * gprimetr * ( ppar - denomR ) ** 2 / (( ppar - denomR ) ** 2 + denomI ** 2 ) else integrate_res = integrate_res + 2.d0 * 2.d0 * gprimetr endif gprimetr = ( funct_g ( denomR + dppar , nperp - 1 , om , nn , mode ) - funct_g ( denomR - dppar , nperp - 1 , om , nn , mode )) / ( 2.d0 * dppar ) if ( denomI . NE . 0.d0 ) then integrate_res = integrate_res + 2.d0 * gprimetr * ( ppar - denomR ) ** 2 / (( ppar - denomR ) ** 2 + denomI ** 2 ) else integrate_res = integrate_res + 2.d0 * gprimetr endif ppar = capDelta + real ( p_res ) ! right end of integration interval gprimetr = ( funct_g ( denomR + dppar , 1 , om , nn , mode ) - funct_g ( denomR - dppar , 1 , om , nn , mode )) / ( 2.d0 * dppar ) integrate_res = integrate_res + 2.d0 * 2.d0 * gprimetr * ( ppar - denomR ) ** 2 / (( ppar - denomR ) ** 2 + denomI ** 2 ) gprimetr = ( funct_g ( denomR + dppar , nperp - 1 , om , nn , mode ) - funct_g ( denomR - dppar , nperp - 1 , om , nn , mode )) / ( 2.d0 * dppar ) integrate_res = integrate_res + 2.d0 * gprimetr * ( ppar - denomR ) ** 2 / (( ppar - denomR ) ** 2 + denomI ** 2 ) ! The following lines account for Eq. (3.7) in the paper: if ( denomI . GT . 0.d0 ) then integrate_res = integrate_res + 2.d0 * 2.d0 * ii * pi * funct_g ( denomR , 1 , om , nn , mode ) / smdelta integrate_res = integrate_res + 2.d0 * ii * pi * funct_g ( denomR , nperp - 1 , om , nn , mode ) / smdelta else if ( denomI . LT . 0.d0 ) then integrate_res = integrate_res - 2.d0 * 2.d0 * ii * pi * funct_g ( denomR , 1 , om , nn , mode ) / smdelta integrate_res = integrate_res - 2.d0 * ii * pi * funct_g ( denomR , nperp - 1 , om , nn , mode ) / smdelta else if ( denomI . EQ . 0.d0 ) then integrate_res = integrate_res + 0.d0 endif ! end of edges. do iperp = 2 , nperp - 2 do ipar = 1 , n_resonance_interval - 1 ppar = real ( p_res ) + smdelta * ipar gprimetr = ( funct_g ( denomR + dppar , iperp , om , nn , mode ) - & funct_g ( denomR - dppar , iperp , om , nn , mode )) / ( 2.d0 * dppar ) integrate_res = integrate_res + 4.d0 * 2.d0 * gprimetr * ( ppar - denomR ) ** 2 / (( ppar - denomR ) ** 2 + denomI ** 2 ) enddo ppar = real ( p_res ) ! In this case, ppar is equal to denomR, so: no integration needed !\t\tgprimetr = (funct_g(denomR+dppar,iperp,om,nn,mode)-funct_g(denomR-dppar,iperp,om,nn,mode))/(2.d0*dppar) !\t\tif (denomI.NE.0.d0) then !\t\t\tintegrate_res = integrate_res + 2.d0 * 2.d0 * gprimetr * (ppar-denomR)**2 / ((ppar-denomR)**2+denomI**2) !\t\telse !\t\t\tintegrate_res = integrate_res + 2.d0 * 2.d0 * gprimetr !\t\tendif ppar = real ( p_res ) + capDelta gprimetr = ( funct_g ( denomR + dppar , iperp , om , nn , mode ) - funct_g ( denomR - dppar , iperp , om , nn , mode )) / ( 2.d0 * dppar ) integrate_res = integrate_res + 2.d0 * 2.d0 * gprimetr * ( ppar - denomR ) ** 2 / (( ppar - denomR ) ** 2 + denomI ** 2 ) ! The following lines account for Eq. (3.7) in the paper: if ( denomI . GT . 0.d0 ) then integrate_res = integrate_res + 4.d0 * ii * pi * funct_g ( denomR , iperp , om , nn , mode ) / smdelta else if ( denomI . LT . 0.d0 ) then integrate_res = integrate_res - 4.d0 * ii * pi * funct_g ( denomR , iperp , om , nn , mode ) / smdelta else if ( denomI . EQ . 0.d0 ) then integrate_res = integrate_res + 0.d0 endif enddo do ipar = 1 , n_resonance_interval - 1 ppar = real ( p_res ) + smdelta * ipar gprimetr = ( funct_g ( denomR + dppar , 1 , om , nn , mode ) - funct_g ( denomR - dppar , 1 , om , nn , mode )) / ( 2.d0 * dppar ) integrate_res = integrate_res + 4.d0 * 2.d0 * gprimetr * ( ppar - denomR ) ** 2 / (( ppar - denomR ) ** 2 + denomI ** 2 ) gprimetr = ( funct_g ( denomR + dppar , nperp - 1 , om , nn , mode ) - funct_g ( denomR - dppar , nperp - 1 , om , nn , mode )) / ( 2.d0 * dppar ) integrate_res = integrate_res + 2.d0 * 2.d0 * gprimetr * ( ppar - denomR ) ** 2 / (( ppar - denomR ) ** 2 + denomI ** 2 ) enddo endif ! There is a tiny rest left between the point real(p_res)+capDelta and the position ! pp(sproc,2,upperlimit,2). We split this interval into steps of roughly size smdelta: ntiny = int (( pp ( sproc , 2 , upperlimit , 2 ) - real ( p_res ) - capDelta ) / smdelta ) if ( ntiny . GT . 0 ) then ! Correct for the fact that smdelta is not exactly the step width in the tiny-rest integration: correction = (( pp ( sproc , 2 , upperlimit , 2 ) - real ( p_res ) - capDelta ) / ( 1.d0 * ntiny )) / smdelta ppar = real ( p_res ) + capDelta integrate_res = integrate_res + & 2.d0 * correction * ( funct_g ( ppar , 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI )) integrate_res = integrate_res + & correction * ( funct_g ( ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI )) ppar = real ( p_res ) + capDelta + correction * smdelta * ntiny ! this should be the same as pp(upperlimit) integrate_res = integrate_res + & 2.d0 * correction * ( funct_g ( ppar , 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI )) integrate_res = integrate_res + & correction * ( funct_g ( ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI )) do iperp = 2 , nperp - 2 do ipar = 1 , ntiny - 1 ppar = real ( p_res ) + capDelta + correction * smdelta * ipar integrate_res = integrate_res + 4.d0 * & correction * ( funct_g ( ppar , iperp , om , nn , mode ) / ( ppar - denomR - ii * denomI )) enddo ppar = real ( p_res ) + capDelta integrate_res = integrate_res + 2.d0 * & correction * ( funct_g ( ppar , iperp , om , nn , mode ) / ( ppar - denomR - ii * denomI )) ppar = real ( p_res ) + capDelta + correction * smdelta * ntiny integrate_res = integrate_res + 2.d0 * & correction * ( funct_g ( ppar , iperp , om , nn , mode ) / ( ppar - denomR - ii * denomI )) enddo do ipar = 1 , ntiny - 1 ppar = real ( p_res ) + capDelta + correction * smdelta * ipar integrate_res = integrate_res + 2.d0 * 2.d0 * & correction * ( funct_g ( ppar , 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI )) integrate_res = integrate_res + 2.d0 * & correction * ( funct_g ( ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI )) enddo endif integrate_res = 2.d0 * pi * integrate_res * smdelta * dpperp * 0.25d0 integrate_res = integrate_res + integrate_norm return end function integrate_res ! Linearized integrand WITHOUT the resonance part. ! It is - resU * int_T / kpar but without the denominator. ! It can be evaluated at any real value of pp (ppar_real) between the grid around the resonance. double complex function funct_g ( ppar_real , iperp , om , nn , mode ) use alps_var , only : npar , pp , ms , qs , kpar , df0 , sproc implicit none integer :: nn , mode , ipar , iperp , ipar_close double complex :: om , integrandplus , integrandminus , integrand double precision :: ppar_real , dppar dppar = abs ( pp ( sproc , 2 , 2 , 2 ) - pp ( sproc , 2 , 1 , 2 )) ipar_close = 0 ! determine the closest ipar (on the left) to this p_res_real: do ipar = 1 , npar - 1 if (( pp ( sproc , iperp , ipar + 1 , 2 ). GT . ppar_real ). AND .( pp ( sproc , iperp , ipar , 2 ). LE . ppar_real )) then ipar_close = ipar endif enddo if ( ipar_close . GE .( npar - 1 )) ipar_close = npar - 2 if ( ipar_close . LE . 1 ) ipar_close = 2 ! calculate the function on the grid (left and right of ppar_real): integrandplus =- qs ( sproc ) * & ( om * df0 ( sproc , iperp , ipar_close + 1 , 1 ) + ( kpar / ( ms ( sproc )) ) * & ( pp ( sproc , iperp , ipar_close + 1 , 1 ) * df0 ( sproc , iperp , ipar_close + 1 , 2 ) - & pp ( sproc , iperp , ipar_close + 1 , 2 ) * df0 ( sproc , iperp , ipar_close + 1 , 1 ) ) ) * & int_T ( nn , iperp , ipar_close + 1 , mode ) / kpar integrand =- qs ( sproc ) * & ( om * df0 ( sproc , iperp , ipar_close , 1 ) + ( kpar / ( ms ( sproc )) ) * & ( pp ( sproc , iperp , ipar_close , 1 ) * df0 ( sproc , iperp , ipar_close , 2 ) - & pp ( sproc , iperp , ipar_close , 2 ) * df0 ( sproc , iperp , ipar_close , 1 ) ) ) * & int_T ( nn , iperp , ipar_close , mode ) / kpar integrandminus =- qs ( sproc ) * & ( om * df0 ( sproc , iperp , ipar_close - 1 , 1 ) + ( kpar / ( ms ( sproc )) ) * & ( pp ( sproc , iperp , ipar_close - 1 , 1 ) * df0 ( sproc , iperp , ipar_close - 1 , 2 ) - & pp ( sproc , iperp , ipar_close - 1 , 2 ) * df0 ( sproc , iperp , ipar_close - 1 , 1 ) ) ) * & int_T ( nn , iperp , ipar_close - 1 , mode ) / kpar funct_g = integrand + & 0.5d0 * (( integrandplus - integrandminus ) / dppar ) * ( ppar_real - pp ( sproc , iperp , ipar_close , 2 )) return end function funct_g double complex function landau_integrate ( om , nn , mode ) use alps_var , only : nperp , pp , pi , ms , qs , kpar , sproc use alps_analyt , only : eval_fit implicit none !Passed double complex :: om !complex frequency integer :: nn !Bessel N integer :: mode !index in T tensor !Local integer :: iperp double precision :: dpperp , dppar double precision :: h !delta p_perp double complex :: ii double complex :: p_res , dfperp_C , dfpar_C ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) !choose numerical integration method... landau_integrate = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) dpperp = pp ( sproc , 2 , 2 , 1 ) - pp ( sproc , 1 , 2 , 1 ) dppar = abs ( pp ( sproc , 2 , 2 , 2 ) - pp ( sproc , 2 , 1 , 2 )) ! Landau contour integral: ! At iperp=1, we are already missing the part from iperp=0, where we should actually start. Therefore, we use 4 instead of 2 in the trapezoid integration: do iperp = 1 , nperp - 1 if (( iperp . EQ . 0 ). or .( iperp . EQ . ( nperp - 1 ))) then h = 0.5d0 else h = 1.d0 endif p_res = ( ms ( sproc ) * ( om ) - 1.d0 * nn * qs ( sproc )) / kpar ! Calculate the derivatives of f0 at the complex p_res: dfperp_C = ( eval_fit ( sproc , iperp + 1 , p_res ) - eval_fit ( sproc , iperp - 1 , p_res )) / ( 2.d0 * dpperp ) dfpar_C = ( eval_fit ( sproc , iperp , p_res + dppar ) - eval_fit ( sproc , iperp , p_res - dppar )) / ( 2.d0 * dppar ) landau_integrate = landau_integrate - h * int_T_res ( nn , iperp , p_res , mode ) * & ( qs ( sproc ) / abs ( kpar )) * ( ( pp ( sproc , iperp , 1 , 1 ) * dfpar_C - & p_res * dfperp_C ) * kpar / ( ms ( sproc )) + om * dfperp_C ) enddo landau_integrate = landau_integrate * ii * dpperp * pi * 2.d0 * pi return end function landau_integrate double complex function int_ee ( om ) use alps_var , only : qs , ms , nperp , npar , pp , pi , df0 , sproc implicit none !Passed double complex :: om !complex frequency !Local integer :: iperp , ipar !p_perp, p_par index double precision :: dpperp , dppar !delta p_perp, delta p_par !choose numerical integration method... int_ee = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) dpperp = pp ( sproc , 2 , 2 , 1 ) - pp ( sproc , 1 , 2 , 1 ) dppar = abs ( pp ( sproc , 2 , 2 , 2 ) - pp ( sproc , 2 , 1 , 2 )) ! At iperp=1, we are already missing the part from iperp=0, where we should actually start. Therefore, we use 4 instead of 2 in the trapezoid integration: int_ee = int_ee + & 2.d0 * pp ( sproc , 1 , 1 , 2 ) * & ( df0 ( sproc , 1 , 1 , 2 ) * pp ( sproc , 1 , 1 , 1 ) - & pp ( sproc , 1 , 1 , 1 ) * df0 ( sproc , 1 , 1 , 1 )) int_ee = int_ee + & 2.d0 * pp ( sproc , 1 , npar - 1 , 2 ) * & ( df0 ( sproc , 1 , npar - 1 , 2 ) * pp ( sproc , 1 , npar - 1 , 1 ) - & pp ( sproc , 1 , npar - 1 , 2 ) * df0 ( sproc , 1 , npar - 1 , 1 )) int_ee = int_ee + & pp ( sproc , nperp - 1 , 1 , 2 ) * & ( df0 ( sproc , nperp - 1 , 1 , 2 ) * pp ( sproc , nperp - 1 , 1 , 1 ) - & pp ( sproc , nperp - 1 , 1 , 2 ) * df0 ( sproc , nperp - 1 , 1 , 1 )) int_ee = int_ee + & pp ( sproc , nperp - 1 , npar - 1 , 2 ) * & ( df0 ( sproc , nperp - 1 , npar - 1 , 2 ) * pp ( sproc , nperp - 1 , npar - 1 , 1 ) - & pp ( sproc , nperp - 1 , npar - 1 , 2 ) * df0 ( sproc , nperp - 1 , npar - 1 , 1 )) do iperp = 2 , nperp - 2 do ipar = 2 , npar - 2 int_ee = int_ee + & 4.d0 * (& pp ( sproc , iperp , ipar , 2 ) * & ( df0 ( sproc , iperp , ipar , 2 ) * pp ( sproc , iperp , ipar , 1 ) - & pp ( sproc , iperp , ipar , 2 ) * df0 ( sproc , iperp , ipar , 1 )) ) enddo enddo do ipar = 2 , npar - 2 ! At iperp=1, we are already missing the part from iperp=0, where we should actually start. Therefore, we use 4 instead of 2 in the trapezoid integration: int_ee = int_ee + & 2.d0 * 2.d0 * (& pp ( sproc , 1 , ipar , 2 ) * & ( df0 ( sproc , 1 , ipar , 2 ) * pp ( sproc , 1 , ipar , 1 ) - & pp ( sproc , 1 , ipar , 2 ) * df0 ( sproc , 1 , ipar , 1 )) ) int_ee = int_ee + & 2.d0 * (& pp ( sproc , nperp - 1 , ipar , 2 ) * & ( df0 ( sproc , nperp - 1 , ipar , 2 ) * pp ( sproc , nperp - 1 , ipar , 1 ) - & pp ( sproc , nperp - 1 , ipar , 2 ) * df0 ( sproc , nperp - 1 , ipar , 1 )) ) enddo do iperp = 2 , nperp - 2 int_ee = int_ee + & 2.d0 * (& pp ( sproc , iperp , 1 , 2 ) * & ( df0 ( sproc , iperp , 1 , 2 ) * pp ( sproc , iperp , 1 , 1 ) - & pp ( sproc , iperp , 1 , 2 ) * df0 ( sproc , iperp , 1 , 1 )) ) int_ee = int_ee + & 2.d0 * (& pp ( sproc , iperp , npar - 1 , 2 ) * & ( df0 ( sproc , iperp , npar - 1 , 2 ) * pp ( sproc , iperp , npar - 1 , 1 ) - & pp ( sproc , iperp , npar - 1 , 2 ) * df0 ( sproc , iperp , npar - 1 , 1 ))) enddo int_ee = int_ee * 2.d0 * pi * qs ( sproc ) / ms ( sproc ) int_ee = int_ee * dpperp * dppar * 0.25d0 return end function int_ee !-=-=-=-=-=-= !Functions for resonant term in integral !-=-=-=-=-=-= double complex function resU ( om , nn , iperp , ipar ) use ALPS_var , only : pp , kpar , ms , qs , df0 , vA , sproc , relativistic implicit none !Passed integer :: nn !Bessel N integer :: iperp , ipar !p_perp, p_par index double complex :: om !complex frequency !Local double precision :: gamma !Relativistic Factor gamma = 1.d0 if ( relativistic ( sproc )) gamma = sqrt (( pp ( sproc , iperp , ipar , 1 ) ** 2 + & pp ( sproc , iperp , ipar , 2 ) ** 2 ) * vA ** 2 / ms ( sproc ) ** 2 + 1.d0 ) resU = qs ( sproc ) * & ( om * df0 ( sproc , iperp , ipar , 1 ) + ( kpar / ( gamma * ms ( sproc )) ) * & ( pp ( sproc , iperp , ipar , 1 ) * df0 ( sproc , iperp , ipar , 2 ) - & pp ( sproc , iperp , ipar , 2 ) * df0 ( sproc , iperp , ipar , 1 ) ) ) / & ( gamma * ms ( sproc ) * om - kpar * pp ( sproc , iperp , ipar , 2 ) - & ( 1.d0 * nn ) * qs ( sproc ) ) return end function resU !-=-=-=-=-=-= !Functions for Tij- !-=-=-=-=-=-= !Function to pass T_ij into integrator double complex function int_T ( nn , iperp , ipar , mode ) use ALPS_var , only : pp , kperp , qs , bessel_array , sproc implicit none !Passed integer :: nn !Bessel N integer :: iperp , ipar !p_perp, p_par index integer :: mode !index in T tensor !Local double precision :: z !Bessel Argument double precision :: bessel ! Bessel function for nn and z double precision :: besselP ! first derivative of Bessel function for nn and z double complex :: ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) !Bessel Fn Argument z = kperp / qs ( sproc ) ! Look up array of Bessel functions: if ( nn . LT . 0 ) then bessel = (( - 1.d0 ) ** nn ) * bessel_array ( - nn , iperp ) else bessel = bessel_array ( nn , iperp ) endif ! determine derivative of Bessel function: if ( nn . GE . 1 ) then besselP = 0.5d0 * ( bessel_array ( nn - 1 , iperp ) - bessel_array ( nn + 1 , iperp )) else if ( nn . LT . - 1 ) then besselP = 0.5d0 * (((( - 1.d0 ) ** ( nn - 1 )) * bessel_array ( - ( nn - 1 ), iperp ))& - ((( - 1.d0 ) ** ( nn + 1 )) * bessel_array ( - ( nn + 1 ), iperp ))) else if ( nn . EQ . 0 ) then besselP = - bessel_array ( 1 , iperp ) !NIST 10.6.2- yields same result. else if ( nn . EQ . - 1 ) then besselP = 0.5d0 * ( bessel_array ( 2 , iperp ) - bessel_array ( 0 , iperp )) endif select case ( mode ) case ( 1 ) !T xx int_T = 1.d0 * ( nn * nn ) * bessel * bessel / ( z * z ) case ( 2 ) !T yy int_T = ( pp ( sproc , iperp , ipar , 1 ) ** 2 ) * besselP * besselP case ( 3 ) !T zz int_T = bessel * bessel * pp ( sproc , iperp , ipar , 2 ) ** 2 case ( 4 ) !T xy int_T = ( pp ( sproc , iperp , ipar , 1 )) * ii * ( 1.d0 * ( nn )) * bessel * besselP / z case ( 5 ) !T xz int_T = ( 1.d0 * nn ) * bessel * bessel * pp ( sproc , iperp , ipar , 2 ) / z case ( 6 ) !T yz int_T = ( - 1.d0 * ii ) * bessel * besselP * pp ( sproc , iperp , ipar , 2 ) * pp ( sproc , iperp , ipar , 1 ) end select return end function int_T !++++ !-=-=-=-=-=-= !Functions for Tij- !-=-=-=-=-=-= !Function to pass T_ij into integrator double complex function int_T_res ( nn , iperp , p_res , mode ) use ALPS_var , only : pp , kperp , qs , bessel_array , sproc implicit none !Passed integer :: nn !Bessel N integer :: iperp !p_perp, p_par index integer :: mode !index in T tensor double complex :: p_res !Bessel Argument !Local double precision :: z !Bessel Argument double precision :: bessel ! Bessel function for nn and z double precision :: besselP ! first derivative of Bessel function for nn and z double complex :: ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) !Bessel Fn Argument z = kperp / qs ( sproc ) ! Look up array of Bessel functions: if ( nn . LT . 0 ) then bessel = (( - 1.d0 ) ** ( nn )) * bessel_array ( - nn , iperp ) else bessel = bessel_array ( nn , iperp ) endif ! determine derivative of Bessel function: if ( nn . GE . 1 ) then besselP = 0.5d0 * ( bessel_array ( nn - 1 , iperp ) - bessel_array ( nn + 1 , iperp )) else if ( nn . LT . - 1 ) then besselP = 0.5d0 * (((( - 1.d0 ) ** ( nn - 1 )) * bessel_array ( - ( nn - 1 ), iperp ))& - ((( - 1.d0 ) ** ( nn + 1 )) * bessel_array ( - ( nn + 1 ), iperp ))) else if ( nn . EQ . 0 ) then besselP = - bessel_array ( 1 , iperp ) !NIST 10.6.2- yields same result. else if ( nn . EQ . - 1 ) then besselP = 0.5d0 * ( bessel_array ( 2 , iperp ) - bessel_array ( 0 , iperp )) endif select case ( mode ) case ( 1 ) !T xx int_T_res = 1.d0 * ( nn * nn ) * bessel * bessel / ( z * z ) case ( 2 ) !T yy int_T_res = ( pp ( sproc , iperp , 1 , 1 ) ** 2 ) * besselP * besselP case ( 3 ) !T zz int_T_res = bessel * bessel * p_res ** 2 case ( 4 ) !T xy int_T_res = ( pp ( sproc , iperp , 1 , 1 )) * ii * ( 1.d0 * ( nn )) * bessel * besselP / z case ( 5 ) !T xz int_T_res = ( 1.d0 * nn ) * bessel * bessel * p_res / z case ( 6 ) !T yz int_T_res = ( - 1.d0 * ii ) * bessel * besselP * p_res * pp ( sproc , iperp , 1 , 1 ) end select return end function int_T_res !++++ !++++ !-=-=-=-=-=-= !Secant method !-=-=-=-=-=-= subroutine secant ( om ) use ALPS_var , only : numiter , D_threshold , ierror , proc0 , writeOut , D_prec use mpi implicit none double complex :: om , prevom , ii , D , Dprev , jump , minom , minD integer :: iter logical :: go_for_secant ii = ( 0.d0 , 1.d0 ) !prevom = om - 1.d-5 - 1.d-5*ii prevom = om * ( 1.d0 - D_prec ) Dprev = disp ( prevom ) minD = Dprev minom = prevom call mpi_barrier ( mpi_comm_world , ierror ) iter = 0 go_for_secant = . TRUE . do while (( iter . LE .( numiter - 1 )). AND .( go_for_secant )) iter = iter + 1 D = disp ( om ) if (( abs ( D - Dprev ). LT . 1.d-80 )) then prevom = prevom + 1.d-8 Dprev = disp ( prevom ) endif if (( abs ( D ). LT . D_threshold )) then jump = 0.d0 go_for_secant = . FALSE . if ( proc0 . AND . writeOut ) then write ( * , '(a,i4)' ) ' Converged after iteration ' , iter write ( * , '(a,2es14.4,a,2es14.4)' ) ' D(' , real ( om ), aimag ( om ), ')= ' , D endif else jump = D * ( om - prevom ) / ( D - Dprev ) endif prevom = om om = om - jump Dprev = D if ( abs ( D ). LT . abs ( minD )) then minom = om minD = D endif enddo if ( proc0 . AND . writeOut . AND .( iter . GE . numiter )) then write ( * , '(a,i4,a)' ) ' Maximum iteration ' , iter , ' reached.' om = minom write ( * , '(a,2es14.4,a,2es14.4)' ) ' D(' , real ( om ), aimag ( om ), ')= ' , D endif end subroutine secant !-=-=-=-=-=-= !Routine for scanning along a single perscribed path in wavevector space !-=-=-=-=-=-= !KGK: subroutine om_scan ( ik ) use ALPS_var , only : proc0 , nroots , runname , ierror , wroots , scan , sproc use ALPS_var , only : kperp , kpar , kperp_last , kpar_last , D_gap use ALPS_var , only : nspec use ALPS_io , only : get_unused_unit , isnancheck , alps_error use mpi implicit none !Passed integer :: ik !Scan Number !Local integer :: it , nt !step of scan, number of scans integer :: in !number of roots character ( 100 ), dimension (:), allocatable :: scanName !Output file name character ( 100 ), dimension (:), allocatable :: heatName !Output file name character ( 100 ), dimension (:), allocatable :: eigenName !Output file name character ( 6 ) :: scan_ID double precision :: theta_0 , theta_1 , k_0 double complex :: omega !Complex Frequency integer , dimension (:), allocatable :: scan_unit integer , dimension (:), allocatable :: heat_unit ! file for outputting damping rates integer , dimension (:), allocatable :: eigen_unit ! file for outputting eigenfn values integer :: imm logical , dimension (:), allocatable :: jump logical :: alljump double complex :: tmp !Eigenfunctions double complex , dimension ( 1 : 3 ) :: ef , bf !E, B double complex , dimension ( 1 : nspec ) :: ds !density double complex , dimension ( 1 : 3 , 1 : nspec ) :: Us !Velocity !Heating double precision , dimension ( 1 : nspec ) :: Ps !Power into/out of species character ( 50 ) :: fmt_eigen , fmt_heat !Output format allocate ( jump ( 1 : nroots )); jump = . true . if ( proc0 ) then allocate ( scan_unit ( nroots )) allocate ( scanName ( nroots )) select case ( scan ( ik )% type_s ) case ( 0 ) !k_0 to k_1 write ( scan_ID , '(a)' ) 'k1_k2_' case ( 1 ) !theta_0 to theta_1 write ( scan_ID , '(a)' ) 'theta_' case ( 2 ) ! |k_0| to |k_1| @ constant theta write ( scan_ID , '(a)' ) 'kcstq_' case ( 3 ) !kperp scan write ( scan_ID , '(a)' ) 'kperp_' case ( 4 ) !kpar scan write ( scan_ID , '(a)' ) 'kpara_' end select if ( scan ( ik )% eigen_s ) then write ( fmt_eigen , '(a,i0,a)' ) '(4es14.4,12es14.4,' , nspec * 8 , 'es14.4)' allocate ( eigen_unit ( nroots )) allocate ( eigenName ( nroots )) endif if ( scan ( ik )% heat_s ) then write ( fmt_heat , '(a,i0,a)' ) '(4es14.4,' , nspec , 'es14.4)' allocate ( heat_unit ( nroots )) allocate ( heatName ( nroots )) endif do in = 1 , nroots write ( scanName ( in ), '(4a,i0,a,i0)' )& 'solution/' , trim ( runname ), '.scan_' , scan_ID , ik , '.root_' , in write ( * , '(2a)' ) ' => ' , trim ( scanName ( in )) call get_unused_unit ( scan_unit ( in )) open ( unit = scan_unit ( in ), file = trim ( scanName ( in )), status = 'replace' ) write ( scan_unit ( in ), '(4es14.4)' ) & kperp , kpar , wroots ( in ) close ( scan_unit ( in )) enddo endif if (( scan ( ik )% eigen_s ). or .( scan ( ik )% heat_s )) then do in = 1 , nroots omega = wroots ( in ) tmp = disp ( omega ) call calc_eigen ( omega , ef , bf , Us , ds , Ps , scan ( ik )% eigen_s , scan ( ik )% heat_s ) !reassign omega omega = wroots ( in ) !this is necessary, as calc_eigen evaluates !the wave tensor at several different values of omega call mpi_barrier ( mpi_comm_world , ierror ) if ( proc0 ) then if ( scan ( ik )% eigen_s ) then write ( eigenName ( in ), '(4a,i0,a,i0)' )& 'solution/' , trim ( runname ), '.eigen_' , scan_ID , ik , '.root_' , in write ( * , '(2a)' ) ' => ' , trim ( eigenName ( in )) call get_unused_unit ( eigen_unit ( in )) open ( unit = eigen_unit ( in ), file = trim ( eigenName ( in )), status = 'replace' ) write ( eigen_unit ( in ), trim ( fmt_eigen )) & kperp , kpar , wroots ( in ), ef , bf , Us , ds close ( eigen_unit ( in )) endif if ( scan ( ik )% heat_s ) then write ( heatName ( in ), '(4a,i0,a,i0)' )& 'solution/' , trim ( runname ), '.heat_' , scan_ID , ik , '.root_' , in write ( * , '(2a)' ) ' => ' , trim ( heatName ( in )) call get_unused_unit ( heat_unit ( in )) open ( unit = heat_unit ( in ), file = trim ( heatName ( in )), status = 'replace' ) write ( heat_unit ( in ), trim ( fmt_heat )) & kperp , kpar , wroots ( in ), Ps close ( heat_unit ( in )) endif endif enddo endif nt = scan ( ik )% n_out * scan ( ik )% n_res kperp_last = kperp ; kpar_last = kpar theta_0 = atan ( kperp_last / kpar_last ) k_0 = sqrt ( kperp_last ** 2 + kpar_last ** 2 ) do it = 1 , nt !Scan through wavevector select case ( scan ( ik )% type_s ) case ( 0 ) !k_0 to k_1 if ( scan ( ik )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperp_last ) + scan ( ik )% diff * it ) kpar = 1 0.d0 ** ( log10 ( kpar_last ) + scan ( ik )% diff2 * it ) else kperp = kperp_last + scan ( ik )% diff * it kpar = kpar_last + scan ( ik )% diff2 * it endif case ( 1 ) !theta_0 to theta_1 if ( scan ( ik )% log_scan ) then theta_1 = 1 0.d0 ** ( log10 ( theta_0 ) + scan ( ik )% diff * it ) else theta_1 = theta_0 + scan ( ik )% diff * it endif kperp = k_0 * sin ( theta_1 ) kpar = k_0 * cos ( theta_1 ) case ( 2 ) ! |k_0| to |k_1| @ constant theta if ( scan ( ik )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperp_last ) + scan ( ik )% diff * it ) kpar = 1 0.d0 ** ( log10 ( kpar_last ) + scan ( ik )% diff2 * it ) else kperp = kperp_last + scan ( ik )% diff * it kpar = kpar_last + scan ( ik )% diff2 * it endif case ( 3 ) !kperp scan if ( scan ( ik )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperp_last ) + scan ( ik )% diff * it ) else kperp = kperp_last + scan ( ik )% diff * it endif case ( 4 ) !kpar scan if ( scan ( ik )% log_scan ) then kpar = 1 0.d0 ** ( log10 ( kpar_last ) + scan ( ik )% diff * it ) else kpar = kpar_last + scan ( ik )% diff * it endif end select if ( scan ( ik )% type_s . ne . 4 ) then ! Once we know kperp, we can determine nmax and split the processes: ! These three routines must be called when kperp changes call determine_nmax call split_processes ! All processes determine their Bessel function array: if (. NOT .( sproc . EQ . 0 )) call determine_bessel_array endif call mpi_barrier ( mpi_comm_world , ierror ) if ( proc0 ) write ( * , '(a,es14.4,a,es14.4)' ) 'kperp: ' , kperp , ' kpar: ' , kpar ! Check if all jumps are set to .false.: alljump = . FALSE . do in = 1 , nroots alljump = alljump . OR . jump ( in ) enddo if ( alljump . EQV .. FALSE .) call alps_error ( 9 ) do in = 1 , nroots !Search for new roots if ( jump ( in )) then omega = wroots ( in ) call secant ( omega ) wroots ( in ) = omega call mpi_bcast ( wroots ( in ), 1 , & MPI_DOUBLE_COMPLEX , 0 , MPI_COMM_WORLD , ierror ) tmp = disp ( omega ) call mpi_barrier ( mpi_comm_world , ierror ) !Calculate eigenfunctions and heating rates !KGK: 200526 !only call on wavevector steps that will be output if ( mod ( it , scan ( ik )% n_res ) == 0 ) then if (( scan ( ik )% eigen_s ). or .(( scan ( ik )% heat_s ))) then !the susceptability tensor, chi0 !and wave tensor, wave !are set by the !tmp = disp(omega) !call above mpi_barrier call calc_eigen ( omega , ef , bf , Us , ds , Ps , scan ( ik )% eigen_s , scan ( ik )% heat_s ) !reassign omega omega = wroots ( in ) !this is necessary, as calc_eigen evaluates !the wave tensor at several different values of omega endif endif call mpi_barrier ( mpi_comm_world , ierror ) !Output and check for root jumps and NaNs if ( proc0 ) then !NaN Check !              tmp=real(omega) if ( isnancheck ( real ( omega ))) then omega = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )); jump ( in ) = . false . endif !              if (.not.(tmp .ne. omega)) then !                 omega=cmplx(0.d0,0.d0);jump(in)=.false. !              endif !              !infty Check !              if (abs(tmp) .gt. 1.d100) then !                 omega=cmplx(0.d0,0.d0);jump(in)=.false. !              endif !compare to previous roots !KGK: 200811: Updated to separately compare real and imaginary components of roots !previous version would reject all roots except the first solution for scans of !relatvely small wavevectors do imm = 1 , in - 1 if ( abs ( wroots ( in ) - wroots ( imm )). lt . D_gap ) then write ( * , '(a,6es14.4)' ) 'Root too close!' ,& wroots ( in ), wroots ( imm ),& real ( wroots ( in )) - real ( wroots ( imm )), & aimag ( wroots ( in )) - aimag ( wroots ( imm )) wroots ( in ) = cmplx ( 0.d0 , 0.d0 ); jump ( in ) = . false . endif enddo if ( mod ( it , scan ( ik )% n_res ) == 0 ) then open ( unit = scan_unit ( in ), file = trim ( scanName ( in )), status = 'old' , position = 'append' ) write ( scan_unit ( in ), '(4es14.4)' ) & kperp , kpar , wroots ( in ) close ( scan_unit ( in )) if ( scan ( ik )% eigen_s ) then open ( unit = eigen_unit ( in ), file = trim ( eigenName ( in )), status = 'old' , position = 'append' ) write ( eigen_unit ( in ), trim ( fmt_eigen )) & kperp , kpar , wroots ( in ), ef , bf , Us , ds close ( eigen_unit ( in )) endif if ( scan ( ik )% heat_s ) then open ( unit = heat_unit ( in ), file = trim ( heatName ( in )), status = 'old' , position = 'append' ) write ( heat_unit ( in ), trim ( fmt_heat )) & kperp , kpar , wroots ( in ), Ps close ( heat_unit ( in )) endif endif endif call mpi_bcast ( jump ( in ), 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) end if call mpi_barrier ( mpi_comm_world , ierror ) enddo enddo if ( proc0 ) then deallocate ( scan_unit ) deallocate ( scanName ) endif end subroutine om_scan !-=-=-=-=-=-= !  Calculates the electric and magnetic fields as well as species !     velocities and density fluctuations for (omega,gamma) !     and particle heating/cooling from a given wave !-=-=-=-=-=-= !KGK: 200522 !Based upon calc_eigen routine by Greg Howes and Kris Klein !found in the PLUME linear dispersion solver subroutine calc_eigen ( omega , electric , magnetic , vmean , ds , Ps , eigen_L , heat_L ) use ALPS_var , only : proc0 , nspec , ns , qs , wave , chi0 , kperp , kpar , vA implicit none !Passed !Frequency double complex :: omega !Electromagnetic Eigenfns double complex , dimension ( 1 : 3 ), intent ( out ) :: electric , magnetic !E, B double complex , dimension ( 1 : nspec ), intent ( out ) :: ds !density fluctuation double complex , dimension ( 1 : 3 , 1 : nspec ), intent ( out ) :: vmean !Velocity fluctiation !Heating double precision , dimension ( 1 : nspec ), intent ( out ) :: Ps !Power into/out of species logical :: eigen_L , heat_L !Logical for calculating eigenvalues, heating !Local integer :: ii , j , jj double complex :: temp1 double complex , dimension ( nspec , 3 , 3 ) :: chia double complex , dimension ( 3 , 3 ) :: chih , chihold , dchih double complex , dimension ( nspec , 3 ) :: term double complex , dimension ( 3 ) :: term1 double precision :: ewave if ( proc0 ) then !Note that the electric and magnetic fields are needed for the heating !rate calculation; thus, we calculate them for both the eigen and heating !logical flags !CALCULATE FIELDS FLUCTUATIONS========================================== !Calculate Electric Fields, normalized to E_x electric ( 1 ) = cmplx ( 1.d0 , 0.d0 , kind ( 1.d0 )) electric ( 3 ) =- electric ( 1 ) * ( wave ( 2 , 1 ) * wave ( 3 , 2 ) - wave ( 3 , 1 ) * wave ( 2 , 2 )) electric ( 3 ) = electric ( 3 ) / ( wave ( 2 , 3 ) * wave ( 3 , 2 ) - wave ( 3 , 3 ) * wave ( 2 , 2 )) electric ( 2 ) = - electric ( 3 ) * wave ( 3 , 3 ) - electric ( 1 ) * wave ( 3 , 1 ) electric ( 2 ) = electric ( 2 ) / wave ( 3 , 2 ) !Calculate Magnetic Fields, normalized to E_x magnetic ( 1 ) = - 1.d0 * kpar * electric ( 2 ) / ( omega * vA ) magnetic ( 2 ) = - 1.d0 * ( kperp * electric ( 3 ) - kpar * electric ( 1 )) / ( omega * vA ) magnetic ( 3 ) = kperp * electric ( 2 ) / ( omega * vA ) !KGK: The magnetic field normalization factors are different from PLUME, !as spatial scales are normalized to d_ref, rather than rho_ref. !thus, w_perp, ref/c in PLUME becomes v_A/c here. if ( eigen_L ) then !CALCULATE VELOCITY FLUCTUATIONS======================================== !vmean is the velocity perturbutation due to the wave for each species !vmean = (delta V_s/v_A)(B_0/E_x)(v_A/c) vmean (:,:) = 0.d0 do j = 1 , 3 !x,y,z do jj = 1 , nspec !Species velocity fluctuations vmean ( j , jj ) = - ( vA ** 2.d0 / ( qs ( jj ) * ns ( jj ))) * & cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) * & omega * sum ( electric (:) * chi0 ( jj , j ,:)) enddo enddo !CALCULATE DENSITY FLUCTUATIONS======================================== ! This is (ns/ns0)(B_0/E_x)(v_A/c) do jj = 1 , nspec !ds(jj) = (vmean(1,jj)*kperp+vmean(3,jj)*kpar)/& !     (omega-kpar * spec(jj)%vv_s) !TO-DO: !add in correct effects of drift on density fluctuation !e.g. omega-kpar V_0 !with a physically meaningful V_0 used. ds ( jj ) = 0.d0 !ds(jj) = (vmean(1,jj)*kperp+vmean(3,jj)*kpar)/& !     (omega) enddo !EndIf (scan(is)%eigen_s) loop endif endif !If (scan(is)%heat_s) loop !Greg Howes, 2006; Kristopher Klein, 2015 if ( heat_L ) then !CALCULATE COMPONENT HEATING====================================== !evaulate at omega_r=real(omega), gamma=0 temp1 = cmplx ( real ( omega ), 0.d0 , kind ( 1.d0 )) !temp1 = omega temp1 = disp ( temp1 ) if ( proc0 ) then do ii = 1 , 3 !tensor index do j = 1 , 3 !tensor index do jj = 1 , nspec !species index chia ( jj , ii , j ) = - 0.5d0 * cmplx ( 0.d0 , 1.d0 ) * & ( chi0 ( jj , ii , j ) - conjg ( chi0 ( jj , j , ii ))) enddo chihold ( ii , j ) = 0.5 * ( sum ( chi0 (:, ii , j )) + & sum ( conjg ( chi0 (:, j , ii )))) enddo enddo term (:,:) = 0.d0 term1 (:) = 0.d0 do ii = 1 , 3 do jj = 1 , nspec term ( jj , ii ) = sum ( conjg ( electric (:)) * chia ( jj ,:, ii )) enddo enddo Ps = 0.d0 do jj = 1 , nspec Ps ( jj ) = sum ( term ( jj ,:) * electric (:)) enddo endif !recall that disp requires /all/ processors temp1 = disp ( cmplx ( real ( omega * 1.000001d0 ), 0.d0 , kind ( 1.d0 ))) !but only proc0 'knows' the correct value of chi0 if ( proc0 ) then do ii = 1 , 3 do j = 1 , 3 chih ( ii , j ) = 0.5d0 * ( sum ( chi0 (:, ii , j )) + & sum ( conjg ( chi0 (:, j , ii )))) dchih ( ii , j ) = ( 1.000001d0 * chih ( ii , j ) - chihold ( ii , j )) / 0.000001d0 enddo enddo ewave = 0.d0 do ii = 1 , 3 term1 ( ii ) = sum ( conjg ( electric (:)) * dchih (:, ii )) enddo ewave = sum ( term1 (:) * electric (:)) + sum ( magnetic (:) * conjg ( magnetic (:))) Ps = Ps / ewave endif endif !EndIf (scan(is)%heat_s) loop end subroutine calc_eigen !-=-=-=-=-=-= !Routine for scanning along a perscribed plane in wavevector space !Must have n_scan=2 !-=-=-=-=-=-= !KGK: subroutine om_double_scan use ALPS_var , only : proc0 , nroots , runname , ierror , wroots , scan , sproc use ALPS_var , only : kperp , kpar , kperp_last , kpar_last , D_gap use ALPS_var , only : ierror use ALPS_io , only : get_unused_unit , alps_error use mpi implicit none !Local integer :: it , it2 , nt , nt2 !step of scan, number of scans integer :: in !number of roots character ( 100 ), dimension (:), allocatable :: scanName !Output file name character ( 6 ) :: scan_ID character ( 5 ) :: scan_ID2 double precision :: theta_0 , theta_1 , k_0 , theta_i , k_i double precision :: kperpi , kpari double precision , dimension (:), allocatable :: om_tmp double complex :: omega !Complex Frequency integer , dimension (:), allocatable :: scan_unit double precision :: tmp integer :: imm logical , dimension (:), allocatable :: jump allocate ( jump ( 1 : nroots )); jump = . true . if ( scan ( 1 )% type_s == scan ( 2 )% type_s ) then call alps_error ( 5 ) endif if (( scan ( 1 )% type_s == 0 ). or .( scan ( 2 )% type_s == 0 )) then call alps_error ( 6 ) endif allocate ( om_tmp ( nroots )) if ( proc0 ) then allocate ( scan_unit ( nroots )) allocate ( scanName ( nroots )) !Name of first scan select case ( scan ( 1 )% type_s ) case ( 0 ) !k_0 to k_1 write ( scan_ID , '(a)' ) 'k1_k2_' case ( 1 ) !theta_0 to theta_1 write ( scan_ID , '(a)' ) 'theta_' case ( 2 ) ! |k_0| to |k_1| @ constant theta write ( scan_ID , '(a)' ) 'kcstq_' case ( 3 ) !kperp scan write ( scan_ID , '(a)' ) 'kperp_' case ( 4 ) !kpar scan write ( scan_ID , '(a)' ) 'kpara_' end select !Name of second scan select case ( scan ( 2 )% type_s ) case ( 0 ) !k_0 to k_1 write ( scan_ID2 , '(a)' ) 'k1_k2' case ( 1 ) !theta_0 to theta_1 write ( scan_ID2 , '(a)' ) 'theta' case ( 2 ) ! |k_0| to |k_1| @ constant theta write ( scan_ID2 , '(a)' ) 'kcstq' case ( 3 ) !kperp scan write ( scan_ID2 , '(a)' ) 'kperp' case ( 4 ) !kpar scan write ( scan_ID2 , '(a)' ) 'kpara' end select do in = 1 , nroots write ( scanName ( in ), '(6a,i0)' )& 'solution/' , trim ( runname ), '.scan_' , scan_ID , scan_ID2 , '.root_' , in write ( * , '(2a)' ) ' => ' , trim ( scanName ( in )) call get_unused_unit ( scan_unit ( in )) open ( unit = scan_unit ( in ), file = trim ( scanName ( in )), status = 'replace' ) write ( scan_unit ( in ), '(4es14.4)' ) & kperp , kpar , wroots ( in ) close ( scan_unit ( in )) enddo endif nt = scan ( 1 )% n_out * scan ( 1 )% n_res nt2 = scan ( 2 )% n_out * scan ( 2 )% n_res kperp_last = kperp ; kpar_last = kpar theta_0 = atan ( kperp_last / kpar_last ) k_0 = sqrt ( kperp_last ** 2 + kpar_last ** 2 ) do it = 1 , nt !Scan through wavevector select case ( scan ( 1 )% type_s ) case ( 0 ) !k_0 to k_1 if ( scan ( 1 )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperp_last ) + scan ( 1 )% diff * it ) kpar = 1 0.d0 ** ( log10 ( kpar_last ) + scan ( 1 )% diff2 * it ) else kperp = kperp_last + scan ( 1 )% diff * it kpar = kpar_last + scan ( 1 )% diff2 * it endif case ( 1 ) !theta_0 to theta_1 if ( scan ( 1 )% log_scan ) then theta_1 = 1 0.d0 ** ( log10 ( theta_0 ) + scan ( 1 )% diff * it ) else theta_1 = theta_0 + scan ( 1 )% diff * it endif kperp = k_0 * sin ( theta_1 ) kpar = k_0 * cos ( theta_1 ) case ( 2 ) ! |k_0| to |k_1| @ constant theta if ( scan ( 1 )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperp_last ) + scan ( 1 )% diff * it ) kpar = 1 0.d0 ** ( log10 ( kpar_last ) + scan ( 1 )% diff2 * it ) else kperp = kperp_last + scan ( 1 )% diff * it kpar = kpar_last + scan ( 1 )% diff2 * it endif case ( 3 ) !kperp scan if ( scan ( 1 )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperp_last ) + scan ( 1 )% diff * it ) else kperp = kperp_last + scan ( 1 )% diff * it endif case ( 4 ) !kpar scan if ( scan ( 1 )% log_scan ) then kpar = 1 0.d0 ** ( log10 ( kpar_last ) + scan ( 1 )% diff * it ) else kpar = kpar_last + scan ( 1 )% diff * it endif end select if (. true .) then if ( scan ( 1 )% type_s . ne . 4 ) then ! Once we know kperp, we can determine nmax and split the processes: ! These three routines must be called when kperp changes call determine_nmax call split_processes ! All processes determine their Bessel function array: if (. NOT .( sproc . EQ . 0 )) call determine_bessel_array endif call mpi_barrier ( mpi_comm_world , ierror ) endif if ( proc0 ) write ( * , '(a,es14.4,a,es14.4)' ) 'kperp: ' , kperp , ' kpar: ' , kpar om_tmp = wroots !SECOND SCAN do it2 = 1 , nt2 !Scan through wavevector if ( it2 == 1 ) then kperpi = kperp ; kpari = kpar kperpi = kperp ; kpari = kpar theta_i = atan ( kperpi / kpari ) k_i = sqrt ( kperpi ** 2 + kpari ** 2 ) wroots = om_tmp endif select case ( scan ( 2 )% type_s ) case ( 0 ) !k_0 to k_1 if ( scan ( 2 )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperpi ) + scan ( 2 )% diff * it2 ) kpar = 1 0.d0 ** ( log10 ( kpari ) + scan ( 2 )% diff2 * it2 ) else kperp = kperpi + scan ( 2 )% diff * it2 kpar = kpari + scan ( 2 )% diff2 * it2 endif case ( 1 ) !theta_i to theta_1 if ( scan ( 2 )% log_scan ) then theta_1 = 1 0.d0 ** ( log10 ( theta_i ) + scan ( 2 )% diff * it2 ) else theta_1 = theta_i + scan ( 2 )% diff * it2 endif kperp = k_i * sin ( theta_1 ) kpar = k_i * cos ( theta_1 ) case ( 2 ) ! |k_0| to |k_1| @ constant theta if ( scan ( 2 )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperpi ) + scan ( 2 )% diff * it2 ) kpar = 1 0.d0 ** ( log10 ( kpari ) + scan ( 2 )% diff2 * it2 ) else kperp = kperpi + scan ( 2 )% diff * it2 kpar = kpari + scan ( 2 )% diff2 * it2 endif case ( 3 ) !kperp scan if ( scan ( 2 )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperpi ) + scan ( 2 )% diff * it2 ) else kperp = kperpi + scan ( 2 )% diff * it2 endif case ( 4 ) !kpar scan if ( scan ( 2 )% log_scan ) then kpar = 1 0.d0 ** ( log10 ( kpari ) + scan ( 2 )% diff * it2 ) else kpar = kpari + scan ( 2 )% diff * it2 endif end select if (. true .) then if ( scan ( 2 )% type_s . ne . 4 ) then ! Once we know kperp, we can determine nmax and split the processes: ! These three routines must be called when kperp changes call determine_nmax call split_processes ! All processes determine their Bessel function array: if (. NOT .( sproc . EQ . 0 )) call determine_bessel_array endif call mpi_barrier ( mpi_comm_world , ierror ) endif if ( proc0 ) write ( * , '(a,es14.4,a,es14.4)' ) 'kperp: ' , kperp , ' kpar: ' , kpar do in = 1 , nroots !Search for new roots if ( jump ( in )) then omega = wroots ( in ) call secant ( omega ) wroots ( in ) = omega call mpi_bcast ( wroots ( in ), 1 , & MPI_DOUBLE_COMPLEX , 0 , MPI_COMM_WORLD , ierror ) tmp = disp ( omega ) call mpi_barrier ( mpi_comm_world , ierror ) !Output... if ( proc0 ) then !NaN Check tmp = real ( omega ) if (. not .( tmp . ne . omega )) then omega = cmplx ( 0.d0 , 0.d0 ); jump ( in ) = . false . endif !infty Check if ( abs ( tmp ) . gt . 1.d100 ) then omega = cmplx ( 0.d0 , 0.d0 ); jump ( in ) = . false . endif do imm = 1 , in - 1 if ( abs ( wroots ( in ) - wroots ( imm )). lt . D_gap ) then write ( * , '(a,6es14.4)' ) 'Root too close!' ,& wroots ( in ), wroots ( imm ),& real ( wroots ( in )) - real ( wroots ( imm )), & aimag ( wroots ( in )) - aimag ( wroots ( imm )) wroots ( in ) = cmplx ( 0.d0 , 0.d0 ); jump ( in ) = . false . endif enddo !Aplus~=Aminus if ( mod ( it2 , scan ( 2 )% n_res ) == 0 ) then open ( unit = scan_unit ( in ), file = trim ( scanName ( in )),& status = 'old' , position = 'append' ) write ( scan_unit ( in ), '(4es14.4)' ) & kperp , kpar , wroots ( in ) close ( scan_unit ( in )) endif endif call mpi_bcast ( jump ( in ), 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) endif call mpi_barrier ( mpi_comm_world , ierror ) enddo !roots enddo !second scan if ( proc0 ) then do in = 1 , nroots open ( unit = scan_unit ( in ), file = trim ( scanName ( in )),& status = 'old' , position = 'append' ) write ( scan_unit ( in ), * ) close ( scan_unit ( in )) enddo endif kperp = kperp_last ; kpar = kpar_last enddo !first scan if ( proc0 ) then deallocate ( scan_unit ) deallocate ( scanName ) endif deallocate ( om_tmp ) end subroutine om_double_scan !-=-=-=-=-=-= !Routine to find solutions over a region of complex frequency space- !-=-=-=-=-=-= !KGK: subroutine map_search use ALPS_var , only : ierror use ALPS_var , only : omi , omf , gami , gamf , loggridw , loggridg , determine_minima use ALPS_var , only : ni , nr , proc0 , ms , ns , qs , runname , nspec use ALPS_var , only : writeOut , kperp , kpar , wroots , numroots , nroots , nroots_max use ALPS_io , only : get_unused_unit use mpi implicit none double precision :: dr , di !Spacing double precision :: wr , wi !Real,imaginary omega double precision , dimension (:,:), pointer :: val !Value of Dispersion relation double complex , dimension (:,:), allocatable :: cal ! (complex) Value of Dispersion relation double complex , dimension (:,:), allocatable :: om !Complex Frequency double complex :: omega !Complex Frequency integer :: ii , ir !indices for frequency grids integer :: is !species index integer :: iw !root index character ( 100 ) :: mapName !Output file names integer , dimension ( 1 : 2 , 1 : numroots ) :: iroots !Indices of roots in local min. search integer :: unit_map double precision :: tmp if ( writeOut . and . proc0 . and . . true .) then write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-=-' write ( * , '(a)' ) 'Global Plasma Parameters:' write ( * , '(a,es12.3)' ) ' k_perp d_p   = ' , kperp write ( * , '(a,es12.3)' ) ' k_par  d_p   = ' , kpar do is = 1 , nspec write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-=-' write ( * , '(a,i3)' ) 'Parameters for species' , is write ( * , '(a,es12.3)' ) ' m_s/m_m =        ' , ms ( is ) write ( * , '(a,es12.3)' ) ' q_s/q_p =        ' , qs ( is ) write ( * , '(a,es12.3)' ) ' n_s/n_p =        ' , ns ( is ) enddo write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-=-' write ( * , '(a)' ) 'Searching over:' write ( * , '(a,es12.3,a,es12.3,a)' ) ' om  in [' , omi , ',' , omf , ']' write ( * , '(a,es12.3,a,es12.3,a)' ) ' gam in [' , gami , ',' , gamf , ']' write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-=-' endif !Allocate array for map values !Value of dispersion relation on frequency grid allocate ( cal ( nr , ni )); cal (:,:) = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) !magnitude of cal allocate ( val ( nr , ni )); val (:,:) = 0.d0 !Array of complex frequencies allocate ( om ( nr , ni )); om (:,:) = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) !Determine spacing in complex omega space (Normal or log) dr = omf - omi di = gamf - gami if ( nr . GT . 1 ) dr = ( omf - omi ) / ( 1.d0 * ( nr - 1 )) if ( ni . GT . 1 ) di = ( gamf - gami ) / ( 1.d0 * ( ni - 1 )) if ( proc0 ) then write ( mapName , '(3a)' ) 'solution/' , trim ( runname ), '.map' call get_unused_unit ( unit_map ) open ( unit = unit_map , file = trim ( mapName ), status = 'replace' ) close ( unit_map ) endif !Scan over complex frequency space and calculate dispersion relation do ir = 1 , nr if ( loggridw ) then wr = omi if ( nr . GT . 1 ) wr = omi * (( omf / omi ) ** (( 1.d0 * ( ir - 1 )) / ( 1.d0 * ( nr - 1 )))) else wr = omi + dr * ( 1.d0 * ( ir - 1 )) endif if ( proc0 . and . writeOut )& write ( * , '(a,es11.4)' ) ' omega_real = ' , wr do ii = 1 , ni if ( loggridg ) then wi = gami if ( ni . GT . 1 ) wi = gami * (( gamf / gami ) ** (( 1.d0 * ( ii - 1 )) / ( 1.d0 * ( ni - 1 )))) else wi = gami + di * ( 1.d0 * ( ii - 1 )) endif !if (proc0.and.writeOut)& !     write(*,'(a,es11.4)')' omega_aimag = ',wi omega = cmplx ( wr , wi , kind ( 1.d0 )) om ( ir , ii ) = omega cal ( ir , ii ) = disp ( omega ) val ( ir , ii ) = abs ( cal ( ir , ii )) if ( proc0 ) then tmp = cal ( ir , ii ) val ( ir , ii ) = log10 ( val ( ir , ii )) !NaN Check if ( aimag ( cal ( ir , ii )). ne . 0.d0 ) then if (. not .( tmp . ne . cal ( ir , ii )) ) then !write(*,*) 'fail check one: ',tmp, cal(ir,ii) cal ( ir , ii ) = 99999 9.d0 ; val ( ir , ii ) = 99999 9.d0 endif else if (( tmp . ne . cal ( ir , ii )) ) then !write(*,*) 'fail check one: ',tmp, cal(ir,ii) cal ( ir , ii ) = 99999 9.d0 ; val ( ir , ii ) = 99999 9.d0 endif endif !infty Check if ( abs ( tmp ) . gt . 1.d100 ) then cal ( ir , ii ) = 89999 9.d0 ; val ( ir , ii ) = 89999 9.d0 endif open ( unit = unit_map , file = trim ( mapName ), status = 'old' , position = 'append' ) write ( unit_map , '(2i6,5es14.6)' ) & ir , ii , om ( ir , ii ), val ( ir , ii ), cal ( ir , ii ) close ( unit_map ) endif enddo if ( proc0 ) then open ( unit = unit_map , file = trim ( mapName ), status = 'old' , position = 'append' ) write ( unit_map , * ) close ( unit_map ) endif enddo if ( determine_minima ) then !Search for Local Minima in Dispersion Surface if ( proc0 . and .( nr . gt . 1 ). and .( ni . gt . 1 )) then write ( * , * ) 'finding minima' call find_minima ( val , numroots , iroots , nroots_max ) if ( writeOut ) & write ( * , '(i2,a)' ) nroots_max , '  possible local minimum found' do iw = 1 , nroots_max wroots ( iw ) = om ( iroots ( 1 , iw ), iroots ( 2 , iw )) if ( writeOut ) then write ( * , '(a,i4,a,i4)' ) 'ir = ' , iroots ( 1 , iw ), '    ii = ' , iroots ( 2 , iw ) write ( * , '(4es14.4)' ) wroots ( iw ) , cal ( iroots ( 1 , iw ), iroots ( 2 , iw )) endif enddo nroots = min ( nroots , nroots_max ) endif if ( proc0 ) write ( * , * ) 'testing!' call mpi_bcast ( nroots , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( wroots (:), size ( wroots (:)), MPI_DOUBLE_COMPLEX , 0 , MPI_COMM_WORLD , ierror ) call refine_guess call mpi_bcast ( nroots , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( wroots (:), size ( wroots (:)), MPI_DOUBLE_COMPLEX , 0 , MPI_COMM_WORLD , ierror ) endif end subroutine map_search !-=-=-=-=-=-= ! !-=-=-=-=-=-= subroutine refine_guess use alps_var , only : wroots , nroots , writeOut , proc0 use alps_var , only : ierror , runname use alps_io , only : get_unused_unit use mpi implicit none double complex :: omega !Complex Frequency character ( 100 ) :: mapName !Output file names double complex :: tmpDisp !holding variable for dispersion relation solution integer :: iw !loop index integer :: unit_refine !Refine if ( proc0 ) then if ( writeOut ) write ( * , '(a)' ) ' Refining Roots:' write ( mapName , '(3a)' ) 'solution/' , trim ( runname ), '.roots' call get_unused_unit ( unit_refine ) open ( unit = unit_refine , file = trim ( mapName ), status = 'replace' ) endif do iw = 1 , nroots if ( proc0 . and . writeOut ) write ( * , '(a,i0)' ) 'Root ' , iw call mpi_barrier ( mpi_comm_world , ierror ) omega = wroots ( iw ) call secant ( omega ) wroots ( iw ) = omega tmpDisp = disp ( wroots ( iw )) if ( proc0 . and .( abs ( tmpDisp ). NE . 0.d0 )) then write ( unit_refine , '(i4,5es14.4)' ) iw , wroots ( iw ), log10 ( abs ( tmpDisp )), tmpDisp write ( * , '(i4,5es14.4)' ) iw , wroots ( iw ), log10 ( abs ( tmpDisp )), tmpDisp !       if (writeOut) write(*,'(a,2es14.4,a,2es14.4)')'D(',wroots(iw),')= ',tmpDisp endif enddo if ( proc0 ) close ( unit_refine ) end subroutine refine_guess ! !-=-=-=-=-=-= !                          Based upon routine by !                          Greg Howes, 2006 !-=-=-=-=-=-= subroutine find_minima ( val , numroots , iroots , nroots ) use ALPS_var , only : ni , nr implicit none !Passed double precision , dimension (:,:), pointer :: val !Value of Dispersion relation integer :: numroots !Number of roots integer , dimension ( 1 : 2 , 1 : numroots ) :: iroots !Indices of roots integer , intent ( out ) :: nroots !Number of roots found !Local integer :: ir , ii !Counters !Find local minima in map iroots = 0 nroots = 0 do ii = ni , 1 , - 1 do ir = 1 , nr !ir = 0 if ( ir == 1 ) then if ( val ( ir , ii ) . lt . val ( ir + 1 , ii )) then if ( ii == 1 ) then if ( val ( ir , ii ) . lt . val ( ir , ii + 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif elseif ( ii == ni ) then if ( val ( ir , ii ) . lt . val ( ir , ii - 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif else if ( val ( ir , ii ) . lt . val ( ir , ii - 1 ) . and . & val ( ir , ii ) . lt . val ( ir , ii + 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif endif endif elseif ( ir == nr ) then if ( val ( ir , ii ) . lt . val ( ir - 1 , ii )) then if ( ii == 1 ) then if ( val ( ir , ii ) . lt . val ( ir , ii + 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif elseif ( ii == ni ) then if ( val ( ir , ii ) . lt . val ( ir , ii - 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif else if ( val ( ir , ii ) . lt . val ( ir , ii - 1 ) . and . & val ( ir , ii ) . lt . val ( ir , ii + 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif endif endif else if ( val ( ir , ii ) . lt . val ( ir - 1 , ii ) . and . & val ( ir , ii ) . lt . val ( ir + 1 , ii )) then if ( ii == 1 ) then if ( val ( ir , ii ) . lt . val ( ir , ii + 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif elseif ( ii == ni ) then if ( val ( ir , ii ) . lt . val ( ir , ii - 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif else if ( val ( ir , ii ) . lt . val ( ir , ii - 1 ) . and . & val ( ir , ii ) . lt . val ( ir , ii + 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif endif endif endif enddo enddo write ( * , * ) nroots end subroutine find_minima !-=-=-=-=-=-= !Bessel Functions !-=-=-=-=-=-= ! determine nmax: subroutine determine_nmax () use ALPS_var , only : pp , kperp , qs , Bessel_zero , nmax , ierror use ALPS_var , only : proc0 , nperp , nspec , writeOut , nproc , usebM use ALPS_fns_rel , only : BESSJ use mpi implicit none integer :: is ! Species index integer :: nn ! Bessel n double precision :: bessel , besselprev , besselmax double precision :: z !Bessel Argument integer :: iperp , ipar !p_perp, p_par index integer :: max_procs logical :: maximum ! Did we find a maximum? logical :: modified_nmax ipar = 1 max_procs = nspec do is = 1 , nspec if ( usebM ( is )) then nmax ( is ) = 1 else nn = 0 besselmax = 1 0.d0 do while ( besselmax . GT . Bessel_zero ) nn = nn + 1 iperp = 0 maximum = . FALSE . bessel = 0.d0 if ( nn . GT . 1000 ) write ( * , * ) 'Bessel-function n is greater than 1000.' do while (( iperp . LT . nperp ). AND .(. NOT . maximum )) iperp = iperp + 1 z = kperp * pp ( is , iperp , ipar , 1 ) / abs ( qs ( is )) besselprev = bessel bessel = BESSJ ( nn , z ) if ( bessel . LT . besselprev ) maximum = . TRUE . enddo besselmax = bessel enddo nmax ( is ) = nn endif if ( writeOut . and . proc0 ) & write ( * , '(a,i0,a,i0,a)' ) 'Required nMax for species ' , is , ' : ' , nmax ( is ) max_procs = max_procs + nmax ( is ) enddo ! If we have too many processes, then allow for additional ns: ! The condition is that max_procs has to be greater or equal (nproc-1): is = 1 modified_nmax = . FALSE . do while ( max_procs . LT .( nproc - 1 )) if ( usebM ( is )) then else modified_nmax = . TRUE . nmax ( is ) = nmax ( is ) + 1 endif is = is + 1 max_procs = max_procs + 1 if ( is . GT . nspec ) is = 1 enddo if ( modified_nmax . AND . proc0 . AND . writeOut ) then write ( * , '(a)' ) \"More processes than required. nMax is adjusted.\" do is = 1 , nspec write ( * , '(a,i0,a,i0,a)' ) ' Adjusted nMax for Species ' , is , ' : ' , nmax ( is ) enddo endif call mpi_barrier ( mpi_comm_world , ierror ) end subroutine determine_nmax !-=-=-=-=-=-= !split the processes on different n for parallelization !-=-=-=-=-=-= subroutine split_processes () use alps_var , only : nproc , iproc , nmax , nlim use alps_var , only : nspec , sproc , writeOut , proc0 implicit none integer :: is ! Species index integer :: max_procs ! maximum number of processes (all ns for all species) integer :: ideal_ns_per_proc integer :: proc_per_spec ( nspec ) ! number of processes for each species integer :: ideal_splitting ( nspec ) ! ideal splitting for all processes associated with spec 1 integer :: splitting_rest ( nspec ) ! Rest of ideal splitting integer :: largest_rest ! Largest rest of splitting integer :: largest_spec ! This species has the largest rest integer :: used_procs ! Number of used procs integer :: proc_count , prev_proc_count ! Process Counter integer :: local_iproc ! Local process number (in species field) integer :: rest_sum max_procs = nspec ! to include the Bessel functions with n = 0 for all species do is = 1 , nspec max_procs = max_procs + nmax ( is ) enddo ideal_ns_per_proc = ceiling (( 1. * max_procs ) / ( 1. * nproc - 1. )) used_procs = 0 rest_sum = 0 ! how many processes does each species get? do is = 1 , nspec if (( nmax ( is ) + 1 ). LE . ideal_ns_per_proc ) then proc_per_spec ( is ) = 1 else proc_per_spec ( is ) = ( nmax ( is ) + 1 ) / ideal_ns_per_proc ! COULD LEAVE A REST endif ideal_splitting ( is ) = ( nmax ( is ) + 1 ) / proc_per_spec ( is ) ! is the ideal splitting of species is splitting_rest ( is ) = modulo (( nmax ( is ) + 1 ), proc_per_spec ( is )) ! Every process for species is should get as close as possible to this number! ! This is a little bit better than just using ideal_ns_per_proc ! The last one will get the rest. !  Do we have processes left? used_procs = used_procs + proc_per_spec ( is ) rest_sum = rest_sum + splitting_rest ( is ) enddo if ( proc0 . AND . writeOut ) then if ( modulo (( max_procs + rest_sum + 1 ), 2 ). EQ . 0 ) then write ( * , '(a,i0)' )& 'Ideal Number of Processors: ' , max_procs + rest_sum + 1 else write ( * , '(a,i0)' )& 'Ideal Number of Processors: ' , max_procs + rest_sum endif write ( * , '(a,i0)' ) '-=-=-=-=-=-=-=-=-=-' endif ! Find out which species has the largest rest of n's: largest_spec = 1 largest_rest = 0 do is = 1 , nspec if ( splitting_rest ( is ). GT . largest_rest ) then largest_spec = is largest_rest = splitting_rest ( is ) endif enddo ! the rest of our processes will go to species largest_spec proc_per_spec ( largest_spec ) = proc_per_spec ( largest_spec ) + (( nproc - 1 ) - used_procs ) ideal_splitting ( largest_spec ) = nint (( 1. * nmax ( largest_spec ) + 1. ) / ( 1. * proc_per_spec ( largest_spec ))) proc_count = 0 prev_proc_count = 0 do is = 1 , nspec proc_count = proc_count + proc_per_spec ( is ) if (( iproc . LE . proc_count ). AND .( iproc . GT . prev_proc_count )) then sproc = is local_iproc = ( iproc - prev_proc_count ) nlim ( 1 ) = ( local_iproc - 1 ) * ( ideal_splitting ( is )) nlim ( 2 ) = nlim ( 1 ) + ideal_splitting ( is ) - 1 if (( local_iproc . EQ . proc_per_spec ( is )). AND .( nlim ( 1 ). LE . nmax ( is ))) nlim ( 2 ) = nmax ( is ) endif prev_proc_count = proc_count enddo if ( writeOut ) & write ( * , '(a,i4,a,i4,a,i4,a,2i4,a)' ) & 'Processor ' , iproc , ' of ' , nproc , ' ready. Species ' , sproc , ': n in [' , nlim ( 1 : 2 ), ']' end subroutine split_processes ! determine bessel_array (this process only works on one species subroutine determine_bessel_array () use ALPS_var , only : pp , kperp , qs , sproc , bessel_array , nperp , nlim , iproc use ALPS_io , only : get_unused_unit use ALPS_fns_rel , only : BESSJ implicit none integer :: nn ! Bessel n !double precision :: BESSJ\t! Bessel function double precision :: z !Bessel Argument character ( 10 ) :: procwrite integer :: iperp , ipar !p_perp, p_par index !integer :: unit_bessel ipar = 1 write ( procwrite , '(i0)' ) iproc ! Allocate bessel_array: if ( allocated ( bessel_array )) deallocate ( bessel_array ) allocate ( bessel_array ( nlim ( 1 ) - 1 : nlim ( 2 ) + 1 , 0 : nperp )); bessel_array = 0.d0 !unit_bessel=1001+iproc !open(unit = unit_bessel,file = 'solution/besselArray.'//trim(procwrite)//'.out', status = 'replace') !running into an issue for low n, larger kperp, with electrons ! Fill this array with values: do nn = nlim ( 1 ) - 1 , nlim ( 2 ) + 1 do iperp = 0 , nperp z = kperp * pp ( sproc , iperp , ipar , 1 ) / qs ( sproc ) bessel_array ( nn , iperp ) = BESSJ ( nn , z ) if ( nn . EQ . - 1 ) bessel_array ( nn , iperp ) =- BESSJ ( 1 , z ) !write(unit_bessel,'(i4,i4,2es17.9)')& !     nn, iperp, z, bessel_array(nn,iperp) enddo !write(unit_bessel,*); write(unit_bessel,*) enddo !close(unit_bessel) end subroutine determine_bessel_array end module alps_fns","tags":"","loc":"sourcefile/alps_fns.f90.html"},{"title":"ALPS_var.f90 – ALPS","text":"Contents Modules alps_var Source Code ALPS_var.f90 Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_var use mpi implicit none private !I/O Variables character ( 500 ) :: runname !Root of input file name character ( 500 ) :: foldername !Directory of input file name integer :: option !System Option: Chooses Style of Run !See README file for list of options integer :: nroots !Number of Dispersion Solutions !under consideration integer :: nroots_max !Number of Dispersion Solutions !found in frequency map scan logical :: use_map !Choice of !T: searching for roots over a map in complex frequency space !OR !F: input (nroots) guesses for solutions logical :: writeOut = . true . !Write or Spress output to screen integer :: unit_error !MPI variables integer :: nproc !Number of Processors (1 to nproc) integer :: iproc !Number of local processor (0 to nproc-1) logical :: proc0 !T if iproc=0 integer :: ierror !Integer error flag !Plasma Parameters !Wave vector normalized by inverse reference inertial length double precision :: kperp !Perpendicular Wave number; double precision :: kpar !Parallel Wave number; double precision :: vA !reference Alfven Velocity /c double precision :: Bessel_zero = 1.d-45 ! Use Bessel functions until ! the maximum is less than this value !The proton typically serves as the reference species. integer :: nspec !Number of plasma species integer :: nspec_rel !Number of relativistic plasma species !Solutions for dispersion surface double complex , dimension (:), allocatable :: wroots !(1:numroots) !maximum # of roots integer :: numroots = 100 !Limits on (real, imaginary) map search double precision :: omi , omf , gami , gamf !T: log spacing for complex frequency map search !F: linear spacing for complex frequency map search logical :: loggridw , loggridg !number of points in (real, imaginary) frequency space grid integer :: ni = 128 , nr = 128 !Number of Momentum Space Grid Points integer :: nperp , npar integer :: ngamma = 100 , npparbar = 200 ! How many points in ipar should be used to calculate the principal value integral? integer :: positions_principal = 5 ! Threshold for analytical principal-value integration double precision :: Tlim = 0.01d0 ! The species number on which this process is working integer :: sproc ! Maximum number of iterations in secant method integer :: numiter = 50 ! Value of \"zero\" for secant method double precision :: D_threshold = 1.d-5 ! size of bounding region for secant method double precision :: D_prec = 1.d-5 ! size of allowable difference between roots double precision :: D_gap = 1.d-5 !pi double precision :: pi !Name of input files for distributions character ( 75 ) :: arrayName !Background Distribution Function Array !f0(1:nspec,0:nperp,0:npar) double precision , dimension (:,:,:), allocatable :: f0 double precision , dimension (:,:,:), allocatable :: f0_rel !Perpendicular and parallel Derivatives of f0 !df0(1:nspec,0:nperp,0:npar,1:2) !with index 1-> dvperp !     index 2-> dvpar double precision , dimension (:,:,:,:), allocatable :: df0 double precision , dimension (:,:,:,:), allocatable :: df0_rel !Momentum Space Array for f0 !pp(1:nspec,0:nperp,0:npar,1:2) !with index 1->vperp !     index 2->vpar double precision , dimension (:,:,:,:), allocatable :: pp double precision , dimension (:,:,:), allocatable :: gamma_rel , pparbar_rel !number of n values to sum over !nmax(1:nspec) integer , dimension (:), allocatable :: nmax !Lower and Upper limits for n values for !iproc to sum over integer :: nlim ( 2 ) !Ratios of species density double precision , dimension (:), allocatable :: ns !charge double precision , dimension (:), allocatable :: qs !and mass double precision , dimension (:), allocatable :: ms !relative to the reference value. logical , dimension (:), allocatable :: relativistic !use relativistic treatment; set for each species !Wave Equation Tensor !wave(1:3, 1:3) double complex , dimension (:,:), allocatable :: wave double complex , dimension (:,:,:), allocatable :: chi0 ! Array of Bessel functions: ! bessel_array(nlim(1):nlim(2)+1,0:nperp) double precision , dimension (:,:), allocatable :: bessel_array !Fit Parameters for Hybrid-Analytical Continuation Method integer , dimension (:), allocatable :: n_fits !number of fitted functions, per species integer , dimension (:,:), allocatable :: fit_type !type of analytic function to be fit !fit_type(1:nspec,1:maxval(nfits)) integer :: maxsteps_fit = 500 !maximum number of fitting iterations double precision :: lambda_initial_fit = 1.d0 !Inital Levenberg-Marquardt damping parameter double precision :: lambdafac_fit = 1.d1 !Adjustment factor for Levenberg-Marquardt damping parameter double precision :: epsilon_fit = 1.d-8 !Convergence for fit !Fit output !param_fit(1:nspec,nperp,4,maxval(n_fits)) double precision , dimension (:,:,:,:), allocatable :: param_fit double precision , dimension (:,:), allocatable :: perp_correction logical :: fit_check = . true . !T-> output fitted functions to ASCII file for each species logical :: determine_minima = . true . ! after map search, determine minima and refine? integer :: n_resonance_interval = 100 ! how many steps should be used to integrate around the resonance integer :: scan_option = 1 !select case for scans. !1: consecutive scans along input paths in wavevector space !2: double scans of two selected parameters integer :: n_scan = 0 !number of wavevector scans. !must be set to 2 for scan_option=2 !must be 1 or larger for scan_option=1 !n_scan=0 turns off wavevector scans logical , dimension (:), allocatable :: logfit ! Use logarithmic fitting? logical , dimension (:), allocatable :: usebM ! Use bi-Maxwellian calculation from NHDS? integer , dimension (:), allocatable :: bMnmaxs ! Maximum number of n for bi-Maxwellian calculation from NHDS double precision , dimension (:), allocatable :: bMBessel_zeros ! Besser-zero for bi-Maxwellian calculation from NHDS double precision , dimension (:), allocatable :: bMbetas ! Species beta for bi-Maxwellian calculation from NHDS double precision , dimension (:), allocatable :: bMalphas ! Species temperature anisotropy for bi-Maxwellian calculation from NHDS double precision , dimension (:), allocatable :: bMpdrifts ! Species drift momentum for bi-Maxwellian calculation from NHDS public :: scanner type :: scanner double precision :: range_i !initial value double precision :: range_f !final value logical :: log_scan !T-> log, F-> linear scan logical :: heat_s !T-> heating calc; F-> no heating logical :: eigen_s !T-> eigen calc;   F-> no eigen integer :: type_s !Type of parameter scan integer :: n_out !Number of steps integer :: n_res !scan resolution double precision :: diff , diff2 !step size for scanned parameter end type scanner !-=-=-=-=-=-=-=-=- !Defines nature of parameter scans: !     Type: 0 k_0-> k_1 !           1 theta_0 -> theta_1 !           2 k_fixed angle !     Type: 3 kperp !           4 kpar !-=-=-=-=-=-=-=-=- type ( scanner ), dimension (:), allocatable :: scan double precision :: kperp_last , kpar_last double precision :: kperp_0 , kpar_0 public :: nproc , iproc , proc0 , ierror public :: runname , foldername , option , writeOut public :: kperp , kpar , nspec , use_map , wroots public :: loggridw , loggridg , omi , omf , gami , gamf public :: arrayName , nperp , npar , f0 , pp , df0 , bessel_array public :: nmax , nlim , wave , numiter , D_threshold , D_prec , D_gap , chi0 public :: ns , qs , ms , vA , pi , Bessel_zero , sproc public :: ni , nr , positions_principal , Tlim public :: n_fits , maxsteps_fit , lambda_initial_fit , lambdafac_fit , epsilon_fit public :: param_fit , fit_check , fit_type , perp_correction public :: nroots , nroots_max , numroots public :: determine_minima , n_resonance_interval public :: unit_error , scan_option , n_scan , scan public :: kperp_last , kpar_last , kperp_0 , kpar_0 public :: relativistic , logfit , usebM public :: f0_rel , df0_rel , nspec_rel , gamma_rel , pparbar_rel , ngamma , npparbar public :: bMnmaxs , bMBessel_zeros , bMbetas , bMalphas , bMpdrifts end module alps_var","tags":"","loc":"sourcefile/alps_var.f90.html"},{"title":"Readme – ALPS","text":"A  L  P  S  Arbitrary Linear Plasma Solver This is the ALPS code: the Arbitrary Linear Plasma Solver. Authors Kristopher Klein   (kgklein@arizona.edu)\nDaniel Verscharen  (d.verscharen@ucl.ac.uk) WARNING IN ITS CURRENT FORM, THE CODE IS STILL UNDER DEVELOPMENT. WE RECOMMEND THAT YOU\nUSE IT VERY CAREFULLY OR ONLY IN DIRECT COMMUNICATION WITH THE CODE DEVELOPMENT\nTEAM. THE CODE WILL BE MADE MORE USEABLE AND SUSTAINABLE IN THE FUTURE. CONTENTS What is ALPS? Acknowledgements Installing the ALPS Code Running the ALPS Code Documentation for Input/Output Data List of Error Codes License WHAT IS ALPS? ALPS is a parallelised numerical code that solves the Vlasov-Maxwell dispersion\nrelation in hot (even relativistic) magnetised plasma. ALPS allows for any\nnumber of particle species with arbitrary gyrotropic equilibrium distribution\nfunctions supporting waves with any direction of propagation with respect to\nthe background magnetic field. If you use the code for a science publication, please provide the code website\non github.com/danielver02/ALPS and cite the code paper: Verscharen, D., Klein, K. G., Chandran, B. D. G., Stevens, M. L., Salem, C. S.,\nand Bale, S. D.: ALPS: the Arbitrary Linear Plasma Solver, J. Plasma Phys. 84,\n905840403, 2018, doi: 10.1017/S0022377818000739 ACKNOWLEDGEMENTS The development of the ALPS code was supported by NASA Grant NNX16AG81G. We will\npresent document more details about the numerics on the website\nhttp://www.alps.space. The code developers appreciate support from the UK Science\nand Technology Facilities Council (STFC) Ernest Rutherford Fellowship ST/P003826/1,\nSTFC Consolidated Grants ST/S000240/1 and ST/W001004/1, and the Open Source\nSoftware Sustainability Funding programme from UCL's Advanced Research Computing\nCentre and UCL's eResearch Domain. We appreciate software engineering support by\nDavid Stansby (UCL). INSTALLING THE ALPS CODE For advice on the installation of the code, please check INSTALL.md RUNNING THE ALPS CODE ALPS works with input files that specify the plasma and numerical parameters for\nthe calculation. We recommend that you start by checking out the provided test\ncases as a guidance for the creation of input files. These test cases are listed\nin the scripts run_test.sh and run_test_suite.sh . All associated input files have\na name starting with test_ . You can execute the ALPS code through the following command: mpirun -np <NP> ./src/ALPS <input_file.in> where <NP> is the number of processors you want to use. This number must be greater\nthan or equal to 4, and it must be an even number. <input_file.in> is the input file\nthat includes all parameters for your run. On some systems, depending on the MPI configuration, the oversubscribe flag is\nrequired. In this case, the above command must be replaced with mpirun -np <NP> --oversubscribe ./src/ALPS <input_file.in> DOCUMENTATION FOR INPUT/OUTPUT DATA Input Velocity Distribution Function folder: ./distribution (optionally created by subroutine generate_distribution distribution/generate_distribution.f90 ) file: distribution/<arrayName>.<is>.array data: pp(is,iperp,ipar,1:2) , f0(is,iperp,ipar) Fit Parameters for Hybrid Analytic Continuation folder: ./distribution created by subroutine determine_fit_parameters ( ALPS_analyt.f90 ) file: distribution/<runname>.fit_parameters.<is>.out data: iperp , params Result from Fit Routine for Hybrid Analytic Continuation folder: ./distribution created by subroutine output_fit ( ALPS_analyt.f90 ) file: distribution/<runname>.fit_parameters.<is>.out data: pp(is,iperp,ipar,1:2) , fit_result(is,iperp,ipar) , abs(fit_result(is,iperp,ipar,1:2)- f0(is,iperp,ipar))/f0(is,iperp,ipar) Map (grid in omega,gamma) of Dispersion Solutions created by subroutine map_search ( ALPS_fns.f90 ) file: solution/<runname>.map data: ir , ii , om(ir,ii) , log10(val(ir,ii)) , cal(ir,ii) Listing of Roots created by subroutine refine_guess ( ALPS_fns.f90 ) file: solution/<runname>.roots data: iw , wroots(iw) , log10(abs(tmpDisp)) , tmpDisp Scans of the Dispersion Solutions through k-space created by subroutine om_scan ( ALPS_fns.f90 ) file: solution/<runname>.scan_<option>.root_<rootnumber> data: kperp , kpar , om(ir,ii) Evaluation of the Eigen Vectors created by subroutine om_scan ( ALPS_fns.f90 ) file: solution/<runname>.eigen_<option>.root_<rootnumber> data: kperp , kpar , om(ir,ii) , ef , bf , Us , ds Evaluation of the Heating Rates created by subroutine om_scan ( ALPS_fns.f90 ) file: solution/<runname>.heat_<option>.root_<rootnumber> data: kperp , kpar , om(ir,ii) , Ps LIST OF ERROR CODES error_id = 0 - if mod ( nproc , 2 ) . ne . 0 error_id = 1 - Does requested input namelist exist ? error_id = 2 - if (( 1 + npar ) . LT . n_params ) ERRORS TO ADD: if the size of the input distribution function array is not equal to\nthe allocated distribution function array in ALPS LICENSE BSD 2-Clause License Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen\nAll rights reserved. Redistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","tags":"","loc":"page/index.html"},{"title":"Install – ALPS","text":"A  L  P  S  Arbitrary Linear Plasma Solver These are the install instructions for the ALPS code: the Arbitrary Linear\nPlasma Solver. Authors Kristopher Klein   (kgklein@arizona.edu)\nDaniel Verscharen  (d.verscharen@ucl.ac.uk) CONTENTS Requirements and Dependencies Setting up Computer Environments Getting the ALPS Code Installing the ALPS Code Execution of Test Runs REQUIREMENTS AND DEPENDENCIES ALPS has the following requirements: A UNIX, Linux, or macOS operating system with a working shell GNU make, in some cases it is useful to have the autoconf/automake tools Fortran 90 compiler (e.g., gfortran) - we recommend using the latest version\n  of the compiler to avoid any surprises in the evaluation. MPI (e.g., openmpi) - likewise, this should also be the latest version BLAS and LAPACK - these two libraries are used for the polyharmonic spline\n  interpolation in ALPS. They are directly linked during the compilation SETTING UP COMPUTER ENVIRONMENTS For Ubuntu and macOS users, the following instructions have proven to be useful.\nOn both systems, we recommend deactivating potential anaconda installations\nthat could interfere with the ALPS installation: conda deactivate On Ubuntu, the following installation routines obtain the necessary software\npackages for ALPS: sudo apt-get install -y libopenmpi-dev\nsudo apt-get install -y libopenblas-dev libblas-dev liblapack-dev If an older compiler or MPI version is still installed, it may be necessary to\ndeinstall this before using apt-get. On macOS, homebrew is a good way to install the necessary packages: brew install gcc openmpi GETTING THE ALPS CODE We recommend pulling the latest version of ALPS from GitHub. For this, go to\nthe directory where you want to install ALPS and execute the following command: git clone https://github.com/danielver02/ALPS Alternatively, you can also go to the website https://github.com/danielver02/ALPS\ndirectly and download the source code from there. The advantage of using the git\ncommand is that you can now contribute to the development of the ALPS code. If\nyou make any changes to the code, GitHub will run automatic tests (via workflows)\nto ensure that the changes do not break the code. INSTALLING THE ALPS CODE If all requirements are available, the code can be compiled with the following\ncommands: . / configure make sudo make install ( this option is only required if you want to make the ALPS executable available to all users ) The Makefile.in in the repository has been generated with automake-1.15 from Makefile.am . If you have a different version of automake , make may fail. In that case, start again with autoreconf -i -f before the execution of ./configure . EXECUTION OF TEST RUNS ALPS comes with a selection of test runs that cycle through various test\nproblems. To execute a small set of tests, execute the following shell script: ./run_test.sh This script will test the interpolation routine, the routine to generate pre-\ndescribed distribution functions, and a simply fast dispersion relation. To execute a more complete set of test problems, execute the following shell\nscript: ./run_test_suite.sh This script will test the interpolation routine and then a number of ALPS test\ncases, including the generation of the relevant distribution functions. The test\nroutine outputs time stamps during each steps to compare the speed of the ALPS\ncode and to facilitate scaling tests. For each test, the script will explain\nwhether errors occurred or not in any of the tests. The code output itself will\nbe piped into the .out and .error files in the home directory. For advice on running ALPS, please see the README file.","tags":"","loc":"page/INSTALL.html"}]}