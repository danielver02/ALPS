var tipuesearch = {"pages":[{"title":" ALPS ","text":"ALPS practices.md\n             citingpapers.md display: public\n         protected\n         private\nsource: false\ngraph: true\nincl_src: false\nsrc_dir:  ./src\n          ./interpolation\n          ./distribution\nfavicon: favicon.ico The Arbitrary Linear Plasma Solver ALPS is a parallelised numerical code that solves the Vlasov-Maxwell dispersion\nrelation in hot (even relativistic) magnetised plasma. ALPS allows for any\nnumber of particle species with arbitrary gyrotropic equilibrium distribution\nfunctions supporting waves with any direction of propagation with respect to\nthe background magnetic field. If you use the code for a science publication, please provide the code website github.com/danielver02/ALPS in the acknowledgements of your publication and cite the code paper: Verscharen, D., Klein, K. G., Chandran, B. D. G., Stevens, M. L., Salem, C. S.,\nand Bale, S. D.: ALPS: the Arbitrary Linear Plasma Solver, J. Plasma Phys. 84,\n905840403, 2018, doi: 10.1017/S0022377818000739 Publications using the ALPS code can be found in our NASA ADS Library . For first-time users, we recommend working through our ALPS Tutorial . The key input parameters for ALPS are described on the ALPS Input page. The output format of ALPS is described on the ALPS Output page. For a listing of recommendations when using ALPS, see the ALPS Best Practices page. Developer Info Kristopher Klein, Daniel Verscharen","tags":"home","url":"index.html"},{"title":"scanner – ALPS ","text":"type, public :: scanner Description of wavevector scan behavior.\nRead in from alps_io . Components Type Visibility Attributes Name Initial double precision, public :: range_i Initial scan value. double precision, public :: range_f Final scan value. logical, public :: log_scan Use log (T) or linear (F) spacing. logical, public :: heat_s Calculates heating rates if true. logical, public :: eigen_s Calculates eigenfunctions if true. integer, public :: type_s Type of parameter scan;\n0: Current value of to =range and =range .\n1: at fixed from current value of to range .\n2: Wavevector scan at fixed angle to =range .\n3: scan with constant .\n4: scan with constant . integer, public :: n_out Number of output scan values. integer, public :: n_res Resolution between output scan values. double precision, public :: diff step size for first wavevector variation. double precision, public :: diff2 step size for second wavevector variation.","tags":"","url":"type/scanner.html"},{"title":"calc_chi – ALPS","text":"public  subroutine calc_chi(chi, chi_low, j, kz, kperp, x) Uses alps_var Subroutine that calculates the susceptibility of species j based on NHDS. Arguments Type Intent Optional Attributes Name double complex, intent(out) :: chi (3,3) Susceptibility tensor of species j. double complex, intent(out) :: chi_low (3,3,-1:1) Susceptibility tensor of species j. integer, intent(in) :: j Index for species. double precision, intent(in) :: kz Normalised parallel wavenumber. double precision, intent(in) :: kperp Normalised perpendicular wavenumber. double complex, intent(in) :: x Normalised complex frequency.","tags":"","url":"proc/calc_chi.html"},{"title":"pass_instructions – ALPS","text":"public  subroutine pass_instructions() Uses alps_var mpi Passes information between processes. Arguments None","tags":"","url":"proc/pass_instructions.html"},{"title":"pass_distribution – ALPS","text":"public  subroutine pass_distribution() Uses alps_var mpi Passes distribution functions and associated parameters. Arguments None","tags":"","url":"proc/pass_distribution.html"},{"title":"disp – ALPS","text":"public  function disp(om) Uses mpi alps_var alps_fns_rel alps_nhds This function returns the determinant of the dispersion tensor for a given frequency om. Arguments Type Intent Optional Attributes Name double complex, intent(in) :: om Complex wave frequency . Return Value doublecomplex","tags":"","url":"proc/disp.html"},{"title":"full_integrate – ALPS","text":"public  function full_integrate(om, nn, mode, found_res) Uses alps_var alps_fns_rel This function returns the full integral expression according to Eq. (2.9) in the code paper. Arguments Type Intent Optional Attributes Name double complex, intent(in) :: om Complex wave frequency . integer, intent(in) :: nn Order of the Bessel function. integer, intent(in) :: mode Index of the entries in the T-tensor of Eq. (2.10). logical, intent(in) :: found_res Check whether a resonance is found. Return Value doublecomplex","tags":"","url":"proc/full_integrate.html"},{"title":"funct_g – ALPS","text":"public  function funct_g(ppar_real, iperp, om, nn, mode) Uses alps_var This function returns the function from Eq. (3.2) of the code paper. Arguments Type Intent Optional Attributes Name double precision, intent(in) :: ppar_real Real part of the momentum at which is evaluated. integer, intent(in) :: iperp Index of the perpendicular momentum. double complex, intent(in) :: om Complex wave frequency . integer, intent(in) :: nn Order of the Bessel function. integer, intent(in) :: mode Index of the entries in the T-tensor of Eq. (2.10). Return Value doublecomplex","tags":"","url":"proc/funct_g.html"},{"title":"int_ee – ALPS","text":"public  function int_ee(om) Uses alps_var This function returns the ee term in Eq. (2.9). Arguments Type Intent Optional Attributes Name double complex, intent(in) :: om Complex wave frequency . Return Value doublecomplex","tags":"","url":"proc/int_ee.html"},{"title":"rtsec – ALPS","text":"public  function rtsec(func, xin, in, iflag) Uses alps_var An alternative implementation of the secant method, adapted from PLUME. Arguments Type Intent Optional Attributes Name double complex :: func Function whose roots are to be identified.\nFor ALPS, this is the dispersion relation. double complex :: xin Initial Guess for complex frequency. integer, intent(in) :: in Root number integer :: iflag Flag for number of steps taken. Return Value doublecomplex","tags":"","url":"proc/rtsec.html"},{"title":"derivative_f0 – ALPS","text":"public  subroutine derivative_f0() Uses alps_var alps_fns_rel alps_io This subroutine calculates the perpendicular and parallel derivatives of the background velocity distribution function f0. Arguments None","tags":"","url":"proc/derivative_f0.html"},{"title":"determine_resonances – ALPS","text":"public  subroutine determine_resonances(om, nn, found_res_plus, found_res_minus) Uses alps_var alps_io This subroutine determines whether any kinetic resonances are located in the integration domain. Arguments Type Intent Optional Attributes Name double complex, intent(in) :: om Complex wave frequency . integer, intent(in) :: nn Order of Bessel function. logical, intent(out) :: found_res_plus Check whether a resonance is found at positive n. logical, intent(out) :: found_res_minus Check whether a resonance is found at negative n.","tags":"","url":"proc/determine_resonances.html"},{"title":"secant – ALPS","text":"public  subroutine secant(om, in) Uses alps_var mpi This subroutine applies the secant method to find the roots of the dispersion tensor. Arguments Type Intent Optional Attributes Name double complex, intent(inout) :: om Complex wave frequency . integer, intent(in) :: in Root number","tags":"","url":"proc/secant.html"},{"title":"secant_osc – ALPS","text":"public  subroutine secant_osc(om, in) Uses alps_var mpi Secant method with adaptive damping and Newton search fallback.\nEnsure we don’t divide by a tiny value\nCheck convergence\nDetect oscillations over last four iterations\nReduce step\nIf oscillation persists, use finite-difference Newton step\nRegularized Newton step\nApply jump limits to prevent large jumps\nCap jump at 10% of om\nIf |D| increases, reduce jump\nUpdate previous values\nApply update Arguments Type Intent Optional Attributes Name double complex, intent(inout) :: om Complex wave frequency . integer, intent(in) :: in Root number","tags":"","url":"proc/secant_osc.html"},{"title":"om_scan – ALPS","text":"public  subroutine om_scan(ik) Uses alps_var mpi alps_io This subroutine scans solutions along a single prescribed path in wavevector space.\nKGK: This line causes the solution to (occasionally)\nsmoothly transition to unphysical values.\nSuppressing until we understand the error. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik Index of scan number.","tags":"","url":"proc/om_scan.html"},{"title":"calc_eigen – ALPS","text":"public  subroutine calc_eigen(omega, electric, magnetic, vmean, ds, Ps, Ps_split, eigen_L, heat_L) Uses alps_var This subroutine calculates the relative electric and magnetic field amplitudes, the relative fluctuations in the density and velocity of all species, and the heating rates of the given solution.\nIt is based on the calc_eigen routine by Greg Howes and Kris Klein, found in PLUME.\nThe splitting by mechanisms is described in Huang, Howes, and Brown, JPP 2024,\nbut has been reformated to isolate TTD, LD, and the n=+1 and -1 CD terms separately. Arguments Type Intent Optional Attributes Name double complex, intent(in) :: omega Complex wave frequency . double complex, intent(out), dimension(1:3) :: electric Relative electric field amplitude (eigenfunction). double complex, intent(out), dimension(1:3) :: magnetic Relative magnetic field amplitude (eigenfunction). double complex, intent(out), dimension(1:3,1:nspec) :: vmean Relative velocity-fluctuation amplitude (eigenfunction). double complex, intent(out), dimension(1:nspec) :: ds Relative density-fluctuation amplitude (eigenfunction). double precision, intent(out), dimension(1:nspec) :: Ps Relative heating rate of a given species. double precision, dimension(1:4,1:nspec) :: Ps_split Relative heating rate of a given species split by component logical, intent(in) :: eigen_L Check whether eigenfunction calculation is requested. logical, intent(in) :: heat_L Check whether eigenfunction calculation is requested.","tags":"","url":"proc/calc_eigen.html"},{"title":"om_double_scan – ALPS","text":"public  subroutine om_double_scan() Uses alps_var mpi alps_io This subroutine scans along a prescribed plane in wavevector space\n to map out in this space.\n It is required that n_scan=2, and is invoked with option =2\nKGK: This line causes the solution to (occasionally)\nsmoothly transition to unphysical values.\nSuppressing until we understand the error. KGK: This line causes the solution to (occasionally)\nsmoothly transition to unphysical values.\nSuppressing until we understand the error. Arguments None","tags":"","url":"proc/om_double_scan.html"},{"title":"map_search – ALPS","text":"public  subroutine map_search() Uses alps_var mpi alps_io This subroutine calculates the map of the determinant of the dispersion tensor in complex frequency space.\ncheck check Arguments None","tags":"","url":"proc/map_search.html"},{"title":"refine_guess – ALPS","text":"public  subroutine refine_guess() Uses alps_var mpi alps_io This subroutine refines the guess at the starting point of the search for solutions to the dispersion relation when scanning. It is also used by map_search to identify the roots on the map. Arguments None","tags":"","url":"proc/refine_guess.html"},{"title":"find_minima – ALPS","text":"public  subroutine find_minima(val, numroots, iroots, nroots) Uses alps_var This subroutine identifies the minima of the coarse map grid. It is called by map_search .\nThe code is based on a routine by Greg Howes, 2006. Arguments Type Intent Optional Attributes Name double precision, intent(in), dimension(:,:), pointer :: val Array of determinant of the dispersion tensor. integer, intent(in) :: numroots Number of roots. integer, intent(out), dimension(1:2,1:numroots) :: iroots Indices of roots. integer, intent(out) :: nroots Number of roots found.","tags":"","url":"proc/find_minima.html"},{"title":"determine_nmax – ALPS","text":"public  subroutine determine_nmax() Uses mpi alps_var alps_fns_rel This subroutine determines the maximum required order of the Bessel functions in Eq. (2.9) of the code paper. Arguments None","tags":"","url":"proc/determine_nmax.html"},{"title":"split_processes – ALPS","text":"public  subroutine split_processes() Uses alps_var mpi This subroutine defines the tasks for the individual processes. It uses the number of species and the required orders of the Bessel functions to define the splitting across the MPI processes. Arguments None","tags":"","url":"proc/split_processes.html"},{"title":"determine_bessel_array – ALPS","text":"public  subroutine determine_bessel_array() Uses alps_var alps_fns_rel alps_io This subroutine determines the array of Bessel functions that is used in the T-tensor of Eq. (2.10) of the code paper. Arguments None","tags":"","url":"proc/determine_bessel_array.html"},{"title":"integrate_res_rel – ALPS","text":"public  function integrate_res_rel(om, nn, mode) Uses alps_var This function performs the integration near resonances as described in Section 3.1 of the code paper for a relativistic calculation. It is only called if resonances are present in or near the integration domain. Arguments Type Intent Optional Attributes Name double complex, intent(in) :: om Complex wave frequency . integer, intent(in) :: nn Order of the Bessel function. integer, intent(in) :: mode Index of the entries in the T-tensor of Eq. (2.10). Return Value doublecomplex","tags":"","url":"proc/integrate_res_rel.html"},{"title":"principal_integral_rel – ALPS","text":"public  function principal_integral_rel(sproc_rel, om, nn, mode, igamma, ipparbar_res, upperlimit) Uses alps_var This function performs the integration near resonances as described in Section 3.1 of the code paper for a relativistic calculation. It is only called if resonances are present in or near the integration domain. Arguments Type Intent Optional Attributes Name integer, intent(in) :: sproc_rel is_rel of the current process. double complex, intent(in) :: om Complex wave frequency . integer, intent(in) :: nn Order of the Bessel function. integer, intent(in) :: mode Index of the entries in the T-tensor of Eq. (2.10). integer, intent(in) :: igamma Index to loop over . integer, intent(in) :: ipparbar_res Index of the nearest relativistic parallel momentum to the resonance. integer, intent(in) :: upperlimit Index of upper limit for integration according to Eq. (3.5). Return Value doublecomplex","tags":"","url":"proc/principal_integral_rel.html"},{"title":"landau_integrate_rel – ALPS","text":"public  function landau_integrate_rel(om, nn, mode) Uses alps_analyt alps_var This function evaluates the Landau contour according to Eqs. (3.8) and (3.9) of the code paper for a relativistic calculation. Arguments Type Intent Optional Attributes Name double complex, intent(in) :: om Complex wave frequency . integer, intent(in) :: nn Order of the Bessel function. integer, intent(in) :: mode Index of the entries in the T-tensor of Eq. (2.10). Return Value doublecomplex","tags":"","url":"proc/landau_integrate_rel.html"},{"title":"int_ee_rel – ALPS","text":"public  function int_ee_rel(om) Uses alps_var This function returns the ee term in Eq. (2.9) for the relativistic calculation. Arguments Type Intent Optional Attributes Name double complex, intent(in) :: om Complex wave frequency . Return Value doublecomplex","tags":"","url":"proc/int_ee_rel.html"},{"title":"resU_rel – ALPS","text":"public  function resU_rel(sproc_rel, om, nn, igamma, ipparbar) Uses alps_var This function evaluates the term proportional to in Eq. (2.9) of the code paper for the relativistic calculation. Arguments Type Intent Optional Attributes Name integer, intent(in) :: sproc_rel is_rel of the current process. double complex, intent(in) :: om Complex wave frequency . integer, intent(in) :: nn Order of the Bessel function. integer, intent(in) :: igamma Index to loop over . integer, intent(in) :: ipparbar Index to loop over relativistic parallel momentum. Return Value doublecomplex","tags":"","url":"proc/resu_rel.html"},{"title":"BESSJ – ALPS","text":"public  function BESSJ(N, X) This function calculates the first kind Bessel function\nof integer order N, for any REAL X. We use here the classical\nrecursion formula, when X > N. For X < N, Miller's algorithm\nis used to avoid overflows. Reference:\nC.W.Clenshaw, Chebyshev Series for Mathematical Functions, Mathematical Tables, Vol. 5, 1962. Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Order of Bessel function. double precision, intent(in) :: X Argument of the Bessel function. Return Value doubleprecision","tags":"","url":"proc/bessj.html"},{"title":"BESSJ0 – ALPS","text":"public  function BESSJ0(X) This function calculates the first kind Bessel function\nof order 0, for any REAL X. The polynomial approximation by\nseries of Chebyshev polynomials is used for 0<X<8 and 0<8/X<1. References:\nM.Abramowitz, I.A.Stegun, Handbook of Mathematical Functions, 1965. C.W.Clenshaw, Chebyshev Series for Mathematical Functions, Mathematical Tables, Vol. 5, 1962. Arguments Type Intent Optional Attributes Name double precision, intent(in) :: X Argument of the Bessel function. Return Value doubleprecision","tags":"","url":"proc/bessj0.html"},{"title":"BESSJ1 – ALPS","text":"public  function BESSJ1(X) This subroutine calculates the First Kind Bessel Function of\norder 1, for any real number X. The polynomial approximation by\nseries of Chebyshev polynomials is used for 0<X<8 and 0<8/X<1. References:\nM.Abramowitz, I.A.Stegun, Handbook of Mathematical Functions, 1965. C.W.Clenshaw, Chebyshev Series for Mathematical Functions, Mathematical Tables, Vol. 5, 1962. Arguments Type Intent Optional Attributes Name double precision, intent(in) :: X Argument of the Bessel function. Return Value doubleprecision","tags":"","url":"proc/bessj1.html"},{"title":"Gamma – ALPS","text":"public  function Gamma(xx) This function returns the Gamma-function. Arguments Type Intent Optional Attributes Name double precision :: xx Argument of the Gamma-function. Return Value doubleprecision","tags":"","url":"proc/gamma.html"},{"title":"derivative_f0_rel – ALPS","text":"public  subroutine derivative_f0_rel(is, is_rel) Uses alps_var alps_io This subroutine calculates the derivatives of the background velocity distribution function f0 for the relativistic calculation. Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Index of particle species. integer, intent(in) :: is_rel Index for relativistic species (if any).","tags":"","url":"proc/derivative_f0_rel.html"},{"title":"polyharmonic_spline – ALPS","text":"public  subroutine polyharmonic_spline(grid_coarse, gamma_coarse, pparbar_coarse, n_coarse, gamma_rel, pparbar, ngamma, npparbar, smoothing, f0_rel, is_rel, nspec_rel) This soubroutine interpolates the grid with a polyharmonic thin-plate spline.\nThis subroutine needs the LUPACK and BLAS libraries to evoke the dgesv subroutine.\nThe method uses the Thin Plate Spline.\nWe use these resources: http://cseweb.ucsd.edu/~sjb/eccv_tps.pdf http://www.univie.ac.at/nuhag-php/bibtex/open_files/po94_M%20J%20D%20Powell%2003%2093.pdf http://vision.ucsd.edu/sites/default/files/fulltext(4).pdf Arguments Type Intent Optional Attributes Name double precision, intent(in) :: grid_coarse (n_coarse) Coarse input grid for interpolation. double precision, intent(in) :: gamma_coarse (n_coarse) Coordinates of on coarse grid. double precision, intent(in) :: pparbar_coarse (n_coarse) Coordinates of relativistic parallel momentum on coarse grid. integer, intent(in) :: n_coarse Number of entries in coarse grid. double precision, intent(in) :: gamma_rel (nspec_rel,0:ngamma,0:npparbar) Coordinates of on fine grid. double precision, intent(in) :: pparbar (nspec_rel,0:ngamma,0:npparbar) Coordinates of relativistic parallel momentum on fine grid. integer, intent(in) :: ngamma Number of steps on fine output grid. integer, intent(in) :: npparbar Number of parallel momentum steps on fine output grid. double precision, intent(in) :: smoothing Smoothing parameter for spline interpolation. double precision, intent(out) :: f0_rel (nspec_rel,0:ngamma,0:npparbar) Fine output grid after interpolation. integer :: is_rel Index for relativistic species (if any). integer :: nspec_rel Number of relativistic species.","tags":"","url":"proc/polyharmonic_spline.html"},{"title":"CBESSJ – ALPS","text":"public  subroutine CBESSJ(z, nu, z1) This subroutine calculates the complex Bessel function. It is based on the CBESSJ function release 1.1 by J-P Moreau, Paris (www.jpmoreau.fr). Arguments Type Intent Optional Attributes Name double complex, intent(in) :: z Argument of the Bessel function. integer, intent(in) :: nu Order of Bessel function. double complex, intent(out) :: z1 Resulting value of Bessel function.","tags":"","url":"proc/cbessj.html"},{"title":"isnancheck – ALPS","text":"public  function isnancheck(input) Checks if double precision number input is NaN. Arguments Type Intent Optional Attributes Name double precision :: input Variable to be checked. Return Value logical","tags":"","url":"proc/isnancheck.html"},{"title":"init_param – ALPS","text":"public  subroutine init_param() Uses alps_var Read in system parameters from *.in file.\nOnly processor 0 calls this routine: Arguments None Namelists Namelist system Variables Name Type Default Description kperp double precision None Perpendicular wavenumber, normalized by\ninverse reference inertial length, . kpar double precision None Parallel wavenumber, normalized by\ninverse reference inertial length, . nspec integer None Number of plasma components. nroots integer None Number of dispersion solutions under consideration. use_map logical None Choice of:\n (T) searching for roots over a map in complex frequency space,\n via map_read ;\n (F) input (nroots) guesses for solutions,\n via solution_read writeOut logical .true. Write or suppress output to screen. nperp integer None Number of perpendicular momentum space grid points, . npar integer None Number of parallel momentum space grid points, . ngamma integer 100 Number of grid points in relativitic , (Eqn. 3.14). npparbar integer 200 Number of grid points in dimensionless paralell momentum , . vA double precision None Alfven Velocity, normalized to speed of light, . arrayName character(len=75) None Name of input files for distributions. Bessel_zero double precision 1.d-45 Calculate Bessel functions until the maximum is less than this value. secant_method integer 2 Selection of root finding method.\n0: secant\n1: rtsec\n2: secant_osc: an improvement to reduce oscillatory loops. numiter integer 50 Maximum number of iterations in secant method. kperp_norm logical .true. Use the tensor in Stix's (10-57) (true)\nor\nMultiply by kperp&#94;2 d_ref&#94;2 (false) D_threshold double precision 1.d-5 Minimum threshold for secant method. D_prec double precision 1.d-5 Size of bounding region for secant method. D_gap double precision 1.d-5 Size of allowable difference between roots. D_tol double precision 1.d-7 Tolerance for secant method=1, alps_fn positions_principal integer 5 Number of parallel momentum steps distant from the resonant momentum\nincluded in the numerical calculation of Eqn 3.5, . Tlim double precision 0.01d0 Threshold for analytical principal-value integration for\nevaluating Eqn 3.6 and 3.7, . maxsteps_fit integer 500 Maximum number of fitting iterations. lambda_initial_fit double precision 1.d0 Inital Levenberg-Marquardt damping parameter. lambdafac_fit double precision 1.d1 Adjustment factor for Levenberg-Marquardt damping parameter. epsilon_fit double precision 1.d-8 Convergence for Levenberg-Marquardt fit. fit_check logical .true. If true, output fitted functions to ASCII file for each species. determine_minima logical .true. If true, after map search, determine minima and refine solutions. n_resonance_interval integer 100 How many steps should be used to integrate around the resonance, , used for integrating near poles (see section 3.1). scan_option integer 1 Select case for scans;\n1) consecutive scans along input paths in wavevector space,\n2) double scans of two selected parameters. n_scan integer 0 Number of wavevector scans.\nMust be set to 2 for scan_option=2;\nMust be 1 or larger for scan_option=1.\n0 turns off wavevector scans.","tags":"","url":"proc/init_param.html"},{"title":"fit_read – ALPS","text":"public  subroutine fit_read(is, ifit) Uses alps_var Reads in fit parameters for component is. Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Species index. integer, intent(in) :: ifit Namelists Namelist ffit Variables Name Type Default Description fit_type_in integer None Read in value for type of analytic function. fit_1 double precision None Read in values for fit component 1. fit_2 double precision None Read in values for fit component 2. fit_3 double precision None Read in values for fit component 3. fit_4 double precision None Read in values for fit component 4. fit_5 double precision None Read in values for fit component 5. perpcorr double precision None Perpendicular correction to compensate for exponential\ndependency of drift to make fit more reliable\n[ in Eqn B1 of Verscharen et al 2018].","tags":"","url":"proc/fit_read.html"},{"title":"read_f0 – ALPS","text":"public  subroutine read_f0() Uses alps_var Subroutine for reading in background distribution function Arguments None","tags":"","url":"proc/read_f0.html"},{"title":"get_indexed_double_namelist_unit – ALPS","text":"public  subroutine get_indexed_double_namelist_unit(unit, nml, spec_in, index_in) Uses alps_var A version of get_indexed_namelist_unit , extended\nto allow for double indexing in order to read in multiple fits\nfor a single species. Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit Unit to be defined. character(len=*), intent(in) :: nml Character string for namelist to be read in. integer, intent(in) :: spec_in First index of namelist to be read in. integer, intent(in) :: index_in Second index of namelist to be read in.","tags":"","url":"proc/get_indexed_double_namelist_unit.html"},{"title":"get_unused_unit – ALPS","text":"public  subroutine get_unused_unit(unit) Determine unused number for I/O index. Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit Unit to be assigned.","tags":"","url":"proc/get_unused_unit.html"},{"title":"alps_error_init – ALPS","text":"public  subroutine alps_error_init() Uses alps_var Open a file for the error log. Arguments None","tags":"","url":"proc/alps_error_init.html"},{"title":"alps_error – ALPS","text":"public  subroutine alps_error(error_id) Uses alps_var mpi Error catching subroutine. Arguments Type Intent Optional Attributes Name integer :: error_id Index of error message.","tags":"","url":"proc/alps_error.html"},{"title":"output_time – ALPS","text":"public  subroutine output_time() Outputs the date and time in a given format using intrinsic\nFORTRAN function. Arguments None","tags":"","url":"proc/output_time.html"},{"title":"display_credits – ALPS","text":"public  subroutine display_credits() Writes the opening credits. Arguments None","tags":"","url":"proc/display_credits.html"},{"title":"eval_fit – ALPS","text":"public  function eval_fit(is, iperp, ppar_valC) Uses alps_var alps_distribution_analyt This function evaluates the fit to f0 at and the complex parallel\nmomentum ppar_valC. It requires the fit parameters that will be determined\nby the subroutine determine_param_fit . Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Index of species for which eval_fit is executed. integer, intent(in) :: iperp Index of perpendicular momentum at which eval_fit is executed. double complex, intent(in) :: ppar_valC Complex parallel momentum at which eval_fit is executed. Return Value doublecomplex","tags":"","url":"proc/eval_fit.html"},{"title":"fit_function_poly – ALPS","text":"public  function fit_function_poly(is, iperp, ppar_val, n_poly, fit_coeffs) Uses alps_var This function evaluates the orthogonal polynomical fit to f0\n at real pperp_val and complex ppar_val,\n with the one-dimensional polynomical coefficient array fit_coeffs is fed into the\n function.\n For the evaluation in ALPS, use eval_fit .\nkgk: should this be .gt. or .ge. ? Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Index of species for which eval_fit is executed. integer, intent(in) :: iperp Index of perpendicular momentum at which fit_function_poly is executed. double complex :: ppar_val Complex parallel momentum. integer :: n_poly Maximum Polynomial Order double precision, intent(in) :: fit_coeffs (0:n_poly) Array of polynomial coefficients Return Value doublecomplex","tags":"","url":"proc/fit_function_poly.html"},{"title":"determine_param_fit – ALPS","text":"public  subroutine determine_param_fit() Uses alps_var This is the fitting routine for the hybrid analytic continuation. It determines\nthe full field param_fit . Arguments None","tags":"","url":"proc/determine_param_fit.html"},{"title":"least_squares_fit – ALPS","text":"public  subroutine least_squares_fit(AA, BB, coeffs, npoly) Uses alps_var Solves General Linear Least Squares Normal Equation Arguments Type Intent Optional Attributes Name double precision, intent(in) :: AA (0:npar,0:npoly) Polynomial Basis double precision, intent(in) :: BB (0:npar) f0(is,iperp,:) double precision, intent(out) :: coeffs (0:npoly) fit coefficients integer :: npoly Order for polyhedral representation","tags":"","url":"proc/least_squares_fit.html"},{"title":"alps_var – ALPS","text":"Contains all global variables. Uses mpi Variables Type Visibility Attributes Name Initial character(len=500), public :: runname Root of input file name. character(len=500), public :: foldername Directory of input file name. integer, public :: nroots Number of dispersion solutions under consideration. integer, public :: nroots_max Number of dispersion solutions found in frequency map scan. logical, public :: use_map Choice of:\n (T) searching for roots over a map in complex frequency space,\n via map_read ;\n (F) input (nroots) guesses for solutions,\n via solution_read logical, public :: kperp_norm = .true. Use the tensor in Stix's (10-57) (true)\nor\nMultiply by kperp&#94;2 d_ref&#94;2 (false) logical, public :: writeOut = .true. Write or suppress output to screen. integer, public :: unit_error Output unit for error file. integer, public :: nproc Total number of processors. integer, public :: iproc Number of local processor. logical, public :: proc0 T if iproc=0. integer, public :: ierror Integer error flag. double precision, public :: kperp Perpendicular wavenumber, normalized by\ninverse reference inertial length, . double precision, public :: kpar Parallel wavenumber, normalized by\ninverse reference inertial length, . double precision, public :: vA Alfven Velocity, normalized to speed of light, . double precision, public :: Bessel_zero = 1.d-45 Calculate Bessel functions until the maximum is less than this value. integer, public :: nspec Number of plasma components. integer, public :: nspec_rel Number of relativistic plasma components. double complex, public, dimension(:), allocatable :: wroots Dispersion solutions, ranging from 1 to numroots. integer, public :: numroots = 100 Maximum number of solutions. double precision, public :: omi Smallest value for complex map search. double precision, public :: omf Largest value for complex map search. double precision, public :: gami Smallest value for complex map search. double precision, public :: gamf Largest value for complex map search. logical, public :: loggridw Linear (F) or Log (T) spacing for map search. logical, public :: loggridg Linear (F) or Log (T) spacing for map search. integer, public :: nr = 128 Number of points in frequency grid. integer, public :: ni = 128 Number of points in frequency grid. integer, public :: nperp Number of perpendicular momentum space grid points, . integer, public :: npar Number of parallel momentum space grid points, . integer, public :: ngamma = 100 Number of grid points in relativitic , (Eqn. 3.14). integer, public :: npparbar = 200 Number of grid points in dimensionless paralell momentum , . integer, public :: positions_principal = 5 Number of parallel momentum steps distant from the resonant momentum\nincluded in the numerical calculation of Eqn 3.5, . double precision, public :: Tlim = 0.01d0 Threshold for analytical principal-value integration for\nevaluating Eqn 3.6 and 3.7, . integer, public :: sproc The species number on which this process is working. integer, public :: secant_method = 2 Selection of root finding method.\n0: secant\n1: rtsec\n2: secant_osc: an improvement to reduce oscillatory loops. integer, public :: numiter = 50 Maximum number of iterations in secant method. double precision, public :: D_threshold = 1.d-5 Minimum threshold for secant method. double precision, public :: D_prec = 1.d-5 Size of bounding region for secant method. double precision, public :: D_gap = 1.d-5 Size of allowable difference between roots. double precision, public :: D_tol = 1.d-7 Tolerance for secant method=1, alps_fn double precision, public :: pi The ratio of a circle's circumference to its diameter. character(len=75), public :: arrayName Name of input files for distributions. double precision, public, dimension(:,:,:), allocatable :: f0 Background distribution function array ;\n(1:nspec,0:nperp,0:npar). double precision, public, dimension(:,:,:), allocatable :: f0_rel Relativistic background distribution function array ;\n(1:nspec,0:ngamma,0:npparbar). double precision, public, dimension(:,:,:,:), allocatable :: df0 Perpendicular and parallel derivatives of ;\n(1:nspec,0:nperp,0:npar,1:2),\nwith in index 1,\nand in index 2. double precision, public, dimension(:,:,:,:), allocatable :: df0_rel Derivatives of ;\n(1:nspec,0:nperp,0:npar,1:2),\nwith in index 1\nand in index 2. double precision, public, dimension(:,:,:,:), allocatable :: pp Momentum Space Array for ;\n(1:nspec,0:nperp,0:npar,1:2)\nwith in index 1\nand in index 2. double precision, public, dimension(:), allocatable :: current_int Current density, (0:nspec)\nZeroth index is sum over all species double precision, public, dimension(:), allocatable :: density_int density, (0:nspec)\nZeroth index is sum over all species double precision, public, dimension(:,:,:), allocatable :: gamma_rel Relativistic momentum space array of ;\n(1:nspec,0:ngamma,0:npparbar). double precision, public, dimension(:,:,:), allocatable :: pparbar_rel Relativistic momentum space array of ;\n(1:nspec,0:ngamma,0:npparbar). integer, public, dimension(:), allocatable :: nmax number of n values to sum over, (1:nspec). integer, public :: nlim (2) Lower and Upper limits for n values for iproc to sum over. double precision, public, dimension(:), allocatable :: ns Ratio of species density to reference , (1:nspec). double precision, public, dimension(:), allocatable :: qs Ratio of species charge to reference , (1:nspec). double precision, public, dimension(:), allocatable :: ms Ratio of species mass to reference , (1:nspec). logical, public, dimension(:), allocatable :: relativistic Use relativistic treatment; (1:nspec). double complex, public, dimension(:,:), allocatable :: wave Wave Equation Tensor (1:3,1:3). double complex, public, dimension(:,:,:), allocatable :: chi0 Susceptibility Tensor (1:nspec,1:3,1:3). double complex, public, dimension(:,:,:,:), allocatable :: chi0_low Susceptibility Tensor (1:nspec,1:3,1:3,0:1). double precision, public, dimension(:,:), allocatable :: bessel_array Array of Bessel functions; (nlim(1):nlim(2)+1,0:nperp). integer, public, dimension(:), allocatable :: ACmethod Selection of method for Hybrid-Analytical Continutation, (1:nspec)\n 0) Use the analytic function.\n 1) Use the 'n_fits' functions described with 'fit_type'\n 2) Use a polynomial basis representation. double precision, public, dimension(:,:,:), allocatable :: polynomials Polynomials of order (0,poly_order) evaluatated at (0,npar) abscissa points,\n(1:nspec,0:npar,0:poly_order)\npoly_order is taken to be the maximum order across all species. double precision, public, dimension(:,:,:), allocatable :: poly_fit_coeffs Fit Coefficients for Polynomials from Generarl Linear Least Squares Method\n(1:nspec,0:nperp,0:poly_order)\npoly_order is taken to be the maximum order across all species.\nThe fit is taken in one dimension at each perpendicular momentum value. integer, public, dimension(:), allocatable :: poly_kind Selection of Orthogonal Basis Function, (1:nspec)\n 1) Chebyshev Polynomials\n Other Polynomials can be added in future releases. double precision, public, dimension(:), allocatable :: poly_log_max Limit on the Evaluation of the Polynomial Representation, (1:nspec) integer, public, dimension(:), allocatable :: poly_order Selection of Maximum Order of Orthogonal Basis Function, (1:nspec) integer, public, dimension(:), allocatable :: n_fits Number of fitted functions, (1:nspec) integer, public, dimension(:,:), allocatable :: fit_type Type of analytic function to be fit, (1:nspec,1:maxval(nfits));\n1) Maxwellian,\n2) Kappa,\n3) Juettner with ,\n4) Juettner with , constant ,\n5) Juettner with ; variable ,\n6) Bi-Moyal distribution. integer, public :: maxsteps_fit = 500 Maximum number of fitting iterations. double precision, public :: lambda_initial_fit = 1.d0 Inital Levenberg-Marquardt damping parameter. double precision, public :: lambdafac_fit = 1.d1 Adjustment factor for Levenberg-Marquardt damping parameter. double precision, public :: epsilon_fit = 1.d-8 Convergence for Levenberg-Marquardt fit. double precision, public, dimension(:,:,:,:), allocatable :: param_fit Fit parameters, (1:nspec,0:nperp,4,maxval(n_fits)). double precision, public, dimension(:,:), allocatable :: perp_correction This parameter, in Eqn. B1, compensates for the strong dependence of , making the fit more reliable. logical, public :: fit_check = .true. If true, output fitted functions to ASCII file for each species. logical, public :: determine_minima = .true. If true, after map search, determine minima and refine solutions. integer, public :: n_resonance_interval = 100 How many steps should be used to integrate around the resonance, , used for integrating near poles (see section 3.1). integer, public :: scan_option = 1 Select case for scans;\n1) consecutive scans along input paths in wavevector space,\n2) double scans of two selected parameters. integer, public :: n_scan = 0 Number of wavevector scans.\nMust be set to 2 for scan_option=2;\nMust be 1 or larger for scan_option=1.\n0 turns off wavevector scans. logical, public, dimension(:), allocatable :: logfit Use logarithmic fitting, (1:nspec). logical, public, dimension(:), allocatable :: usebM Use bi-Maxwellian/cold calculation from NHDS, (1:nspec). integer, public, dimension(:), allocatable :: bMnmaxs Maximum number of n for NHDS bi-Maxwellian calculation, (1:nspec). double precision, public, dimension(:), allocatable :: bMBessel_zeros Bessel-zero for NHDS bi-Maxwellian calculation (1:nspec). double precision, public, dimension(:), allocatable :: bMbetas Species beta for\nNHDS bi-Maxwellian calculation (1:nspec).\nIf bMbetas=0.d0, then this species is treated with the cold-plasma susceptibility. double precision, public, dimension(:), allocatable :: bMalphas Species temperature anisotropy for NHDS bi-Maxwellian calculation. double precision, public, dimension(:), allocatable :: bMpdrifts Species drift momentum for NHDS bi-Maxwellian/cold calculation,\nin units of (1:nspec). type( scanner ), public, dimension (:), allocatable :: scan Scan parameters for each wavevector scan.\n Read in from alps_io . double precision, public :: kperp_last Previous value of . double precision, public :: kpar_last Previous value of . double precision, public :: kperp_0 Current value of . double precision, public :: kpar_0 Current value of . Derived Types type, public :: scanner Description of wavevector scan behavior.\nRead in from alps_io . Components Type Visibility Attributes Name Initial double precision, public :: range_i Initial scan value. double precision, public :: range_f Final scan value. logical, public :: log_scan Use log (T) or linear (F) spacing. logical, public :: heat_s Calculates heating rates if true. logical, public :: eigen_s Calculates eigenfunctions if true. integer, public :: type_s Type of parameter scan;\n0: Current value of to =range and =range .\n1: at fixed from current value of to range .\n2: Wavevector scan at fixed angle to =range .\n3: scan with constant .\n4: scan with constant . integer, public :: n_out Number of output scan values. integer, public :: n_res Resolution between output scan values. double precision, public :: diff step size for first wavevector variation. double precision, public :: diff2 step size for second wavevector variation.","tags":"","url":"module/alps_var.html"},{"title":"alps_nhds – ALPS","text":"Module including the NHDS implementation for bi-Maxwellian/cold-plasma reference cases.\nThe original NHDS code can be found under github.com/danielver02/NHDS. Subroutines public  subroutine calc_chi (chi, chi_low, j, kz, kperp, x) Subroutine that calculates the susceptibility of species j based on NHDS. Arguments Type Intent Optional Attributes Name double complex, intent(out) :: chi (3,3) Susceptibility tensor of species j. double complex, intent(out) :: chi_low (3,3,-1:1) Susceptibility tensor of species j. integer, intent(in) :: j Index for species. double precision, intent(in) :: kz Normalised parallel wavenumber. double precision, intent(in) :: kperp Normalised perpendicular wavenumber. double complex, intent(in) :: x Normalised complex frequency.","tags":"","url":"module/alps_nhds.html"},{"title":"alps_com – ALPS","text":"Subroutines public  subroutine pass_instructions () Passes information between processes. Arguments None public  subroutine pass_distribution () Passes distribution functions and associated parameters. Arguments None","tags":"","url":"module/alps_com.html"},{"title":"alps_fns – ALPS","text":"This module contains the key numerical functions of ALPS. Functions public  function disp (om) This function returns the determinant of the dispersion tensor for a given frequency om. Arguments Type Intent Optional Attributes Name double complex, intent(in) :: om Complex wave frequency . Return Value doublecomplex public  function full_integrate (om, nn, mode, found_res) This function returns the full integral expression according to Eq. (2.9) in the code paper. Arguments Type Intent Optional Attributes Name double complex, intent(in) :: om Complex wave frequency . integer, intent(in) :: nn Order of the Bessel function. integer, intent(in) :: mode Index of the entries in the T-tensor of Eq. (2.10). logical, intent(in) :: found_res Check whether a resonance is found. Return Value doublecomplex public  function funct_g (ppar_real, iperp, om, nn, mode) This function returns the function from Eq. (3.2) of the code paper. Arguments Type Intent Optional Attributes Name double precision, intent(in) :: ppar_real Real part of the momentum at which is evaluated. integer, intent(in) :: iperp Index of the perpendicular momentum. double complex, intent(in) :: om Complex wave frequency . integer, intent(in) :: nn Order of the Bessel function. integer, intent(in) :: mode Index of the entries in the T-tensor of Eq. (2.10). Return Value doublecomplex public  function int_ee (om) This function returns the ee term in Eq. (2.9). Arguments Type Intent Optional Attributes Name double complex, intent(in) :: om Complex wave frequency . Return Value doublecomplex public  function rtsec (func, xin, in, iflag) An alternative implementation of the secant method, adapted from PLUME. Arguments Type Intent Optional Attributes Name double complex :: func Function whose roots are to be identified.\nFor ALPS, this is the dispersion relation. double complex :: xin Initial Guess for complex frequency. integer, intent(in) :: in Root number integer :: iflag Flag for number of steps taken. Return Value doublecomplex Subroutines public  subroutine derivative_f0 () This subroutine calculates the perpendicular and parallel derivatives of the background velocity distribution function f0. Arguments None public  subroutine determine_resonances (om, nn, found_res_plus, found_res_minus) This subroutine determines whether any kinetic resonances are located in the integration domain. Arguments Type Intent Optional Attributes Name double complex, intent(in) :: om Complex wave frequency . integer, intent(in) :: nn Order of Bessel function. logical, intent(out) :: found_res_plus Check whether a resonance is found at positive n. logical, intent(out) :: found_res_minus Check whether a resonance is found at negative n. public  subroutine secant (om, in) This subroutine applies the secant method to find the roots of the dispersion tensor. Arguments Type Intent Optional Attributes Name double complex, intent(inout) :: om Complex wave frequency . integer, intent(in) :: in Root number public  subroutine secant_osc (om, in) Secant method with adaptive damping and Newton search fallback.\nEnsure we don’t divide by a tiny value\nCheck convergence\nDetect oscillations over last four iterations\nReduce step\nIf oscillation persists, use finite-difference Newton step\nRegularized Newton step\nApply jump limits to prevent large jumps\nCap jump at 10% of om\nIf |D| increases, reduce jump\nUpdate previous values\nApply update Arguments Type Intent Optional Attributes Name double complex, intent(inout) :: om Complex wave frequency . integer, intent(in) :: in Root number public  subroutine om_scan (ik) This subroutine scans solutions along a single prescribed path in wavevector space.\nKGK: This line causes the solution to (occasionally)\nsmoothly transition to unphysical values.\nSuppressing until we understand the error. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ik Index of scan number. public  subroutine calc_eigen (omega, electric, magnetic, vmean, ds, Ps, Ps_split, eigen_L, heat_L) This subroutine calculates the relative electric and magnetic field amplitudes, the relative fluctuations in the density and velocity of all species, and the heating rates of the given solution.\nIt is based on the calc_eigen routine by Greg Howes and Kris Klein, found in PLUME.\nThe splitting by mechanisms is described in Huang, Howes, and Brown, JPP 2024,\nbut has been reformated to isolate TTD, LD, and the n=+1 and -1 CD terms separately. Arguments Type Intent Optional Attributes Name double complex, intent(in) :: omega Complex wave frequency . double complex, intent(out), dimension(1:3) :: electric Relative electric field amplitude (eigenfunction). double complex, intent(out), dimension(1:3) :: magnetic Relative magnetic field amplitude (eigenfunction). double complex, intent(out), dimension(1:3,1:nspec) :: vmean Relative velocity-fluctuation amplitude (eigenfunction). double complex, intent(out), dimension(1:nspec) :: ds Relative density-fluctuation amplitude (eigenfunction). double precision, intent(out), dimension(1:nspec) :: Ps Relative heating rate of a given species. double precision, dimension(1:4,1:nspec) :: Ps_split Relative heating rate of a given species split by component logical, intent(in) :: eigen_L Check whether eigenfunction calculation is requested. logical, intent(in) :: heat_L Check whether eigenfunction calculation is requested. public  subroutine om_double_scan () This subroutine scans along a prescribed plane in wavevector space\n to map out in this space.\n It is required that n_scan=2, and is invoked with option =2\nKGK: This line causes the solution to (occasionally)\nsmoothly transition to unphysical values.\nSuppressing until we understand the error. Read more… Arguments None public  subroutine map_search () This subroutine calculates the map of the determinant of the dispersion tensor in complex frequency space.\ncheck Read more… Arguments None public  subroutine refine_guess () This subroutine refines the guess at the starting point of the search for solutions to the dispersion relation when scanning. It is also used by map_search to identify the roots on the map. Arguments None public  subroutine find_minima (val, numroots, iroots, nroots) This subroutine identifies the minima of the coarse map grid. It is called by map_search .\nThe code is based on a routine by Greg Howes, 2006. Arguments Type Intent Optional Attributes Name double precision, intent(in), dimension(:,:), pointer :: val Array of determinant of the dispersion tensor. integer, intent(in) :: numroots Number of roots. integer, intent(out), dimension(1:2,1:numroots) :: iroots Indices of roots. integer, intent(out) :: nroots Number of roots found. public  subroutine determine_nmax () This subroutine determines the maximum required order of the Bessel functions in Eq. (2.9) of the code paper. Arguments None public  subroutine split_processes () This subroutine defines the tasks for the individual processes. It uses the number of species and the required orders of the Bessel functions to define the splitting across the MPI processes. Arguments None public  subroutine determine_bessel_array () This subroutine determines the array of Bessel functions that is used in the T-tensor of Eq. (2.10) of the code paper. Arguments None","tags":"","url":"module/alps_fns.html"},{"title":"alps_fns_rel – ALPS","text":"This module contains the relativistic numerical functions of ALPS. Functions public  function integrate_res_rel (om, nn, mode) This function performs the integration near resonances as described in Section 3.1 of the code paper for a relativistic calculation. It is only called if resonances are present in or near the integration domain. Arguments Type Intent Optional Attributes Name double complex, intent(in) :: om Complex wave frequency . integer, intent(in) :: nn Order of the Bessel function. integer, intent(in) :: mode Index of the entries in the T-tensor of Eq. (2.10). Return Value doublecomplex public  function principal_integral_rel (sproc_rel, om, nn, mode, igamma, ipparbar_res, upperlimit) This function performs the integration near resonances as described in Section 3.1 of the code paper for a relativistic calculation. It is only called if resonances are present in or near the integration domain. Arguments Type Intent Optional Attributes Name integer, intent(in) :: sproc_rel is_rel of the current process. double complex, intent(in) :: om Complex wave frequency . integer, intent(in) :: nn Order of the Bessel function. integer, intent(in) :: mode Index of the entries in the T-tensor of Eq. (2.10). integer, intent(in) :: igamma Index to loop over . integer, intent(in) :: ipparbar_res Index of the nearest relativistic parallel momentum to the resonance. integer, intent(in) :: upperlimit Index of upper limit for integration according to Eq. (3.5). Return Value doublecomplex public  function landau_integrate_rel (om, nn, mode) This function evaluates the Landau contour according to Eqs. (3.8) and (3.9) of the code paper for a relativistic calculation. Arguments Type Intent Optional Attributes Name double complex, intent(in) :: om Complex wave frequency . integer, intent(in) :: nn Order of the Bessel function. integer, intent(in) :: mode Index of the entries in the T-tensor of Eq. (2.10). Return Value doublecomplex public  function int_ee_rel (om) This function returns the ee term in Eq. (2.9) for the relativistic calculation. Arguments Type Intent Optional Attributes Name double complex, intent(in) :: om Complex wave frequency . Return Value doublecomplex public  function resU_rel (sproc_rel, om, nn, igamma, ipparbar) This function evaluates the term proportional to in Eq. (2.9) of the code paper for the relativistic calculation. Arguments Type Intent Optional Attributes Name integer, intent(in) :: sproc_rel is_rel of the current process. double complex, intent(in) :: om Complex wave frequency . integer, intent(in) :: nn Order of the Bessel function. integer, intent(in) :: igamma Index to loop over . integer, intent(in) :: ipparbar Index to loop over relativistic parallel momentum. Return Value doublecomplex public  function BESSJ (N, X) This function calculates the first kind Bessel function\nof integer order N, for any REAL X. We use here the classical\nrecursion formula, when X > N. For X < N, Miller's algorithm\nis used to avoid overflows. Reference:\nC.W.Clenshaw, Chebyshev Series for Mathematical Functions, Mathematical Tables, Vol. 5, 1962. Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Order of Bessel function. double precision, intent(in) :: X Argument of the Bessel function. Return Value doubleprecision public  function BESSJ0 (X) This function calculates the first kind Bessel function\nof order 0, for any REAL X. The polynomial approximation by\nseries of Chebyshev polynomials is used for 0<X<8 and 0<8/X<1. References:\nM.Abramowitz, I.A.Stegun, Handbook of Mathematical Functions, 1965. C.W.Clenshaw, Chebyshev Series for Mathematical Functions, Mathematical Tables, Vol. 5, 1962. Arguments Type Intent Optional Attributes Name double precision, intent(in) :: X Argument of the Bessel function. Return Value doubleprecision public  function BESSJ1 (X) This subroutine calculates the First Kind Bessel Function of\norder 1, for any real number X. The polynomial approximation by\nseries of Chebyshev polynomials is used for 0<X<8 and 0<8/X<1. References:\nM.Abramowitz, I.A.Stegun, Handbook of Mathematical Functions, 1965. C.W.Clenshaw, Chebyshev Series for Mathematical Functions, Mathematical Tables, Vol. 5, 1962. Arguments Type Intent Optional Attributes Name double precision, intent(in) :: X Argument of the Bessel function. Return Value doubleprecision public  function Gamma (xx) This function returns the Gamma-function. Arguments Type Intent Optional Attributes Name double precision :: xx Argument of the Gamma-function. Return Value doubleprecision Subroutines public  subroutine derivative_f0_rel (is, is_rel) This subroutine calculates the derivatives of the background velocity distribution function f0 for the relativistic calculation. Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Index of particle species. integer, intent(in) :: is_rel Index for relativistic species (if any). public  subroutine polyharmonic_spline (grid_coarse, gamma_coarse, pparbar_coarse, n_coarse, gamma_rel, pparbar, ngamma, npparbar, smoothing, f0_rel, is_rel, nspec_rel) This soubroutine interpolates the grid with a polyharmonic thin-plate spline.\nThis subroutine needs the LUPACK and BLAS libraries to evoke the dgesv subroutine.\nThe method uses the Thin Plate Spline.\nWe use these resources: http://cseweb.ucsd.edu/~sjb/eccv_tps.pdf http://www.univie.ac.at/nuhag-php/bibtex/open_files/po94_M%20J%20D%20Powell%2003%2093.pdf http://vision.ucsd.edu/sites/default/files/fulltext(4).pdf Arguments Type Intent Optional Attributes Name double precision, intent(in) :: grid_coarse (n_coarse) Coarse input grid for interpolation. double precision, intent(in) :: gamma_coarse (n_coarse) Coordinates of on coarse grid. double precision, intent(in) :: pparbar_coarse (n_coarse) Coordinates of relativistic parallel momentum on coarse grid. integer, intent(in) :: n_coarse Number of entries in coarse grid. double precision, intent(in) :: gamma_rel (nspec_rel,0:ngamma,0:npparbar) Coordinates of on fine grid. double precision, intent(in) :: pparbar (nspec_rel,0:ngamma,0:npparbar) Coordinates of relativistic parallel momentum on fine grid. integer, intent(in) :: ngamma Number of steps on fine output grid. integer, intent(in) :: npparbar Number of parallel momentum steps on fine output grid. double precision, intent(in) :: smoothing Smoothing parameter for spline interpolation. double precision, intent(out) :: f0_rel (nspec_rel,0:ngamma,0:npparbar) Fine output grid after interpolation. integer :: is_rel Index for relativistic species (if any). integer :: nspec_rel Number of relativistic species. public  subroutine CBESSJ (z, nu, z1) This subroutine calculates the complex Bessel function. It is based on the CBESSJ function release 1.1 by J-P Moreau, Paris (www.jpmoreau.fr). Arguments Type Intent Optional Attributes Name double complex, intent(in) :: z Argument of the Bessel function. integer, intent(in) :: nu Order of Bessel function. double complex, intent(out) :: z1 Resulting value of Bessel function.","tags":"","url":"module/alps_fns_rel.html"},{"title":"alps_io – ALPS","text":"Controls input and output functions to and from main program. Variables Type Visibility Attributes Name Initial integer, public :: unit Index for file I/O. integer, public, parameter :: stdout_unit = 6 Standard unit for I/O. integer, public, save :: input_unit_no Saved input unit for use with multiple read in calls. integer, public, save :: error_unit_no = stdout_unit Error output unit. Functions public  function isnancheck (input) Checks if double precision number input is NaN. Arguments Type Intent Optional Attributes Name double precision :: input Variable to be checked. Return Value logical Subroutines public  subroutine init_param () Read in system parameters from *.in file.\nOnly processor 0 calls this routine: Arguments None public  subroutine fit_read (is, ifit) Reads in fit parameters for component is. Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Species index. integer, intent(in) :: ifit public  subroutine read_f0 () Subroutine for reading in background distribution function Arguments None public  subroutine get_indexed_double_namelist_unit (unit, nml, spec_in, index_in) A version of get_indexed_namelist_unit , extended\nto allow for double indexing in order to read in multiple fits\nfor a single species. Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit Unit to be defined. character(len=*), intent(in) :: nml Character string for namelist to be read in. integer, intent(in) :: spec_in First index of namelist to be read in. integer, intent(in) :: index_in Second index of namelist to be read in. public  subroutine get_unused_unit (unit) Determine unused number for I/O index. Arguments Type Intent Optional Attributes Name integer, intent(out) :: unit Unit to be assigned. public  subroutine alps_error_init () Open a file for the error log. Arguments None public  subroutine alps_error (error_id) Error catching subroutine. Arguments Type Intent Optional Attributes Name integer :: error_id Index of error message. public  subroutine output_time () Outputs the date and time in a given format using intrinsic\nFORTRAN function. Arguments None public  subroutine display_credits () Writes the opening credits. Arguments None","tags":"","url":"module/alps_io.html"},{"title":"alps_analyt – ALPS","text":"This module contains functions and subroutines for the hybrid analytical continuation. Functions public  function eval_fit (is, iperp, ppar_valC) This function evaluates the fit to f0 at and the complex parallel\nmomentum ppar_valC. It requires the fit parameters that will be determined\nby the subroutine determine_param_fit . Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Index of species for which eval_fit is executed. integer, intent(in) :: iperp Index of perpendicular momentum at which eval_fit is executed. double complex, intent(in) :: ppar_valC Complex parallel momentum at which eval_fit is executed. Return Value doublecomplex public  function fit_function_poly (is, iperp, ppar_val, n_poly, fit_coeffs) This function evaluates the orthogonal polynomical fit to f0\n at real pperp_val and complex ppar_val,\n with the one-dimensional polynomical coefficient array fit_coeffs is fed into the\n function.\n For the evaluation in ALPS, use eval_fit .\nkgk: should this be .gt. or .ge. ? Arguments Type Intent Optional Attributes Name integer, intent(in) :: is Index of species for which eval_fit is executed. integer, intent(in) :: iperp Index of perpendicular momentum at which fit_function_poly is executed. double complex :: ppar_val Complex parallel momentum. integer :: n_poly Maximum Polynomial Order double precision, intent(in) :: fit_coeffs (0:n_poly) Array of polynomial coefficients Return Value doublecomplex Subroutines public  subroutine determine_param_fit () This is the fitting routine for the hybrid analytic continuation. It determines\nthe full field param_fit . Arguments None public  subroutine least_squares_fit (AA, BB, coeffs, npoly) Solves General Linear Least Squares Normal Equation Arguments Type Intent Optional Attributes Name double precision, intent(in) :: AA (0:npar,0:npoly) Polynomial Basis double precision, intent(in) :: BB (0:npar) f0(is,iperp,:) double precision, intent(out) :: coeffs (0:npoly) fit coefficients integer :: npoly Order for polyhedral representation","tags":"","url":"module/alps_analyt.html"},{"title":"alps – ALPS","text":"Uses alps_fns alps_io alps_analyt mpi alps_var alps_com Variables Type Attributes Name Initial integer :: ik Index for iterating through wavevector scans with om_scan or om_double_scan","tags":"","url":"program/alps.html"},{"title":"  system – ALPS\n","text":"Variables Name Type Default Description kperp double precision None Perpendicular wavenumber, normalized by\ninverse reference inertial length, . kpar double precision None Parallel wavenumber, normalized by\ninverse reference inertial length, . nspec integer None Number of plasma components. nroots integer None Number of dispersion solutions under consideration. use_map logical None Choice of:\n (T) searching for roots over a map in complex frequency space,\n via map_read ;\n (F) input (nroots) guesses for solutions,\n via solution_read writeOut logical .true. Write or suppress output to screen. nperp integer None Number of perpendicular momentum space grid points, . npar integer None Number of parallel momentum space grid points, . ngamma integer 100 Number of grid points in relativitic , (Eqn. 3.14). npparbar integer 200 Number of grid points in dimensionless paralell momentum , . vA double precision None Alfven Velocity, normalized to speed of light, . arrayName character(len=75) None Name of input files for distributions. Bessel_zero double precision 1.d-45 Calculate Bessel functions until the maximum is less than this value. secant_method integer 2 Selection of root finding method.\n0: secant\n1: rtsec\n2: secant_osc: an improvement to reduce oscillatory loops. numiter integer 50 Maximum number of iterations in secant method. kperp_norm logical .true. Use the tensor in Stix's (10-57) (true)\nor\nMultiply by kperp&#94;2 d_ref&#94;2 (false) D_threshold double precision 1.d-5 Minimum threshold for secant method. D_prec double precision 1.d-5 Size of bounding region for secant method. D_gap double precision 1.d-5 Size of allowable difference between roots. D_tol double precision 1.d-7 Tolerance for secant method=1, alps_fn positions_principal integer 5 Number of parallel momentum steps distant from the resonant momentum\nincluded in the numerical calculation of Eqn 3.5, . Tlim double precision 0.01d0 Threshold for analytical principal-value integration for\nevaluating Eqn 3.6 and 3.7, . maxsteps_fit integer 500 Maximum number of fitting iterations. lambda_initial_fit double precision 1.d0 Inital Levenberg-Marquardt damping parameter. lambdafac_fit double precision 1.d1 Adjustment factor for Levenberg-Marquardt damping parameter. epsilon_fit double precision 1.d-8 Convergence for Levenberg-Marquardt fit. fit_check logical .true. If true, output fitted functions to ASCII file for each species. determine_minima logical .true. If true, after map search, determine minima and refine solutions. n_resonance_interval integer 100 How many steps should be used to integrate around the resonance, , used for integrating near poles (see section 3.1). scan_option integer 1 Select case for scans;\n1) consecutive scans along input paths in wavevector space,\n2) double scans of two selected parameters. n_scan integer 0 Number of wavevector scans.\nMust be set to 2 for scan_option=2;\nMust be 1 or larger for scan_option=1.\n0 turns off wavevector scans.","tags":"","url":"namelist/system.html"},{"title":"  maps – ALPS\n","text":"Variables Name Type Default Description loggridw logical None Linear (F) or Log (T) spacing for map search. loggridg logical None Linear (F) or Log (T) spacing for map search. omi double precision None Smallest value for complex map search. omf double precision None Largest value for complex map search. gami double precision None Smallest value for complex map search. gamf double precision None Largest value for complex map search. ni integer 128 Number of points in frequency grid. nr integer 128 Number of points in frequency grid.","tags":"","url":"namelist/maps.html"},{"title":"  guess – ALPS\n","text":"Variables Name Type Default Description g_om double precision None Guess for real solution . g_gam double precision None Guess for imaginary solution .","tags":"","url":"namelist/guess.html"},{"title":"  spec – ALPS\n","text":"Variables Name Type Default Description nn double precision None Read in value for relative density for . qq double precision None Read in value for charge for . mm double precision None Read in value for mass for . AC_method double precision None Read in value for Analytic Continuation Method ff integer None Read in value for number of fitted functions. relat logical .false. Treat species as non-relativistic or relativistic. log_fit logical .true. Use linear or fitting routine. use_bM logical .false. Use actual numerical integration or bi-Maxwellian/cold-plasma proxy via NHDS.","tags":"","url":"namelist/spec.html"},{"title":"  poly_spec – ALPS\n","text":"Variables Name Type Default Description kind integer None Selection of Orthogonal Basis Function\n1) Chebyshev polynomials order integer None Maximum order of Polynomial log_max double precision None Maximum Value of Polynomial Evaluation","tags":"","url":"namelist/poly_spec.html"},{"title":"  bM_spec – ALPS\n","text":"Variables Name Type Default Description bM_nmaxs integer None Maximum number of resonances to consider. bM_Bessel_zeros double precision None Precision threshold for . bM_betas double precision None of biMaxwellian distribution .\n If bM_betas=0.d0, this species is treated with the cold-plasma susceptibilities. bM_alphas double precision None of biMaxwellian distribution . bM_pdrifts double precision None Relative drift of biMaxwellian distribution ,\nin units of . Also used as the drift of the cold-plasma species\n if bM_betas is set to 0.d0.","tags":"","url":"namelist/bm_spec.html"},{"title":"  scan_input – ALPS\n","text":"Variables Name Type Default Description scan_type integer None Determine kind of wavevector scan. swi double precision None Initial Scan Value. swf double precision None Final Scan Value. swlog logical None or linear scan spacing. ns integer None Number of output scan values. nres integer None Resolution between output scan values. heating logical None Activate heating calculation. eigen logical None Activate eigenfunction calculation.","tags":"","url":"namelist/scan_input.html"},{"title":"  ffit – ALPS\n","text":"Variables Name Type Default Description fit_type_in integer None Read in value for type of analytic function. fit_1 double precision None Read in values for fit component 1. fit_2 double precision None Read in values for fit component 2. fit_3 double precision None Read in values for fit component 3. fit_4 double precision None Read in values for fit component 4. fit_5 double precision None Read in values for fit component 5. perpcorr double precision None Perpendicular correction to compensate for exponential\ndependency of drift to make fit more reliable\n[ in Eqn B1 of Verscharen et al 2018].","tags":"","url":"namelist/ffit.html"},{"title":"ALPS_var.f90 – ALPS","text":"Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_var !!Contains all global variables. use mpi implicit none private !I/O Variables: character ( 500 ) :: runname !!Root of input file name. character ( 500 ) :: foldername !!Directory of input file name. integer :: nroots !!Number of dispersion solutions under consideration. integer :: nroots_max !!Number of dispersion solutions found in frequency map scan. logical :: use_map !!Choice of: !! (T) searching for roots over a map in complex frequency space, !! via [[map_read(subroutine)]]; !! (F) input (nroots) guesses for solutions, !! via [[solution_read(subroutine)]] logical :: kperp_norm = . true . !! Use the tensor in Stix's (10-57) (true) !! or !! Multiply by kperp&#94;2 d_ref&#94;2 (false) logical :: writeOut = . true . !! Write or suppress output to screen. integer :: unit_error !! Output unit for error file. !MPI variables: integer :: nproc !! Total number of processors. integer :: iproc !! Number of local processor. logical :: proc0 !! T if iproc=0. integer :: ierror !! Integer error flag. !Plasma Parameters: double precision :: kperp !! Perpendicular wavenumber, normalized by !! inverse reference inertial length, k_\\perp d_p. double precision :: kpar !! Parallel wavenumber, normalized by !! inverse reference inertial length, k_\\parallel d_p. double precision :: vA !! Alfven Velocity, normalized to speed of light, v_{Ap}/c. double precision :: Bessel_zero = 1.d-45 !! Calculate Bessel functions until the maximum is less than this value. integer :: nspec !!Number of plasma components. integer :: nspec_rel !!Number of relativistic plasma components. double complex , dimension (:), allocatable :: wroots !(1:numroots) !!Dispersion solutions, ranging from 1 to numroots. integer :: numroots = 100 !! Maximum number of solutions. double precision :: omi !!Smallest \\omega_{\\textrm{r}}/\\Omega_p value for complex map search. double precision :: omf !!Largest \\omega_{\\textrm{r}}/\\Omega_p value for complex map search. double precision :: gami !!Smallest \\gamma/\\Omega_p value for complex map search. double precision :: gamf !!Largest \\gamma/\\Omega_p value for complex map search. logical :: loggridw !!Linear (F) or Log (T) spacing for \\omega_{\\textrm{r}}/\\Omega_p map search. logical :: loggridg !!Linear (F) or Log (T) spacing for \\gamma/\\Omega_p map search. integer :: nr = 128 !!Number of \\omega_{\\textrm{r}}/\\Omega_p points in frequency grid. integer :: ni = 128 !!Number of \\gamma/\\Omega_p points in frequency grid. integer :: nperp !!Number of perpendicular momentum space grid points, N_\\perp. integer :: npar !!Number of parallel momentum space grid points, N_\\parallel. integer :: ngamma = 100 !!Number of grid points in relativitic \\Gamma=\\sqrt{1+\\frac{p_\\perp&#94;2+p_\\parallel&#94;2}{m_j&#94;2c&#94;2}}, !!N_\\Gamma (Eqn. 3.14). integer :: npparbar = 200 !!Number of grid points in dimensionless paralell momentum !!\\bar{p}_\\parallel = p_\\parallel/m_j c, N_{\\bar{p}_\\parallel}. integer :: positions_principal = 5 !! Number of parallel momentum steps distant from the resonant momentum !! included in the numerical calculation of Eqn 3.5, M_I. double precision :: Tlim = 0.01d0 !! Threshold for analytical principal-value integration for !! evaluating Eqn 3.6 and 3.7, t_{\\textrm{lim}}. integer :: sproc !! The species number on which this process is working. integer :: secant_method = 2 !! Selection of root finding method. !! 0: secant !! 1: rtsec !! 2: secant_osc: an improvement to reduce oscillatory loops. integer :: numiter = 50 !! Maximum number of iterations in secant method. double precision :: D_threshold = 1.d-5 !! Minimum threshold for secant method. double precision :: D_prec = 1.d-5 !! Size of bounding region for secant method. double precision :: D_gap = 1.d-5 !! Size of allowable difference between roots. double precision :: D_tol = 1.d-7 !! Tolerance for secant method=1, [[alps_fn(module):rtsec(subroutine)]] double precision :: pi !! The ratio of a circle's circumference to its diameter. character ( 75 ) :: arrayName !! Name of input files for distributions. double precision , dimension (:,:,:), allocatable :: f0 !! Background distribution function array f_{0j}; !! (1:nspec,0:nperp,0:npar). double precision , dimension (:,:,:), allocatable :: f0_rel !! Relativistic background distribution function array f_{0j}; !! (1:nspec,0:ngamma,0:npparbar). double precision , dimension (:,:,:,:), allocatable :: df0 !!Perpendicular and parallel derivatives of f_{0j}; !!(1:nspec,0:nperp,0:npar,1:2), !!with \\partial_{p_\\perp} f_{0j}  in index 1, !!and \\partial_{p_\\parallel} f_{0j}  in index 2. double precision , dimension (:,:,:,:), allocatable :: df0_rel !!Derivatives of f_{0j}; !!(1:nspec,0:nperp,0:npar,1:2), !!with \\partial_{\\Gamma} f_{0j}  in index 1 !!and \\partial_{\\bar{p}_\\parallel} f_{0j}  in index 2. double precision , dimension (:,:,:,:), allocatable :: pp !!Momentum Space Array for f_{0j}; !!(1:nspec,0:nperp,0:npar,1:2) !!with p_\\perp/m_p v_A in index 1 !!and p_\\parallel/m_p v_A in index 2. double precision , dimension (:), allocatable :: current_int !! Current density, (0:nspec) !! Zeroth index is sum over all species double precision , dimension (:), allocatable :: density_int !! density, (0:nspec) !! Zeroth index is sum over all species double precision , dimension (:,:,:), allocatable :: gamma_rel !!Relativistic momentum space array of \\Gamma; !!(1:nspec,0:ngamma,0:npparbar). double precision , dimension (:,:,:), allocatable :: pparbar_rel !!Relativistic momentum space array of \\bar{p}_\\parallel; !!(1:nspec,0:ngamma,0:npparbar). integer , dimension (:), allocatable :: nmax !!number of n values to sum over, (1:nspec). integer :: nlim ( 2 ) !!Lower and Upper limits for n values for iproc to sum over. double precision , dimension (:), allocatable :: ns !!Ratio of species density to reference n_j/n_p, (1:nspec). double precision , dimension (:), allocatable :: qs !!Ratio of species charge to reference q_j/q_p, (1:nspec). double precision , dimension (:), allocatable :: ms !!Ratio of species mass to reference m_j/m_p, (1:nspec). logical , dimension (:), allocatable :: relativistic !!Use relativistic treatment; (1:nspec). double complex , dimension (:,:), allocatable :: wave !!Wave Equation Tensor (1:3,1:3). double complex , dimension (:,:,:), allocatable :: chi0 !!Susceptibility Tensor (1:nspec,1:3,1:3). double complex , dimension (:,:,:,:), allocatable :: chi0_low !!Susceptibility Tensor (1:nspec,1:3,1:3,0:1). double precision , dimension (:,:), allocatable :: bessel_array !! Array of Bessel functions; (nlim(1):nlim(2)+1,0:nperp). integer , dimension (:), allocatable :: ACmethod !!Selection of method for Hybrid-Analytical Continutation, (1:nspec) !! 0) Use the analytic function. !! 1) Use the 'n_fits' functions described with 'fit_type' !! 2) Use a polynomial basis representation. double precision , dimension (:,:,:), allocatable :: polynomials !! Polynomials of order (0,poly_order) evaluatated at (0,npar) abscissa points, !! (1:nspec,0:npar,0:poly_order) !! poly_order is taken to be the maximum order across all species. double precision , dimension (:,:,:), allocatable :: poly_fit_coeffs !! Fit Coefficients for Polynomials from Generarl Linear Least Squares Method !! (1:nspec,0:nperp,0:poly_order) !! poly_order is taken to be the maximum order across all species. !! The fit is taken in one dimension at each perpendicular momentum value. integer , dimension (:), allocatable :: poly_kind !!Selection of Orthogonal Basis Function, (1:nspec) !! 1) Chebyshev Polynomials !! Other Polynomials can be added in future releases. double precision , dimension (:), allocatable :: poly_log_max !!Limit on the Evaluation of the Polynomial Representation, (1:nspec) integer , dimension (:), allocatable :: poly_order !! Selection of Maximum Order of Orthogonal Basis Function, (1:nspec) !Fit Parameters for Hybrid-Analytical Continuation Method: integer , dimension (:), allocatable :: n_fits !!Number of fitted functions, (1:nspec) integer , dimension (:,:), allocatable :: fit_type !! Type of analytic function to be fit, (1:nspec,1:maxval(nfits)); !! 1) Maxwellian, !! 2) Kappa, !! 3) Juettner with p_\\perp,p_\\parallel, !! 4) Juettner with \\Gamma,\\bar{p}_\\parallel, constant \\bar{p}_\\parallel, !! 5) Juettner with p_\\perp,p_\\parallel; variable \\bar{p}_\\parallel, !! 6) Bi-Moyal distribution. integer :: maxsteps_fit = 500 !!Maximum number of fitting iterations. double precision :: lambda_initial_fit = 1.d0 !!Inital Levenberg-Marquardt damping parameter. double precision :: lambdafac_fit = 1.d1 !!Adjustment factor for Levenberg-Marquardt damping parameter. double precision :: epsilon_fit = 1.d-8 !!Convergence for Levenberg-Marquardt fit. !Fit output: double precision , dimension (:,:,:,:), allocatable :: param_fit !!Fit parameters, (1:nspec,0:nperp,4,maxval(n_fits)). double precision , dimension (:,:), allocatable :: perp_correction !!This parameter, y in Eqn. B1, compensates for the strong !! p_\\perp dependence of u_1, making the fit more reliable. logical :: fit_check = . true . !!If true, output fitted functions to ASCII file for each species. logical :: determine_minima = . true . !!If true, after map search, determine minima and refine solutions. integer :: n_resonance_interval = 100 !! How many steps should be used to integrate around the resonance, !!M_P, used for integrating near poles (see section 3.1). integer :: scan_option = 1 !!Select case for scans; !!1) consecutive scans along input paths in wavevector space, !!2) double scans of two selected parameters. integer :: n_scan = 0 !!Number of wavevector scans. !!Must be set to 2 for scan_option=2; !!Must be 1 or larger for scan_option=1. !!0 turns off wavevector scans. logical , dimension (:), allocatable :: logfit !! Use logarithmic fitting, (1:nspec). logical , dimension (:), allocatable :: usebM !! Use bi-Maxwellian/cold calculation from NHDS, (1:nspec). integer , dimension (:), allocatable :: bMnmaxs !! Maximum number of n for NHDS bi-Maxwellian calculation, (1:nspec). double precision , dimension (:), allocatable :: bMBessel_zeros !! Bessel-zero for NHDS bi-Maxwellian calculation (1:nspec). double precision , dimension (:), allocatable :: bMbetas !! Species beta \\beta_{\\parallel,j} for !! NHDS bi-Maxwellian calculation (1:nspec). !! If bMbetas=0.d0, then this species is treated with the cold-plasma susceptibility. double precision , dimension (:), allocatable :: bMalphas !! Species temperature anisotropy T_{\\perp,j}/T_{\\parallel,j} !! for NHDS bi-Maxwellian calculation. double precision , dimension (:), allocatable :: bMpdrifts !! Species drift momentum for NHDS bi-Maxwellian/cold calculation, !! in units of m_p v_A (1:nspec). public :: scanner type :: scanner !! Description of wavevector scan behavior. !! Read in from [[alps_io(module):scan_read(subroutine)]]. double precision :: range_i !! Initial scan value. double precision :: range_f !! Final scan value. logical :: log_scan !! Use log (T) or linear (F) spacing. logical :: heat_s !! Calculates heating rates if true. logical :: eigen_s ! !! Calculates eigenfunctions if true. integer :: type_s !!Type of parameter scan; !!0: Current value of \\textbf{k} to !! k_\\perp=range_\\textrm{i} and k_\\parallel =range_\\textrm{f}. !!1: \\theta_0 \\rightarrow \\theta_1 at fixed |k| !! from current value of \\theta=\\mathrm{atan}(k_\\perp/k_\\parallel) !! to range_\\textrm{f}. !!2: Wavevector scan at fixed angle \\theta_{k,B} to |k|=range_\\textrm{f}. !!3: k_\\perp scan with constant k_\\parallel. !!4: k_\\parallel scan with constant k_\\perp. integer :: n_out !!Number of output scan values. integer :: n_res !!Resolution between output scan values. double precision :: diff !!step size for first wavevector variation. double precision :: diff2 !!step size for second wavevector variation. end type scanner type ( scanner ), dimension (:), allocatable :: scan !!Scan parameters for each wavevector scan. !! Read in from [[alps_io(module):scan_read(subroutine)]]. double precision :: kperp_last !! Previous value of k_\\perp. double precision :: kpar_last !! Previous value of k_\\parallel. double precision :: kperp_0 !! Current value of k_\\perp. double precision :: kpar_0 !! Current value of k_\\parallel. public :: nproc , iproc , proc0 , ierror public :: runname , foldername , writeOut public :: kperp , kpar , nspec , use_map , wroots public :: kperp_norm public :: loggridw , loggridg , omi , omf , gami , gamf public :: arrayName , nperp , npar , f0 , pp , df0 , bessel_array public :: current_int , density_int public :: nmax , nlim , wave , numiter , chi0 , chi0_low public :: D_threshold , D_prec , D_gap , D_tol public :: ns , qs , ms , vA , pi , Bessel_zero , sproc public :: ni , nr , positions_principal , Tlim public :: n_fits , maxsteps_fit , lambda_initial_fit , lambdafac_fit , epsilon_fit public :: param_fit , fit_check , fit_type , perp_correction public :: nroots , nroots_max , numroots public :: determine_minima , n_resonance_interval public :: unit_error , scan_option , n_scan , scan public :: kperp_last , kpar_last , kperp_0 , kpar_0 public :: secant_method , relativistic , logfit , usebM public :: f0_rel , df0_rel , nspec_rel , gamma_rel , pparbar_rel , ngamma , npparbar public :: bMnmaxs , bMBessel_zeros , bMbetas , bMalphas , bMpdrifts public :: ACmethod , poly_kind , poly_order , polynomials , poly_fit_coeffs public :: poly_log_max end module alps_var","tags":"","url":"sourcefile/alps_var.f90.html"},{"title":"ALPS_NHDS.f90 – ALPS","text":"Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_nhds !! Module including the NHDS implementation for bi-Maxwellian/cold-plasma reference cases. !! The original NHDS code can be found under github.com/danielver02/NHDS. implicit none private :: calc_ypsilon , besselI , BESSI , BESSI0 , BESSI1 , WOFZ , dispfunct , calc_chi_cold public :: calc_chi contains ! This file is part of NHDS ! Copyright (C) 2024 Daniel Verscharen (d.verscharen@ucl.ac.uk) !All rights reserved. ! !Redistribution and use in source and binary forms, with or without !modification, are permitted provided that the following conditions are met: ! !1. Redistributions of source code must retain the above copyright notice, this !   list of conditions and the following disclaimer. !2. Redistributions in binary form must reproduce the above copyright notice, !   this list of conditions and the following disclaimer in the documentation !   and/or other materials provided with the distribution. ! !THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND !ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED !WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE !DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR !ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES !(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; !LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND !ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT !(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS !SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! !The views and conclusions contained in the software and documentation are those !of the authors and should not be interpreted as representing official policies, !either expressed or implied, of the NHDS project. !2025-05-28: We are multiplying all of the elements of chi by kperp&#94;2 d_p&#94;2, to make the solution more stable. subroutine calc_chi ( chi , chi_low , j , kz , kperp , x ) !! Subroutine that calculates the susceptibility of species j based on NHDS. use alps_var , only : bMnmaxs , bMBessel_zeros , bMbetas , bMalphas , bMpdrifts use alps_var , only : ms , qs , ns use alps_var , only : kperp_norm implicit none double complex , intent ( out ) :: chi ( 3 , 3 ) !! Susceptibility tensor of species j. double complex , intent ( out ) :: chi_low ( 3 , 3 , - 1 : 1 ) !! Susceptibility tensor of species j. integer , intent ( in ) :: j !! Index for species. double precision , intent ( in ) :: kz !! Normalised parallel wavenumber. double precision , intent ( in ) :: kperp !! Normalised perpendicular wavenumber. double complex , intent ( in ) :: x !! Normalised complex frequency. double complex :: Y ( 3 , 3 ) !! Y-tensor according to Stix. double complex :: Y0 ( 3 , 3 ) !! n=0 contribution to Y-tensor according to Stix. double complex :: Y1 ( 3 , 3 ) !! n=+ 1 contribution to Y-tensor according to Stix. double complex :: Yn1 ( 3 , 3 ) !! n=- 1 contribution to Y-tensor according to Stix. double complex :: Ynew ( 3 , 3 ) !! Iteration of Y-tensor according to Stix. double precision :: z !! Argument of dispersion function. double precision :: Omega !! Normalised gyro-frequency. double precision :: ell !! Normalised inertial length. double precision :: vtherm !! Normalised thermal speed. double precision :: Bessel_zero !! Limit of Bessel-function calculation. double precision :: vdrift !! Normalised drift speed of bi-Maxwellian/cold population. integer :: n !! Index of sum over Bessel functions. integer :: i !! Index running over tensor. integer :: k !! Index running over tensor. integer :: nmaxrun !! Running to maximum index of n for Bessel functions. integer :: nmax !! Maximum index of n for Bessel functions. logical :: Bessel_run !! Check whether maximum n has been achieved. ! Check if you can use the cold-plasma dispersion relation: if ( bMbetas ( j ). EQ . 0.d0 ) then call calc_chi_cold ( chi , j , kz , kperp , x ) !No LD, TTD, or CD contribution from a cold species chi_low = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) else Omega = qs ( j ) / ms ( j ) ell = sqrt ( ms ( j ) / ( ns ( j ) * qs ( j ) * qs ( j ))) vtherm = sqrt ( bMbetas ( j ) / ( ns ( j ) * ms ( j ))) vdrift = bMpdrifts ( j ) / ms ( j ) nmax = bMnmaxs ( j ) Bessel_zero = bMBessel_zeros ( j ) z = 0.5d0 * ( kperp * vtherm / Omega ) * ( kperp * vtherm / Omega ) * bMalphas ( j ) do i = 1 , 3 do k = 1 , 3 Y ( i , k ) = 0.d0 Y0 ( i , k ) = 0.d0 Y1 ( i , k ) = 0.d0 Yn1 ( i , k ) = 0.d0 enddo enddo !determine maximum n for Besselfunction: nmaxrun = nmax n = 0 Bessel_run = . TRUE . do while ( Bessel_run ) if (( n . GE . nmax ). OR .( besselI ( n , z ). LT . Bessel_zero )) then nmaxrun = n Bessel_run = . FALSE . endif n = n + 1 enddo do n =- nmaxrun , nmaxrun call calc_ypsilon ( Ynew , j , n , kz , kperp , x ) do i = 1 , 3 do k = 1 , 3 ! Remember that the Bessel functions give I_n(z)*exp(-z), so the factor exp(-z) is absorbed. Y ( i , k ) = Y ( i , k ) + Ynew ( i , k ) if ( n == 0 ) Y0 ( i , k ) = Ynew ( i , k ) if ( n == 1 ) Y1 ( i , k ) = Y1 ( i , k ) + Ynew ( i , k ) if ( n ==- 1 ) Yn1 ( i , k ) = Yn1 ( i , k ) + Ynew ( i , k ) enddo enddo enddo chi ( 1 , 1 ) = Y ( 1 , 1 ) / ( ell * ell ) chi ( 1 , 2 ) = Y ( 1 , 2 ) / ( ell * ell ) chi ( 1 , 3 ) = Y ( 1 , 3 ) / ( ell * ell ) chi ( 2 , 1 ) = Y ( 2 , 1 ) / ( ell * ell ) chi ( 2 , 2 ) = Y ( 2 , 2 ) / ( ell * ell ) chi ( 2 , 3 ) = Y ( 2 , 3 ) / ( ell * ell ) chi ( 3 , 1 ) = Y ( 3 , 1 ) / ( ell * ell ) chi ( 3 , 2 ) = Y ( 3 , 2 ) / ( ell * ell ) if ( kperp_norm ) then chi ( 3 , 3 ) = 2.d0 * x * vdrift / ( ell * ell * kz * vtherm * vtherm * bMalphas ( j )) + Y ( 3 , 3 ) / ( ell * ell ) else chi ( 3 , 3 ) = kperp * kperp * 2.d0 * x * vdrift / ( ell * ell * kz * vtherm * vtherm * bMalphas ( j )) + Y ( 3 , 3 ) / ( ell * ell ) endif n = 0 chi_low ( 1 , 1 , n ) = Y0 ( 1 , 1 ) / ( ell * ell ) chi_low ( 1 , 2 , n ) = Y0 ( 1 , 2 ) / ( ell * ell ) chi_low ( 1 , 3 , n ) = Y0 ( 1 , 3 ) / ( ell * ell ) chi_low ( 2 , 1 , n ) = Y0 ( 2 , 1 ) / ( ell * ell ) chi_low ( 2 , 2 , n ) = Y0 ( 2 , 2 ) / ( ell * ell ) chi_low ( 2 , 3 , n ) = Y0 ( 2 , 3 ) / ( ell * ell ) chi_low ( 3 , 1 , n ) = Y0 ( 3 , 1 ) / ( ell * ell ) chi_low ( 3 , 2 , n ) = Y0 ( 3 , 2 ) / ( ell * ell ) if ( kperp_norm ) then chi_low ( 3 , 3 , n ) = Y0 ( 3 , 3 ) / ( ell * ell ) + 2.d0 * x * vdrift / ( ell * ell * kz * vtherm * vtherm * bMalphas ( j )) else chi_low ( 3 , 3 , n ) = Y0 ( 3 , 3 ) / ( ell * ell ) + kperp * kperp * 2.d0 * x * vdrift / ( ell * ell * kz * vtherm * vtherm * bMalphas ( j )) endif n = 1 chi_low ( 1 , 1 , n ) = Y1 ( 1 , 1 ) / ( ell * ell ) chi_low ( 1 , 2 , n ) = Y1 ( 1 , 2 ) / ( ell * ell ) chi_low ( 1 , 3 , n ) = Y1 ( 1 , 3 ) / ( ell * ell ) chi_low ( 2 , 1 , n ) = Y1 ( 2 , 1 ) / ( ell * ell ) chi_low ( 2 , 2 , n ) = Y1 ( 2 , 2 ) / ( ell * ell ) chi_low ( 2 , 3 , n ) = Y1 ( 2 , 3 ) / ( ell * ell ) chi_low ( 3 , 1 , n ) = Y1 ( 3 , 1 ) / ( ell * ell ) chi_low ( 3 , 2 , n ) = Y1 ( 3 , 2 ) / ( ell * ell ) chi_low ( 3 , 3 , n ) = Y1 ( 3 , 3 ) / ( ell * ell ) n =- 1 chi_low ( 1 , 1 , n ) = Yn1 ( 1 , 1 ) / ( ell * ell ) chi_low ( 1 , 2 , n ) = Yn1 ( 1 , 2 ) / ( ell * ell ) chi_low ( 1 , 3 , n ) = Yn1 ( 1 , 3 ) / ( ell * ell ) chi_low ( 2 , 1 , n ) = Yn1 ( 2 , 1 ) / ( ell * ell ) chi_low ( 2 , 2 , n ) = Yn1 ( 2 , 2 ) / ( ell * ell ) chi_low ( 2 , 3 , n ) = Yn1 ( 2 , 3 ) / ( ell * ell ) chi_low ( 3 , 1 , n ) = Yn1 ( 3 , 1 ) / ( ell * ell ) chi_low ( 3 , 2 , n ) = Yn1 ( 3 , 2 ) / ( ell * ell ) chi_low ( 3 , 3 , n ) = Yn1 ( 3 , 3 ) / ( ell * ell ) endif end subroutine subroutine calc_ypsilon ( Y , j , n , kz , kperp , x ) !! Calculates the Y-tensor according to Stix for a bi-Maxwelling, using the NHDS calculation. use alps_var , only : bMbetas , bMalphas , bMpdrifts use alps_var , only : ms , qs , ns use alps_var , only : kperp_norm implicit none double complex , parameter :: uniti = ( 0.d0 , 1.d0 ) !! Imaginary unit. double complex , intent ( out ) :: Y ( 3 , 3 ) !! Y-tensor as defined by Stix. integer , intent ( in ) :: j !! Index for species. integer , intent ( in ) :: n !! Index of sum over Bessel functions. double precision , intent ( in ) :: kz !! Normalised parallel wavenumber. double precision , intent ( in ) :: kperp !! Normalised perpendicular wavenumber. double complex , intent ( in ) :: x !! Normalised complex frequency. double complex :: zeta !! Argument of dispersion function. double complex :: An !! An function according to Stix. double complex :: Bn !! Bn function according to Stix. double complex :: resfac !! Resonance factor. double precision :: BInz !! Modified Bessel function, evaluated. double precision :: z !! Argument of Bessel function. double precision :: zp !! Argument of Bessel function, multiplied by kperp&#94;2 double precision :: Omega !! Normalised gyro-frequency. double precision :: ell !! Normalised inertial length. double precision :: vtherm !! Normalised thermal speed. double precision :: vdrift !! Normalised drift speed of bi-Maxwellian/cold population. double precision :: dBInzdz !! Derivative of Bessel function. logical :: kpos !! Check whether kpar is positive. kpos = . TRUE . if ( kz . LT . 0.d0 ) kpos = . FALSE . Omega = qs ( j ) / ms ( j ) ell = sqrt ( ms ( j ) / ( ns ( j ) * qs ( j ) * qs ( j ))) vtherm = sqrt ( bMbetas ( j ) / ( ns ( j ) * ms ( j ))) vdrift = bMpdrifts ( j ) / ms ( j ) zeta = ( x - kz * vdrift - 1.d0 * n * Omega ) / ( kz * vtherm ) resfac = x - kz * vdrift - 1.d0 * n * Omega z = 0.5d0 * ( kperp * vtherm / Omega ) * ( kperp * vtherm / Omega ) * bMalphas ( j ) !zp=z*kperp&#94;2 d_ref&#94;2 zp = 0.5d0 * ( vtherm / Omega ) * ( vtherm / Omega ) * bMalphas ( j ) An = ( bMalphas ( j ) - 1.d0 ) An = An + ( 1.d0 / ( kz * vtherm )) * ( bMalphas ( j ) * resfac + 1.d0 * n * Omega ) * dispfunct ( zeta , kpos ) Bn = ( bMalphas ( j ) * ( x - 1.d0 * n * Omega ) - ( kz * vdrift - 1.d0 * n * Omega )) / kz Bn = Bn + (( x - 1.d0 * n * Omega ) * ( bMalphas ( j ) * resfac + 1.d0 * n * Omega ) / ( kz * kz * vtherm ) ) * dispfunct ( zeta , kpos ) if ( n . GE . 0 ) then BInz = 1.d0 * besselI ( n , z ) dBInzdz = 5.d-1 * ( besselI ( n + 1 , z ) + besselI ( n - 1 , z )) !Changing definition of derivative to avoid division by z !dBInzdz=besselI(n+1,z)+1.d0*n*BInz/z else BInz = 1.d0 * besselI ( - n , z ) dBInzdz = 5.d-1 * ( besselI ( n + 1 , z ) + besselI ( n - 1 , z )) !Changing definition of derivative to avoid division by z !dBInzdz=besselI(-n-1,z)+1.d0*n*BInz/z endif if ( kperp_norm ) then ! The tensor in Stix's (10-57) Y ( 1 , 1 ) = 1.d0 * ( n * n ) * BInz * An / z Y ( 1 , 2 ) =- uniti * n * ( BInz - dBInzdz ) * An Y ( 1 , 3 ) = kperp * n * BInz * Bn / ( Omega * z ) Y ( 2 , 1 ) = uniti * n * ( BInz - dBInzdz ) * An Y ( 2 , 2 ) = ( 1.d0 * ( n * n ) * BInz / z + 2.d0 * z * BInz - 2.d0 * z * dBInzdz ) * An Y ( 2 , 3 ) = uniti * kperp * ( BInz - dBInzdz ) * Bn / Omega Y ( 3 , 1 ) = kperp * BInz * n * Bn / ( Omega * z ) Y ( 3 , 2 ) =- uniti * kperp * ( BInz - dBInzdz ) * Bn / Omega Y ( 3 , 3 ) = 2.d0 * ( x - 1.d0 * n * Omega ) * BInz * Bn / ( kz * vtherm * vtherm * bMalphas ( j )) else ! The tensor in Stix's (10-57), multiplied by kperp&#94;2 d_ref&#94;2 Y ( 1 , 1 ) = 1.d0 * ( n * n ) * BInz * An / zp Y ( 1 , 2 ) =- uniti * n * ( BInz - dBInzdz ) * An * kperp * kperp Y ( 1 , 3 ) = kperp * n * BInz * Bn / ( Omega * zp ) Y ( 2 , 1 ) = uniti * n * ( BInz - dBInzdz ) * An * kperp * kperp Y ( 2 , 2 ) = ( 1.d0 * ( n * n ) * BInz / zp + kperp * kperp * 2.d0 * z * BInz - kperp * kperp * 2.d0 * z * dBInzdz ) * An Y ( 2 , 3 ) = uniti * kperp * kperp * kperp * ( BInz - dBInzdz ) * Bn / Omega Y ( 3 , 1 ) = kperp * BInz * n * Bn / ( Omega * zp ) Y ( 3 , 2 ) =- uniti * kperp * kperp * kperp * ( BInz - dBInzdz ) * Bn / Omega Y ( 3 , 3 ) = kperp * kperp * 2.d0 * ( x - 1.d0 * n * Omega ) * BInz * Bn / ( kz * vtherm * vtherm * bMalphas ( j )) endif end subroutine subroutine calc_chi_cold ( chi , j , kz , kperp , x ) !! Subroutine that calculates the susceptibility of species j based on the cold-plasma dispersion relation based on the paper Verscharen & Chandran, ApJ 764, 88, 2013. use alps_var , only : bMbetas , bMpdrifts use alps_var , only : ms , qs , ns use alps_var , only : kperp_norm implicit none double complex , intent ( out ) :: chi ( 3 , 3 ) !! Susceptibility tensor of species j. double complex , parameter :: uniti = ( 0.d0 , 1.d0 ) !! Imaginary unit. integer , intent ( in ) :: j !! Index for species. double precision , intent ( in ) :: kz !! Normalised parallel wavenumber. double precision , intent ( in ) :: kperp !! Normalised perpendicular wavenumber. double complex , intent ( in ) :: x !! Normalised complex frequency. double precision :: Omega !! Normalised gyro-frequency. double precision :: ell !! Normalised inertial length. double precision :: vtherm !! Normalised thermal speed. double precision :: vdrift !! Normalised drift speed of bi-Maxwellian/cold population. double complex :: dispR !! Susceptibility element R as defined by Verscharen & Chandran double complex :: dispL !! Susceptibility element L as defined by Verscharen & Chandran double complex :: dispP !! Susceptibility element P as defined by Verscharen & Chandran double complex :: dispM !! Susceptibility element M as defined by Verscharen & Chandran double complex :: dispJ !! Susceptibility element J as defined by Verscharen & Chandran Omega = qs ( j ) / ms ( j ) ell = sqrt ( ms ( j ) / ( ns ( j ) * qs ( j ) * qs ( j ))) vtherm = sqrt ( bMbetas ( j ) / ( ns ( j ) * ms ( j ))) vdrift = bMpdrifts ( j ) / ms ( j ) dispR =- ( 1.d0 / ( ell * ell )) * ( x - kz * vdrift ) / ( x - kz * vdrift + Omega ) dispL =- ( 1.d0 / ( ell * ell )) * ( x - kz * vdrift ) / ( x - kz * vdrift - Omega ) dispP = ( x * x / (( x - kz * vdrift ) ** 2 )) + (( kperp * vdrift ) ** 2 / (( x - kz * vdrift ) ** 2 - Omega ** 2 )) dispP =- ( 1.d0 / ( ell * ell )) * dispP dispJ =- ( 1.d0 / ( ell * ell )) * kperp * vdrift * ( x - kz * vdrift ) / (( x - kz * vdrift ) ** 2 - Omega ** 2 ) dispM = uniti * ( 1.d0 / ( ell * ell )) * kperp * vdrift * Omega / (( x - kz * vdrift ) ** 2 - Omega ** 2 ) if ( kperp_norm ) then chi ( 1 , 1 ) = ( dispR + dispL ) / 2.d0 chi ( 1 , 2 ) =- uniti * ( dispR - dispL ) / 2.d0 chi ( 1 , 3 ) = dispJ chi ( 2 , 1 ) = uniti * ( dispR - dispL ) / 2.d0 chi ( 2 , 2 ) = ( dispR + dispL ) / 2.d0 chi ( 2 , 3 ) = dispM chi ( 3 , 1 ) = dispJ chi ( 3 , 2 ) =- dispM chi ( 3 , 3 ) = dispP else write ( * , * ) 'ERROR: check kperp norm for cold plasma distribution!!' stop endif end subroutine double precision function besselI ( n , x ) !! Calculates the modified Bessel function of argument x and order n. implicit none double precision , intent ( in ) :: x !! Argument of the modified Bessel function. integer , intent ( in ) :: n !! Order of the modified Bessel function. if ( n . LT . 0 ) then besselI = BESSI ( - n , x ) else besselI = BESSI ( n , x ) endif end function ! ! Calculate the dispersion function: ! double complex function dispfunct ( zeta , kpos ) !! Calculates the dispersion function based on the complex error function. implicit none double complex , parameter :: uniti = ( 0.d0 , 1.d0 ) !! Imaginary init. double complex , intent ( in ) :: zeta !! Argument of dispersion function. logical , intent ( in ) :: kpos !! Check whether kpar is positive. logical :: flag !! Check whether [[WOFZ(subroutine)]] executes successfully. double precision :: U !! Real part of the output for [[WOFZ(subroutine)]]. double precision :: V !! Imaginary part of the output for [[WOFZ(subroutine)]]. double precision :: XI !! Real part of the argument for [[WOFZ(subroutine)]]. double precision :: YI !! Imaginary part of the argument for [[WOFZ(subroutine)]]. double precision :: M_PI = 4.d0 * atan ( 1.d0 ) !! Pi. XI = 1.d0 * real ( zeta ) YI = 1.d0 * aimag ( zeta ) if ( kpos ) then call WOFZ ( XI , YI , U , V , flag ) dispfunct = uniti * sqrt ( M_PI ) * ( U + uniti * V ) else call WOFZ ( - XI , - YI , U , V , flag ) dispfunct = - uniti * sqrt ( M_PI ) * ( U + uniti * V ) endif end function SUBROUTINE WOFZ ( XI , YI , U , V , FLAG ) !!  Given a complex number Z = (XI,YI), this subroutine computes !!  the value of the Faddeeva function W(Z) = exp(-Z**2)*erfc(-I*Z), !!  where erfc is the complex complementary error function and I !! is the imaginary unit. !Based on !G.P.M. Poppe, C.M.J. Wijers, \"More Efficient Computation of the Complex Error-Function\", !ACM Trans. Math. Software 16, 47 (1990). !      ALGORITHM 680, COLLECTED ALGORITHMS FROM ACM. !      THIS WORK PUBLISHED IN TRANSACTIONS ON MATHEMATICAL SOFTWARE, !      VOL. 16, NO. 1, PP. 47 !  THE ACCURACY OF THE ALGORITHM FOR Z IN THE 1ST AND 2ND QUADRANT !  IS 14 SIGNIFICANT DIGITS; IN THE 3RD AND 4TH IT IS 13 SIGNIFICANT !  DIGITS OUTSIDE A CIRCULAR REGION WITH RADIUS 0.126 AROUND A ZERO !  OF THE FUNCTION. !  ALL REAL VARIABLES IN THE PROGRAM ARE DOUBLE PRECISION. !  THE CODE CONTAINS A FEW COMPILER-DEPENDENT PARAMETERS : !     RMAXREAL = THE MAXIMUM VALUE OF RMAXREAL EQUALS THE ROOT OF !                RMAX = THE LARGEST NUMBER WHICH CAN STILL BE !                IMPLEMENTED ON THE COMPUTER IN DOUBLE PRECISION !                FLOATING-POINT ARITHMETIC !     RMAXEXP  = LN(RMAX) - LN(2) !     RMAXGONI = THE LARGEST POSSIBLE ARGUMENT OF A DOUBLE PRECISION !                GONIOMETRIC FUNCTION (DCOS, DSIN, ...) !  THE REASON WHY THESE PARAMETERS ARE NEEDED AS THEY ARE DEFINED WILL !  BE EXPLAINED IN THE CODE BY MEANS OF COMMENTS ! ! !  PARAMETER LIST !     XI     = REAL      PART OF Z !     YI     = IMAGINARY PART OF Z !     U      = REAL      PART OF W(Z) !     V      = IMAGINARY PART OF W(Z) !     FLAG   = AN ERROR FLAG INDICATING WHETHER OVERFLOW WILL !              OCCUR OR NOT; TYPE LOGICAL; !              THE VALUES OF THIS VARIABLE HAVE THE FOLLOWING !              MEANING : !              FLAG=.FALSE. : NO ERROR CONDITION !              FLAG=.TRUE.  : OVERFLOW WILL OCCUR, THE ROUTINE !                             BECOMES INACTIVE !  XI, YI      ARE THE INPUT-PARAMETERS !  U, V, FLAG  ARE THE OUTPUT-PARAMETERS ! !  FURTHERMORE THE PARAMETER FACTOR EQUALS 2/SQRT(PI) ! !  THE ROUTINE IS NOT UNDERFLOW-PROTECTED BUT ANY VARIABLE CAN BE !  PUT TO 0 UPON UNDERFLOW; ! IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) IMPLICIT INTEGER ( I - N ) LOGICAL A , B , FLAG PARAMETER ( FACTOR = 1.12837916709551257388D0 , RMAXREAL = 0.5D+154 , RMAXEXP = 70 8.503061461606D0 ,& & RMAXGONI = 3.53711887601422D+15 ) FLAG = . FALSE . XABS = DABS ( XI ) YABS = DABS ( YI ) X = XABS / 6.3 Y = YABS / 4.4 !     THE FOLLOWING IF-STATEMENT PROTECTS !     QRHO = (X**2 + Y**2) AGAINST OVERFLOW ! IF (( XABS . GT . RMAXREAL ). OR .( YABS . GT . RMAXREAL )) GOTO 100 QRHO = X ** 2 + Y ** 2 XABSQ = XABS ** 2 XQUAD = XABSQ - YABS ** 2 YQUAD = 2 * XABS * YABS A = QRHO . LT . 0.085264D0 IF ( A ) THEN !  IF (QRHO.LT.0.085264D0) THEN THE FADDEEVA-FUNCTION IS EVALUATED !  USING A POWER-SERIES (ABRAMOWITZ/STEGUN, EQUATION (7.1.5), P.297) !  N IS THE MINIMUM NUMBER OF TERMS NEEDED TO OBTAIN THE REQUIRED !  ACCURACY QRHO = ( 1 - 0.85 * Y ) * DSQRT ( QRHO ) N = IDNINT ( 6 + 72 * QRHO ) J = 2 * N + 1 XSUM = 1.0 / J YSUM = 0.0D0 DO 10 I = N , 1 , - 1 J = J - 2 XAUX = ( XSUM * XQUAD - YSUM * YQUAD ) / I YSUM = ( XSUM * YQUAD + YSUM * XQUAD ) / I XSUM = XAUX + 1.0 / J 10 CONTINUE U1 = - FACTOR * ( XSUM * YABS + YSUM * XABS ) + 1.0 V1 = FACTOR * ( XSUM * XABS - YSUM * YABS ) DAUX = DEXP ( - XQUAD ) U2 = DAUX * DCOS ( YQUAD ) V2 = - DAUX * DSIN ( YQUAD ) U = U1 * U2 - V1 * V2 V = U1 * V2 + V1 * U2 ELSE !  IF (QRHO.GT.1.O) THEN W(Z) IS EVALUATED USING THE LAPLACE !  CONTINUED FRACTION !  NU IS THE MINIMUM NUMBER OF TERMS NEEDED TO OBTAIN THE REQUIRED !  ACCURACY ! !  IF ((QRHO.GT.0.085264D0).AND.(QRHO.LT.1.0)) THEN W(Z) IS EVALUATED !  BY A TRUNCATED TAYLOR EXPANSION, WHERE THE LAPLACE CONTINUED FRACTION !  IS USED TO CALCULATE THE DERIVATIVES OF W(Z) !  KAPN IS THE MINIMUM NUMBER OF TERMS IN THE TAYLOR EXPANSION NEEDED !  TO OBTAIN THE REQUIRED ACCURACY !  NU IS THE MINIMUM NUMBER OF TERMS OF THE CONTINUED FRACTION NEEDED !  TO CALCULATE THE DERIVATIVES WITH THE REQUIRED ACCURACY IF ( QRHO . GT . 1.0 ) THEN H = 0.0D0 KAPN = 0 QRHO = DSQRT ( QRHO ) NU = IDINT ( 3 + ( 1442 / ( 26 * QRHO + 77 ))) ELSE QRHO = ( 1 - Y ) * DSQRT ( 1 - QRHO ) H = 1.88 * QRHO H2 = 2 * H KAPN = IDNINT ( 7 + 34 * QRHO ) NU = IDNINT ( 16 + 26 * QRHO ) ENDIF B = ( H . GT . 0.0 ) IF ( B ) QLAMBDA = H2 ** KAPN RX = 0.0 RY = 0.0 SX = 0.0 SY = 0.0 DO 11 N = NU , 0 , - 1 NP1 = N + 1 TX = YABS + H + NP1 * RX TY = XABS - NP1 * RY C = 0.5 / ( TX ** 2 + TY ** 2 ) RX = C * TX RY = C * TY IF (( B ). AND .( N . LE . KAPN )) THEN TX = QLAMBDA + SX SX = RX * TX - RY * SY SY = RY * TX + RX * SY QLAMBDA = QLAMBDA / H2 ENDIF 11 CONTINUE IF ( H . EQ . 0.0 ) THEN U = FACTOR * RX V = FACTOR * RY ELSE U = FACTOR * SX V = FACTOR * SY END IF IF ( YABS . EQ . 0.0 ) U = DEXP ( - XABS ** 2 ) END IF !  EVALUATION OF W(Z) IN THE OTHER QUADRANTS IF ( YI . LT . 0.0 ) THEN IF ( A ) THEN U2 = 2 * U2 V2 = 2 * V2 ELSE XQUAD = - XQUAD !         THE FOLLOWING IF-STATEMENT PROTECTS 2*EXP(-Z**2) !        AGAINST OVERFLOW IF (( YQUAD . GT . RMAXGONI ). OR . ( XQUAD . GT . RMAXEXP )) GOTO 100 W1 = 2 * DEXP ( XQUAD ) U2 = W1 * DCOS ( YQUAD ) V2 = - W1 * DSIN ( YQUAD ) END IF U = U2 - U V = V2 - V IF ( XI . GT . 0.0 ) V = - V ELSE IF ( XI . LT . 0.0 ) V = - V END IF RETURN 100 FLAG = . TRUE . RETURN END ! ---------------------------------------------------------------------- double precision FUNCTION BESSI ( N , X ) !! Function to calculate the first kind modified Bessel function of integer order N !! for any real X. ! -------------------------------------------------------------------- * !   Reference: From Numath Library By Tuan Dang Trong in Fortran 77.   * !                                                                      * !                               F90 Release 1.1 By J-P Moreau, Paris.  * !                                                                      * !   Version 1.1: corected value of P4 in BESSIO (P4=1.2067492 and not  * !                1.2067429) Aug. 2011.                                 * IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) IMPLICIT INTEGER ( I - N ) !     This subroutine calculates the first kind modified Bessel function !     of integer order N, for any REAL X. We use here the classical !     recursion formula, when X > N. For X < N, the Miller's algorithm !     is used to avoid overflows. !     REFERENCE: !     C.W.CLENSHAW, CHEBYSHEV SERIES FOR MATHEMATICAL FUNCTIONS, !     MATHEMATICAL TABLES, VOL.5, 1962. ! ! This function calculates I_n(x)*exp(-x) instead of I_n(x) DOUBLE PRECISION :: X , TOX , BIM , BI , BIP INTEGER , PARAMETER :: IACC = 40 INTEGER , PARAMETER :: IBIGNO = maxexponent ( x ) / 2 IF ( N . EQ . 0 ) THEN BESSI = BESSI0 ( X ) RETURN ENDIF IF ( N . EQ . 1 ) THEN BESSI = BESSI1 ( X ) RETURN ENDIF IF ( X . EQ . 0.D0 ) THEN BESSI = 0.D0 RETURN ENDIF TOX = 2.D0 / X BIP = 0.D0 BI = 1.D0 BESSI = 0.D0 M = 2 * (( N + INT ( SQRT ( FLOAT ( IACC * N ))))) DO 12 J = M , 1 , - 1 BIM = BIP + DFLOAT ( J ) * TOX * BI BIP = BI BI = BIM IF ( EXPONENT ( BI ). GT . IBIGNO ) THEN BI = scale ( BI , - IBIGNO ) BIP = scale ( BIP , - IBIGNO ) BESSI = scale ( BESSI , - IBIGNO ) ENDIF IF ( J . EQ . N ) BESSI = BIP 12 CONTINUE BESSI = BESSI0 ( X ) * ( BESSI / BI ) RETURN END double precision FUNCTION BESSI0 ( X ) !! Auxiliary Bessel functions for N=0, N=1 ! This function calculates I_0(x)*exp(-x) instead of I_0(x) REAL * 8 X , Y , P1 , P2 , P3 , P4 , P5 , P6 , P7 , & Q1 , Q2 , Q3 , Q4 , Q5 , Q6 , Q7 , Q8 , Q9 , AX , BX DATA P1 , P2 , P3 , P4 , P5 , P6 , P7 / 1.D0 , 3.5156229D0 , 3.0899424D0 , 1.2067492D0 , & 0.2659732D0 , 0.360768D-1 , 0.45813D-2 / DATA Q1 , Q2 , Q3 , Q4 , Q5 , Q6 , Q7 , Q8 , Q9 / 0.39894228D0 , 0.1328592D-1 , & 0.225319D-2 , - 0.157565D-2 , 0.916281D-2 , - 0.2057706D-1 , & 0.2635537D-1 , - 0.1647633D-1 , 0.392377D-2 / AX = ABS ( X ) IF ( AX . LT . 3.75D0 ) THEN Y = ( X / 3.75D0 ) ** 2 BESSI0 = ( P1 + Y * ( P2 + Y * ( P3 + Y * ( P4 + Y * ( P5 + Y * ( P6 + Y * P7 )))))) * EXP ( - AX ) ELSE Y = 3.75D0 / AX BX = 1.D0 / SQRT ( AX ) AX = Q1 + Y * ( Q2 + Y * ( Q3 + Y * ( Q4 + Y * ( Q5 + Y * ( Q6 + Y * ( Q7 + Y * ( Q8 + Y * Q9 ))))))) BESSI0 = AX * BX ENDIF RETURN END double precision FUNCTION BESSI1 ( X ) !! Modified Bessel function of order 1. ! This function calculates I_1(x)*exp(-x) instead of I_1(x) REAL * 8 X , Y , P1 , P2 , P3 , P4 , P5 , P6 , P7 , & Q1 , Q2 , Q3 , Q4 , Q5 , Q6 , Q7 , Q8 , Q9 , AX , BX DATA P1 , P2 , P3 , P4 , P5 , P6 , P7 / 0.5D0 , 0.87890594D0 , 0.51498869D0 , & 0.15084934D0 , 0.2658733D-1 , 0.301532D-2 , 0.32411D-3 / DATA Q1 , Q2 , Q3 , Q4 , Q5 , Q6 , Q7 , Q8 , Q9 / 0.39894228D0 , - 0.3988024D-1 , & - 0.362018D-2 , 0.163801D-2 , - 0.1031555D-1 , 0.2282967D-1 , & - 0.2895312D-1 , 0.1787654D-1 , - 0.420059D-2 / AX = ABS ( X ) IF ( AX . LT . 3.75D0 ) THEN Y = ( X / 3.75D0 ) ** 2 BESSI1 = X * ( P1 + Y * ( P2 + Y * ( P3 + Y * ( P4 + Y * ( P5 + Y * ( P6 + Y * P7 )))))) * EXP ( - AX ) ELSE Y = 3.75D0 / AX BX = 1.D0 / SQRT ( AX ) AX = Q1 + Y * ( Q2 + Y * ( Q3 + Y * ( Q4 + Y * ( Q5 + Y * ( Q6 + Y * ( Q7 + Y * ( Q8 + Y * Q9 ))))))) BESSI1 = AX * BX ENDIF RETURN END end module alps_nhds","tags":"","url":"sourcefile/alps_nhds.f90.html"},{"title":"ALPS_com.f90 – ALPS","text":"Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_com implicit none public :: pass_instructions public :: pass_distribution contains subroutine pass_instructions !!Passes information between processes. use alps_var , only : proc0 , ierror , nroots , n_fits , param_fit , fit_type , perp_correction use alps_var , only : writeOut , nperp , npar , nmax , nlim , nspec , numroots , ngamma , npparbar use alps_var , only : ns , qs , ms , wroots , kperp , kpar , bessel_zero use alps_var , only : wave , chi0 , chi0_low , pp , df0 , vA , pi use alps_var , only : secant_method , numiter , D_threshold , D_gap , D_prec , D_tol use alps_var , only : use_map , kperp_norm use alps_var , only : ni , nr , omi , omf , gami , gamf , loggridg , loggridw use alps_var , only : determine_minima , n_resonance_interval , positions_principal , Tlim use alps_var , only : n_scan , scan , scan_option , relativistic , logfit , usebM use alps_var , only : bMnmaxs , bMBessel_zeros , bMbetas , bMalphas , bMpdrifts use alps_var , only : ACmethod , poly_kind , poly_order , poly_fit_coeffs use alps_var , only : poly_log_max use mpi implicit none integer :: is !!Index for scans. !Broadcast Global Variables needed for code execution: call mpi_bcast ( nperp , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( npar , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( ngamma , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( npparbar , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( nspec , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( nroots , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( numiter , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( n_resonance_interval , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( positions_principal , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( writeOut , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( kperp , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( kpar , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( vA , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bessel_zero , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( D_threshold , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( D_prec , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( D_gap , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( D_tol , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( Tlim , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( use_map , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( kperp_norm , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( n_scan , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan_option , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( secant_method , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) !Broadcast Map Parameters: if ( use_map ) then call mpi_bcast ( omi , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( omf , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( gami , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( gamf , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( loggridw , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( loggridg , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( ni , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( nr , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( determine_minima , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) endif pi = 4.d0 * atan ( 1.d0 ) allocate ( nmax ( 1 : nspec )); nmax = 0 nlim = 0 !Allocate parameter arrays: if ( proc0 ) then !Necessary arrays allocated for proc0 in subroutine init_param (ALPS_io) !to allow for reading in of guesses for the dispersion solution. else allocate ( ns ( 1 : nspec )); ns = 0.d0 allocate ( qs ( 1 : nspec )); qs = 0.d0 allocate ( ms ( 1 : nspec )); ms = 0.d0 allocate ( n_fits ( 1 : nspec )) allocate ( relativistic ( 1 : nspec )); relativistic = . FALSE . allocate ( logfit ( 1 : nspec )); logfit = . TRUE . allocate ( usebM ( 1 : nspec )); usebM = . TRUE . allocate ( bMnmaxs ( 1 : nspec )); bMnmaxs = 500 allocate ( bMBessel_zeros ( 1 : nspec )); bMBessel_zeros = 1.d-50 allocate ( bMbetas ( 1 : nspec )); bMbetas = 1.d0 allocate ( bMalphas ( 1 : nspec )); bMalphas = 1.d0 allocate ( bMpdrifts ( 1 : nspec )); bMpdrifts = 0.d0 allocate ( ACmethod ( 1 : nspec )); ACmethod = 1 allocate ( poly_order ( 1 : nspec )); poly_order = 0 allocate ( poly_kind ( 1 : nspec )); poly_kind = 0 allocate ( poly_log_max ( 1 : nspec )); poly_log_max = 0 allocate ( wroots ( 1 : numroots )); wroots = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) if ( n_scan . gt . 0 ) allocate ( scan ( n_scan )) endif !+ Send and Receive instructions: call mpi_bcast ( ns (:), size ( ns (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( qs (:), size ( qs (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( ms (:), size ( ms (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( n_fits (:), size ( n_fits (:)),& MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( relativistic (:), size ( relativistic (:)),& MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( logfit (:), size ( logfit (:)),& MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( usebM (:), size ( usebM (:)),& MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMnmaxs (:), size ( bMnmaxs (:)),& MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMBessel_zeros (:), size ( bMBessel_zeros (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMbetas (:), size ( bMbetas (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMalphas (:), size ( bMalphas (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( bMpdrifts (:), size ( bMpdrifts (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( wroots (:), size ( wroots (:)),& MPI_DOUBLE_COMPLEX , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( ACmethod (:), size ( ACmethod (:)),& MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( poly_kind (:), size ( poly_kind (:)),& MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( poly_order (:), size ( poly_order (:)),& MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( poly_log_max (:), size ( poly_log_max (:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) if ( n_scan . gt . 0 ) then do is = 1 , n_scan call mpi_bcast ( scan ( is )% range_i , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% range_f , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% diff , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% diff2 , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% log_scan , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% eigen_s , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% heat_s , 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% type_s , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% n_out , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( scan ( is )% n_res , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) enddo endif ! Wave terms only summed on proc0: if ( proc0 ) then allocate ( wave ( 1 : 3 , 1 : 3 )) allocate ( chi0 ( nspec , 1 : 3 , 1 : 3 )) wave = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) allocate ( chi0_low ( nspec , 1 : 3 , 1 : 3 , - 1 : 1 )) else !Final fitting parameter arrays: allocate ( param_fit ( 1 : nspec , 0 :( max ( nperp , ngamma )), 5 , maxval ( n_fits ))) allocate ( fit_type ( 1 : nspec , maxval ( n_fits ))) allocate ( perp_correction ( 1 : nspec , maxval ( n_fits ))) !Allocate fit coefficients for the polynomial basis here! if ( maxval ( poly_order (:)). gt . 1 ) then allocate ( poly_fit_coeffs ( 1 : nspec , 0 : nperp , 0 : maxval ( poly_order (:)))); poly_fit_coeffs = 0.d0 endif endif allocate ( df0 ( 1 : nspec , 1 : nperp - 1 , 1 : npar - 1 , 1 : 2 )); df0 = 0.d0 allocate ( pp ( 1 : nspec , 0 : nperp , 0 : npar , 1 : 2 )); pp = 0.d0 end subroutine pass_instructions subroutine pass_distribution !!Passes distribution functions and associated parameters. use alps_var , only : df0 , pp , param_fit , fit_type , perp_correction , proc0 , writeOut , ierror use alps_var , only : df0_rel , gamma_rel , pparbar_rel , f0_rel use alps_var , only : relativistic , nspec , ngamma , npparbar use alps_var , only : poly_fit_coeffs , poly_order use mpi implicit none integer :: is_rel !!Relativistic component index. integer :: is !!Components index. integer :: nspec_rel !!Number of relativistic components. logical :: any_relativistic !!Check if any component relativistic. !+ Broadcast derivative array: if ( writeOut . and . proc0 )& write ( * , '(a)' ) 'Broadcasting df0/dp...' any_relativistic = . FALSE . is_rel = 0 do is = 1 , nspec if ( relativistic ( is )) then any_relativistic = . TRUE . is_rel = is_rel + 1 endif enddo if ( any_relativistic ) then nspec_rel = is_rel if (. not .( proc0 )) then ! Allocate the relativistic fields: allocate ( gamma_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) allocate ( pparbar_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) allocate ( df0_rel ( nspec_rel , 0 : ngamma , 0 : npparbar , 2 )) allocate ( f0_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) endif call mpi_bcast ( f0_rel (:,:,:), size ( f0_rel (:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( df0_rel (:,:,:,:), size ( df0_rel (:,:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( gamma_rel (:,:,:), size ( gamma_rel (:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( pparbar_rel (:,:,:), size ( pparbar_rel (:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) endif call mpi_bcast ( df0 (:,:,:,:), size ( df0 (:,:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( pp (:,:,:,:), size ( pp (:,:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( param_fit (:,:,:,:), size ( param_fit (:,:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( fit_type (:,:), size ( fit_type (:,:)),& MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( perp_correction (:,:), size ( perp_correction (:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) if ( maxval ( poly_order (:)). gt . 1 ) then call mpi_bcast ( poly_fit_coeffs (:,:,:), size ( poly_fit_coeffs (:,:,:)),& MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierror ) endif if ( writeOut . and . proc0 )& write ( * , '(a)' ) ' df0/dp received' end subroutine pass_distribution end module alps_com","tags":"","url":"sourcefile/alps_com.f90.html"},{"title":"ALPS.f90 – ALPS","text":"Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== program alps use alps_var , only : nproc , iproc , ierror , proc0 , sproc use alps_var , only : use_map , unit_error , scan_option use alps_var , only : writeOut , f0 , nperp , npar , nspec , n_scan use alps_io , only : init_param , read_f0 , get_unused_unit use alps_io , only : alps_error , alps_error_init , output_time , display_credits use alps_fns , only : derivative_f0 , disp , secant use alps_fns , only : refine_guess use alps_fns , only : determine_nmax , split_processes , determine_bessel_array use alps_fns , only : map_search use alps_fns , only : om_scan , om_double_scan use alps_com , only : pass_instructions , pass_distribution use alps_analyt , only : determine_param_fit use mpi implicit none integer :: ik !! Index for iterating through wavevector scans with [[om_scan(subroutine)]] !! or [[om_double_scan(subroutine)]] !Initialize MPI message passing: call mpi_init ( ierror ) call mpi_comm_size ( mpi_comm_world , nproc , ierror ) call mpi_comm_rank ( mpi_comm_world , iproc , ierror ) !Set logical proc0=true if iproc=0: proc0 = ( iproc == 0 ) if ( proc0 ) then call alps_error_init !alps_io write ( * , '(a)' ) 'Starting ALPS===================================' write ( * , '(a)' ) \"Time:\" call output_time !alps_io write ( * , '(a)' ) '================================================' call display_credits !alps_io endif call mpi_barrier ( mpi_comm_world , ierror ) if ( proc0 ) write ( * , '(a)' ) 'All processes are up and running.' !Check to be sure nproc is even and greater than 2, otherwise shutdown: if (( mod ( nproc , 2 ) . ne . 0 ). or .( nproc . le . 2 )) call alps_error ( 0 ) !alps_io !Read parameters: if ( proc0 ) call init_param !alps_io !Split Problem Amongst Processors. !Pass relevant information from readin: call pass_instructions !alps_com if ( proc0 ) then !Allocate background distribution function f0: allocate ( f0 ( 1 : nspec , 0 : nperp , 0 : npar )); f0 = 0.d0 !Read in f0: call read_f0 !alps_io !Calculate pperp, ppar derivatives of f0: call derivative_f0 !alps_fns !Calculate best fit to f0: call determine_param_fit !alps_analyt !f0 not needed for dispersion calculation. !Deallocate to save space: deallocate ( f0 ) endif !Distribute input and derived parameters: call pass_distribution ! alps_com ! Once we know kperp, we can determine nmax and split the processes. ! The following three routines will also be called when kperp changes: call determine_nmax ! alps_fns call split_processes ! alps_fns ! All processes determine their Bessel function array: if (. NOT .( sproc . EQ . 0 )) call determine_bessel_array ! alps_fns call mpi_barrier ( mpi_comm_world , ierror ) !Either: !use_map=.true.  : !    use a scan over (omega,gamma) to local dispersion solutions: !OR !use_map=.false. : !    use user input roots as initial guesses for dispersion solutions: if ( use_map ) then if ( writeOut . and . proc0 ) & write ( * , '(a)' ) 'Map Search' call map_search !alps_fns else if ( writeOut . and . proc0 ) & write ( * , '(a)' ) 'Starting Secant Method' call refine_guess !alps_fns endif if ( n_scan . gt . 0 ) then !setting n_scan=0 turns off wavevector scanning select case ( scan_option ) case ( 1 ) !scan along perscribed paths in wavevector space: do ik = 1 , n_scan call om_scan ( ik ) !alps_fns enddo case ( 2 ) !scan along a plane in wavevector space: if ( n_scan == 2 ) then call om_double_scan !alps_fns else call alps_error ( 4 ) !alps_io endif case default !scan_option not selected call alps_error ( 3 ) !alps_io end select endif !Finalize MPI message passing call mpi_finalize ( ierror ) if ( proc0 ) then write ( * , '(a)' ) 'Finishing ALPS===================================' write ( * , '(a)' ) \"Time:\" call output_time write ( * , '(a)' ) '================================================' write ( unit_error , '(a)' ) 'Run completed without fatal error.' close ( unit_error ) endif end program alps","tags":"","url":"sourcefile/alps.f90.html"},{"title":"ALPS_fns.f90 – ALPS","text":"Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_fns !! This module contains the key numerical functions of ALPS. implicit none private :: int_T , int_T_res , integrate private :: integrate_res , landau_integrate , resU public :: derivative_f0 , disp , determine_bessel_array public :: determine_nmax , split_processes , secant , map_search public :: om_scan , om_double_scan contains subroutine derivative_f0 !! This subroutine calculates the perpendicular and parallel derivatives of the background velocity distribution function f0. use alps_var , only : f0 , pp , df0 , nperp , npar , nspec , arrayName , ns , qs , ms , bMpdrifts use alps_var , only : f0_rel , gamma_rel , pparbar_rel , nspec_rel , df0_rel , ngamma , npparbar use alps_var , only : current_int , density_int use alps_var , only : writeOut , pi , relativistic , usebM use alps_io , only : get_unused_unit use alps_fns_rel , only : derivative_f0_rel implicit none integer :: iperp !! Index for loop over perpendicular momentum. integer :: ipar !! Index for loop over parallel momentum. integer :: is !! Index of particle species. integer :: is_rel !! Index for relativistic species (if any). integer :: unit_f !! Unit for file i/o. logical :: OutDF !! Check whether output shall be written to file. logical :: any_relativistic !! Check whether any relativistic calculations are necessary. character ( 50 ) :: fmt !! Output format for file i/o. character ( 100 ) :: writename !! File name for file i/o. !double precision :: integrate !! Integral of the distribution function. KGK: replaced with density_int(is) double precision , dimension ( 0 : nspec ) :: charge !! Charge density. !! Zeroth index is sum over all species double precision :: dpperp !! Inifinitesimal step in perpendicular momentum. double precision :: dppar !! Inifinitesimal step in parallel momentum. allocate ( current_int ( 0 : nspec )); current_int = 0.d0 allocate ( density_int ( 0 : nspec )); density_int = 0.d0 if ( writeOut ) then write ( * , '(a)' )& '-=-=-=-=-=-=-=-=-' write ( * , '(a)' )& 'Calculating df0/dpperp, df0/ppar if necessary...' endif do is = 1 , nspec if ( usebM ( is )) then write ( * , '(a,i2)' ) ' Bi-Maxwellian/cold-plasma calculation: no derivatives necessary for species ' , is df0 ( is ,:,:,:) = 0.d0 else do iperp = 1 , nperp - 1 do ipar = 1 , npar - 1 !index 1-> vperp derivative df0 ( is , iperp , ipar , 1 ) = & ( f0 ( is , iperp + 1 , ipar ) - f0 ( is , iperp - 1 , ipar )) / & ( pp ( is , iperp + 1 , ipar , 1 ) - pp ( is , iperp - 1 , ipar , 1 )) !index 2-> vpar derivative df0 ( is , iperp , ipar , 2 ) = & ( f0 ( is , iperp , ipar + 1 ) - f0 ( is , iperp , ipar - 1 )) / & ( pp ( is , iperp , ipar + 1 , 2 ) - pp ( is , iperp , ipar - 1 , 2 )) enddo enddo endif enddo write ( * , '(a)' ) 'Derivatives calculated' !Output df/dv to file: OutDF = . false . if ( OutDF ) then if ( writeOut ) & write ( * , '(a)' ) 'Outputing df0/dpperp, df0/dppar' write ( fmt , '(a)' ) '(2es14.4e3,2es14.4e3)' do is = 1 , nspec if (. not . usebM ( is )) then dpperp = pp ( is , 2 , 2 , 1 ) - pp ( is , 1 , 2 , 1 ) dppar = abs ( pp ( is , 2 , 2 , 2 ) - pp ( is , 2 , 1 , 2 )) write ( writeName , '(3a,i0,a)' )& 'distribution/' , trim ( arrayName ), '_dfdv.' , is , '.array' call get_unused_unit ( unit_f ) open ( unit = unit_f , file = trim ( writeName ), status = 'replace' ) do iperp = 1 , nperp - 1 do ipar = 1 , npar - 1 write ( unit_f , fmt ) pp ( is , iperp , ipar , 1 ), pp ( is , iperp , ipar , 2 ),& df0 ( is , iperp , ipar , 1 ), df0 ( is , iperp , ipar , 2 ) enddo write ( unit_f , * ) enddo close ( unit_f ) endif enddo endif !End output charge = 0.d0 current_int = 0.d0 density_int = 0.d0 do is = 1 , nspec if ( usebM ( is )) then density_int ( is ) = 1.d0 charge ( is ) = ns ( is ) * qs ( is ) current_int ( is ) = ns ( is ) * qs ( is ) * & bMpdrifts ( is ) / ms ( is ) else density_int ( is ) = 0.d0 dpperp = pp ( is , 2 , 2 , 1 ) - pp ( is , 1 , 2 , 1 ) dppar = abs ( pp ( is , 2 , 2 , 2 ) - pp ( is , 2 , 1 , 2 )) do iperp = 0 , nperp do ipar = 0 , npar density_int ( is ) = density_int ( is ) + & pp ( is , iperp , ipar , 1 ) * f0 ( is , iperp , ipar ) * & 2.d0 * pi * dpperp * dppar charge ( is ) = charge ( is ) + & ns ( is ) * qs ( is ) * pp ( is , iperp , ipar , 1 ) * f0 ( is , iperp , ipar ) * & 2.d0 * pi * dpperp * dppar current_int ( is ) = current_int ( is ) + & ( ns ( is ) * qs ( is ) / ms ( is )) * pp ( is , iperp , ipar , 1 ) * pp ( is , iperp , ipar , 2 ) * & f0 ( is , iperp , ipar ) * & 2.d0 * pi * dpperp * dppar enddo enddo endif write ( * , '(a)' )& '-=-=-=-=' write ( * , '(a,i3,a)' )& 'Species ' , is , ':' write ( * , '(a, 2es14.4e3)' ) & ' Integration:              ' , density_int ( is ) write ( * , '(a, 2es14.4e3)' ) & ' Charge density:           ' , charge ( is ) write ( * , '(a, 2es14.4e3)' ) & ' Parallel current density: ' , current_int ( is ) enddo write ( * , '(a)' ) '-=-=-=-=' write ( * , '(a, es14.4e3)' ) ' Total charge density:           ' , sum ( charge ( 1 : nspec )) write ( * , '(a, es14.4e3)' ) ' Total parallel current density: ' , sum ( current_int ( 1 : nspec )) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=' if ( writeOut ) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' if ( writeOut ) write ( * , '(a)' ) 'Determine if relativistic calculation necessary' any_relativistic = . FALSE . is_rel = 0 do is = 1 , nspec if ( relativistic ( is )) then any_relativistic = . TRUE . is_rel = is_rel + 1 write ( * , '(a,i3,a,i3)' ) 'Species' , is , ' requires relativistic calculation. is_rel=' , is_rel endif enddo if ( any_relativistic ) then if ( writeOut ) write ( * , '(a,i4)' ) \"ngamma   = \" , ngamma if ( writeOut ) write ( * , '(a,i4)' ) \"npparbar = \" , npparbar nspec_rel = is_rel ! Allocate the relativistic fields (only on proc0 for now): allocate ( gamma_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) allocate ( pparbar_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) allocate ( f0_rel ( nspec_rel , 0 : ngamma , 0 : npparbar )) allocate ( df0_rel ( nspec_rel , 0 : ngamma , 0 : npparbar , 2 )) is_rel = 0 do is = 1 , nspec if ( relativistic ( is )) then is_rel = is_rel + 1 call derivative_f0_rel ( is , is_rel ) endif enddo else nspec_rel = 0 write ( * , '(a)' ) 'No relativistic calculation necessary.' if ( writeOut ) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' endif end subroutine derivative_f0 double complex function disp ( om ) !! This function returns the determinant of the dispersion tensor for a given frequency om. use alps_var , only : nlim , proc0 , nspec , ierror , sproc , relativistic use alps_var , only : wave , kperp , kpar , ns , qs , vA , chi0 , chi0_low use alps_var , only : usebM , kperp_norm use alps_nhds , only : calc_chi use alps_fns_rel , only : int_ee_rel use mpi implicit none double complex , intent ( in ) :: om !! Complex wave frequency \\omega. double complex :: chi_NHDS ( 3 , 3 ) !! Susceptibility tensor \\chi as calculated from NHDS in [[alps_nhds(module)]]. double complex :: chi_NHDS_low ( 3 , 3 , - 1 : 1 ) !! Susceptibility tensor \\chi as calculated from NHDS in [[alps_nhds(module)]]. double complex , dimension ( 1 : nspec , 1 : 3 , 1 : 3 ) :: schi !! Susceptibility tensor \\chi of individual process. double complex , dimension ( 1 : nspec , 1 : 3 , 1 : 3 , - 1 : 1 ) :: schi_low !! Susceptibility tensor \\chi of individual process for n=-1,0,1. double complex , dimension ( 1 : nspec , 1 : 3 , 1 : 3 ) :: chi !! Susceptibility tensor \\chi after summing over processes. double complex , dimension ( 1 : nspec , 1 : 3 , 1 : 3 , - 1 : 1 ) :: chi_low !! Susceptibility tensor \\chi after summing over process for n=0,\\pm 1. double complex , dimension ( 1 : 3 , 1 : 3 ) :: eps !! Dielectric tensor \\epsilon. double complex :: enx2 !! Index of refraction n_x&#94;2. double complex :: enz2 !! Index of refraction n_z&#94;2. double complex :: enxnz !! Index of refraction n_xn_z. integer :: is !! Index for species. integer :: nn !! Index for order of Bessel function. double complex , dimension ( 1 : nspec ) :: norm !! Normalisation for dispersion tensors. logical :: found_res_plus !! Check whether a resonance is found at positive n. logical :: found_res_minus !! Check whether a resonance is found at negative n. chi = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) if ( proc0 ) chi0 = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) if ( proc0 ) chi0_low = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) schi = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) schi_low = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) if ( proc0 ) then !Indices of refraction for the dispersion relation in NHDS normalisation (with an additional kperp**2): if ( kperp_norm ) then enx2 = kperp ** 2 enz2 = kpar ** 2 enxnz = kpar * kperp else enx2 = kperp ** 4 enz2 = kpar ** 2 * kperp ** 2 enxnz = kpar * kperp ** 3 endif else ! Integrate: ! c.f. Stix Equation 10.48; pg 255 ! Split into NHDS or ALPS routines: ! Only run the NHDS routine if useBM is on for the species !   and if process is handling n=0 according to split_processes: if ( usebM ( sproc ). and .( nlim ( 2 ). GE . 0 ). and .( nlim ( 1 ). EQ . 0 )) then ! This is the case to use NHDS for the calculation of chi: call calc_chi ( chi_NHDS , chi_NHDS_low , sproc , kpar , kperp , om ) ! Account for norm below, which is already included in NHDS: schi ( sproc , 1 , 1 ) = chi_NHDS ( 1 , 1 ) / ( ns ( sproc ) * qs ( sproc )) schi ( sproc , 2 , 2 ) = chi_NHDS ( 2 , 2 ) / ( ns ( sproc ) * qs ( sproc )) schi ( sproc , 3 , 3 ) = chi_NHDS ( 3 , 3 ) / ( ns ( sproc ) * qs ( sproc )) schi ( sproc , 1 , 2 ) = chi_NHDS ( 1 , 2 ) / ( ns ( sproc ) * qs ( sproc )) schi ( sproc , 1 , 3 ) = chi_NHDS ( 1 , 3 ) / ( ns ( sproc ) * qs ( sproc )) schi ( sproc , 2 , 3 ) = chi_NHDS ( 2 , 3 ) / ( ns ( sproc ) * qs ( sproc )) !WE DETERMINE CHI0_LOW [which only has contributions from n=0, \\pm 1] !FROM THE BIMAX CALCULATION. schi_low ( sproc , 1 , 1 ,:) = chi_NHDS_low ( 1 , 1 ,:) / ( ns ( sproc ) * qs ( sproc )) schi_low ( sproc , 2 , 2 ,:) = chi_NHDS_low ( 2 , 2 ,:) / ( ns ( sproc ) * qs ( sproc )) schi_low ( sproc , 3 , 3 ,:) = chi_NHDS_low ( 3 , 3 ,:) / ( ns ( sproc ) * qs ( sproc )) schi_low ( sproc , 1 , 2 ,:) = chi_NHDS_low ( 1 , 2 ,:) / ( ns ( sproc ) * qs ( sproc )) schi_low ( sproc , 1 , 3 ,:) = chi_NHDS_low ( 1 , 3 ,:) / ( ns ( sproc ) * qs ( sproc )) schi_low ( sproc , 2 , 3 ,:) = chi_NHDS_low ( 2 , 3 ,:) / ( ns ( sproc ) * qs ( sproc )) else do nn = nlim ( 1 ), nlim ( 2 ) call determine_resonances ( om , nn , found_res_plus , found_res_minus ) ! CHIij(nn) function calls: if ( nn == 0 ) then !xx term is zero !xy term is zero !xz term is zero !yy term: schi_low ( sproc , 2 , 2 , 0 ) = & full_integrate ( om , nn , 2 , found_res_plus ) schi ( sproc , 2 , 2 ) = schi ( sproc , 2 , 2 ) + & schi_low ( sproc , 2 , 2 , 0 ) !zz term: schi_low ( sproc , 3 , 3 , 0 ) = & full_integrate ( om , nn , 3 , found_res_plus ) schi ( sproc , 3 , 3 ) = schi ( sproc , 3 , 3 ) + & schi_low ( sproc , 3 , 3 , 0 ) !yz term: schi_low ( sproc , 2 , 3 , 0 ) = & full_integrate ( om , nn , 6 , found_res_plus ) schi ( sproc , 2 , 3 ) = schi ( sproc , 2 , 3 ) + & schi_low ( sproc , 2 , 3 , 0 ) elseif ( nn == 1 ) then !xx term: schi_low ( sproc , 1 , 1 , 1 ) = & full_integrate ( om , nn , 1 , found_res_plus ) schi_low ( sproc , 1 , 1 , - 1 ) = & full_integrate ( om , - nn , 1 , found_res_minus ) schi ( sproc , 1 , 1 ) = schi ( sproc , 1 , 1 ) + & schi_low ( sproc , 1 , 1 , 1 ) + schi_low ( sproc , 1 , 1 , - 1 ) !yy term: schi_low ( sproc , 2 , 2 , 1 ) = & full_integrate ( om , nn , 2 , found_res_plus ) schi_low ( sproc , 2 , 2 , - 1 ) = & full_integrate ( om , - nn , 2 , found_res_minus ) schi ( sproc , 2 , 2 ) = schi ( sproc , 2 , 2 ) + & schi_low ( sproc , 2 , 2 , 1 ) + schi_low ( sproc , 2 , 2 , - 1 ) !zz term: schi_low ( sproc , 3 , 3 , 1 ) = & full_integrate ( om , nn , 3 , found_res_plus ) schi_low ( sproc , 3 , 3 , - 1 ) = & full_integrate ( om , - nn , 3 , found_res_minus ) schi ( sproc , 3 , 3 ) = schi ( sproc , 3 , 3 ) + & schi_low ( sproc , 3 , 3 , 1 ) + schi_low ( sproc , 3 , 3 , - 1 ) !xy term: schi_low ( sproc , 1 , 2 , 1 ) = & full_integrate ( om , nn , 4 , found_res_plus ) schi_low ( sproc , 1 , 2 , - 1 ) = & full_integrate ( om , - nn , 4 , found_res_minus ) schi ( sproc , 1 , 2 ) = schi ( sproc , 1 , 2 ) + & schi_low ( sproc , 1 , 2 , 1 ) + schi_low ( sproc , 1 , 2 , - 1 ) !xz term: schi_low ( sproc , 1 , 3 , 1 ) = & full_integrate ( om , nn , 5 , found_res_plus ) schi_low ( sproc , 1 , 3 , - 1 ) = & full_integrate ( om , - nn , 5 , found_res_minus ) schi ( sproc , 1 , 3 ) = schi ( sproc , 1 , 3 ) + & schi_low ( sproc , 1 , 3 , 1 ) + schi_low ( sproc , 1 , 3 , - 1 ) !yz term: schi_low ( sproc , 2 , 3 , 1 ) = & full_integrate ( om , nn , 6 , found_res_plus ) schi_low ( sproc , 2 , 3 , - 1 ) = & full_integrate ( om , - nn , 6 , found_res_minus ) schi ( sproc , 2 , 3 ) = schi ( sproc , 2 , 3 ) + & schi_low ( sproc , 2 , 3 , 1 ) + schi_low ( sproc , 2 , 3 , - 1 ) else !xx term: schi ( sproc , 1 , 1 ) = schi ( sproc , 1 , 1 ) + & full_integrate ( om , nn , 1 , found_res_plus ) + & full_integrate ( om , - nn , 1 , found_res_minus ) !yy term: schi ( sproc , 2 , 2 ) = schi ( sproc , 2 , 2 ) + & full_integrate ( om , nn , 2 , found_res_plus ) + & full_integrate ( om , - nn , 2 , found_res_minus ) !zz term: schi ( sproc , 3 , 3 ) = schi ( sproc , 3 , 3 ) + & full_integrate ( om , nn , 3 , found_res_plus ) + & full_integrate ( om , - nn , 3 , found_res_minus ) !xy term: schi ( sproc , 1 , 2 ) = schi ( sproc , 1 , 2 ) + & full_integrate ( om , nn , 4 , found_res_plus ) + & full_integrate ( om , - nn , 4 , found_res_minus ) !xz term: schi ( sproc , 1 , 3 ) = schi ( sproc , 1 , 3 ) + & full_integrate ( om , nn , 5 , found_res_plus ) + & full_integrate ( om , - nn , 5 , found_res_minus ) !yz term: schi ( sproc , 2 , 3 ) = schi ( sproc , 2 , 3 ) + & full_integrate ( om , nn , 6 , found_res_plus ) + & full_integrate ( om , - nn , 6 , found_res_minus ) endif enddo ! Add in ee term: if ( nlim ( 1 ) == 0 ) then if ( relativistic ( sproc )) then if ( kperp_norm ) then schi ( sproc , 3 , 3 ) = schi ( sproc , 3 , 3 ) + int_ee_rel ( om ) else schi ( sproc , 3 , 3 ) = schi ( sproc , 3 , 3 ) + kperp ** 2 * int_ee_rel ( om ) endif else if ( kperp_norm ) then schi ( sproc , 3 , 3 ) = schi ( sproc , 3 , 3 ) + int_ee ( om ) schi_low ( sproc , 3 , 3 , 0 ) = schi_low ( sproc , 3 , 3 , 0 ) + int_ee ( om ) else schi ( sproc , 3 , 3 ) = schi ( sproc , 3 , 3 ) + kperp ** 2 * int_ee ( om ) schi_low ( sproc , 3 , 3 , 0 ) = schi_low ( sproc , 3 , 3 , 0 ) + kperp ** 2 * int_ee ( om ) endif endif endif endif norm ( sproc ) = ns ( sproc ) * qs ( sproc ) schi ( sproc , 1 , 1 ) = schi ( sproc , 1 , 1 ) * norm ( sproc ) schi ( sproc , 2 , 2 ) = schi ( sproc , 2 , 2 ) * norm ( sproc ) schi ( sproc , 3 , 3 ) = schi ( sproc , 3 , 3 ) * norm ( sproc ) schi ( sproc , 1 , 2 ) = schi ( sproc , 1 , 2 ) * norm ( sproc ) schi ( sproc , 1 , 3 ) = schi ( sproc , 1 , 3 ) * norm ( sproc ) schi ( sproc , 2 , 3 ) = schi ( sproc , 2 , 3 ) * norm ( sproc ) schi_low ( sproc , 1 , 1 ,:) = schi_low ( sproc , 1 , 1 ,:) * norm ( sproc ) schi_low ( sproc , 2 , 2 ,:) = schi_low ( sproc , 2 , 2 ,:) * norm ( sproc ) schi_low ( sproc , 3 , 3 ,:) = schi_low ( sproc , 3 , 3 ,:) * norm ( sproc ) schi_low ( sproc , 1 , 2 ,:) = schi_low ( sproc , 1 , 2 ,:) * norm ( sproc ) schi_low ( sproc , 1 , 3 ,:) = schi_low ( sproc , 1 , 3 ,:) * norm ( sproc ) schi_low ( sproc , 2 , 3 ,:) = schi_low ( sproc , 2 , 3 ,:) * norm ( sproc ) endif ! Return the schi to proc0: call MPI_REDUCE ( schi , chi , size ( chi ),& MPI_DOUBLE_COMPLEX , MPI_SUM , 0 , MPI_COMM_WORLD , ierror ) call MPI_REDUCE ( schi_low , chi_low , size ( chi_low ),& MPI_DOUBLE_COMPLEX , MPI_SUM , 0 , MPI_COMM_WORLD , ierror ) if ( proc0 ) then !Calculate dielectric tensor epsilon: !The global variable 'chi0' is used !for heating & eigenfunction calculation. !The global variable 'chi0_low' is used !for calculations for the n=0 and \\pm 1 !heating mechanisms. if ( kperp_norm ) then chi0 = chi / ( om * om * vA * vA ) chi0_low = chi_low / ( om * om * vA * vA ) else chi0 = chi / ( om * om * vA * vA * kperp * kperp ) chi0_low = chi_low / ( om * om * vA * vA * kperp * kperp ) endif chi0 (:, 2 , 1 ) =- chi0 (:, 1 , 2 ) chi0 (:, 3 , 1 ) = chi0 (:, 1 , 3 ) chi0 (:, 3 , 2 ) =- chi0 (:, 2 , 3 ) chi0_low (:, 2 , 1 ,:) =- chi0_low (:, 1 , 2 ,:) chi0_low (:, 3 , 1 ,:) = chi0_low (:, 1 , 3 ,:) chi0_low (:, 3 , 2 ,:) =- chi0_low (:, 2 , 3 ,:) !write(*,*)'-=-=-=-' !write(*,*)'-=-=-=- n = 0' !write(*,*)chi0_low(1,1,1,0),chi0_low(1,1,2,0),chi0_low(1,1,3,0) !write(*,*)chi0_low(1,2,1,0),chi0_low(1,2,2,0),chi0_low(1,2,3,0) !write(*,*)chi0_low(1,3,1,0),chi0_low(1,3,2,0),chi0_low(1,3,3,0) !write(*,*)'-=-=-=- n = \\pm 1' !write(*,*)chi0_low(1,1,1,1),chi0_low(1,1,2,1),chi0_low(1,1,3,1) !write(*,*)chi0_low(1,2,1,1),chi0_low(1,2,2,1),chi0_low(1,2,3,1) !write(*,*)chi0_low(1,3,1,1),chi0_low(1,3,2,1),chi0_low(1,3,3,1) wave = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) eps = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) ! Sum over species: do is = 1 , nspec eps ( 1 , 1 ) = eps ( 1 , 1 ) + chi ( is , 1 , 1 ) eps ( 2 , 2 ) = eps ( 2 , 2 ) + chi ( is , 2 , 2 ) eps ( 3 , 3 ) = eps ( 3 , 3 ) + chi ( is , 3 , 3 ) eps ( 1 , 2 ) = eps ( 1 , 2 ) + chi ( is , 1 , 2 ) eps ( 1 , 3 ) = eps ( 1 , 3 ) + chi ( is , 1 , 3 ) eps ( 2 , 3 ) = eps ( 2 , 3 ) + chi ( is , 2 , 3 ) !Trouble shooting electron firehose !write(*,'(6es14.4,i3)')chi0(is,1,1),chi0(is,1,2),chi0(is,1,3),is !write(*,'(6es14.4,i3)')chi0(is,2,1),chi0(is,2,2),chi0(is,2,3),is !write(*,'(6es14.4,i3)')chi0(is,3,1),chi0(is,3,2),chi0(is,3,3),is enddo ! Exploit symmetry of epsilon tensor: eps ( 2 , 1 ) = - eps ( 1 , 2 ) eps ( 3 , 1 ) = eps ( 1 , 3 ) eps ( 3 , 2 ) = - eps ( 2 , 3 ) ! Add the unit tensor (in our normalisation): if ( kperp_norm ) then eps ( 1 , 1 ) = eps ( 1 , 1 ) + ( om * vA ) ** 2 eps ( 2 , 2 ) = eps ( 2 , 2 ) + ( om * vA ) ** 2 eps ( 3 , 3 ) = eps ( 3 , 3 ) + ( om * vA ) ** 2 else eps ( 1 , 1 ) = eps ( 1 , 1 ) + ( kperp * om * vA ) ** 2 eps ( 2 , 2 ) = eps ( 2 , 2 ) + ( kperp * om * vA ) ** 2 eps ( 3 , 3 ) = eps ( 3 , 3 ) + ( kperp * om * vA ) ** 2 endif !Calculate dispersion tensor: !wave = ( eps_xx - nz&#94;2  eps_xy              eps_xz + nxnz ) !       ( eps_yx         eps_yy -nz&#94;2 -nx&#94;2  eps_yz        ) !       ( eps_zx + nxnz  eps_zy              eps_zz - nx&#94;2 ) wave ( 1 , 1 ) = eps ( 1 , 1 ) - enz2 wave ( 2 , 2 ) = eps ( 2 , 2 ) - enz2 - enx2 wave ( 3 , 3 ) = eps ( 3 , 3 ) - enx2 wave ( 1 , 3 ) = eps ( 1 , 3 ) + enxnz wave ( 1 , 2 ) = eps ( 1 , 2 ) wave ( 2 , 3 ) = eps ( 2 , 3 ) ! Exploit symmetry of dispersion tensor: wave ( 2 , 1 ) = - wave ( 1 , 2 ) wave ( 3 , 1 ) = wave ( 1 , 3 ) wave ( 3 , 2 ) = - wave ( 2 , 3 ) !-=-=-=-=-=- !Calculate determinant of the dispersion tensor: !The below relies on the symmetries of the T_n tensor: !Again, c.f. Stix Equation 10.48; pg 255 !--------------------------------------------------------------------- disp = wave ( 1 , 1 ) * ( wave ( 2 , 2 ) * wave ( 3 , 3 ) + wave ( 2 , 3 ) ** 2 ) + & 2.d0 * wave ( 1 , 2 ) * wave ( 2 , 3 ) * wave ( 1 , 3 ) - wave ( 1 , 3 ) ** 2 * wave ( 2 , 2 ) + & wave ( 1 , 2 ) ** 2 * wave ( 3 , 3 ) endif call mpi_bcast ( disp , 1 , MPI_DOUBLE_COMPLEX , 0 , MPI_COMM_WORLD , ierror ) !Make sure all processors have completed calculation to avoid !cross contamination with map and root searches call mpi_barrier ( mpi_comm_world , ierror ) return end function disp subroutine determine_resonances ( om , nn , found_res_plus , found_res_minus ) !! This subroutine determines whether any kinetic resonances are located in the integration domain. use alps_var , only : npar , pp , vA , ms , qs , sproc , kpar , nperp use alps_var , only : positions_principal , relativistic use alps_io , only : alps_error implicit none double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: nn !! Order of Bessel function. logical , intent ( out ) :: found_res_plus !! Check whether a resonance is found at positive n. logical , intent ( out ) :: found_res_minus !! Check whether a resonance is found at negative n. integer :: iperp !! Index to loop over perpendicular momentum. integer :: ipar !! Index to loop over parallel momentum. double precision :: dppar !! Inifinitesimal step in parallel momentum. double precision :: gamma !! Lorentz factor \\Gamma. double complex :: p_res !! Complex resonance momentum. dppar = pp ( sproc , 2 , 2 , 2 ) - pp ( sproc , 2 , 1 , 2 ) found_res_plus = . FALSE . found_res_minus = . FALSE . if ( relativistic ( sproc )) then ! The following checks for resonances in (pperp,ppar)-space rather than in (Gamma,pparbar)-space: do iperp = 0 , nperp do ipar = 0 , npar - 1 gamma = sqrt (( pp ( sproc , iperp , ipar , 1 ) ** 2 + & pp ( sproc , iperp , ipar , 2 ) ** 2 ) * vA ** 2 / ms ( sproc ) ** 2 + 1.d0 ) ! positive n: p_res = ( gamma * ms ( sproc ) * om - 1.d0 * nn * qs ( sproc )) / kpar if (( pp ( sproc , 2 , ipar , 2 ). LE . real ( p_res )). and .& ( pp ( sproc , 2 , ipar + 1 , 2 ). GT . real ( p_res ))) found_res_plus = . TRUE . ! negative n: p_res = ( gamma * ms ( sproc ) * om + 1.d0 * nn * qs ( sproc )) / kpar if (( pp ( sproc , 2 , ipar , 2 ). LE . real ( p_res )). and .& ( pp ( sproc , 2 , ipar + 1 , 2 ). GT . real ( p_res ))) found_res_minus = . TRUE . enddo enddo else ! non-relativistic case: ! positive n: ipar = 0 p_res = ( ms ( sproc ) * om - 1.d0 * nn * qs ( sproc )) / kpar do while (( ipar . LE .( npar - 2 )). AND .(. NOT . found_res_plus )) ipar = ipar + 1 if (( pp ( sproc , 2 , ipar , 2 ). LE . real ( p_res )). and .& ( pp ( sproc , 2 , ipar + 1 , 2 ). GT . real ( p_res ))) found_res_plus = . TRUE . enddo ! negative n: ipar = 0 p_res = ( ms ( sproc ) * om + 1.d0 * nn * qs ( sproc )) / kpar do while (( ipar . LE .( npar - 2 )). AND .(. NOT . found_res_minus )) ipar = ipar + 1 if (( pp ( sproc , 2 , ipar , 2 ). LE . real ( p_res )). and .& ( pp ( sproc , 2 , ipar + 1 , 2 ). GT . real ( p_res ))) found_res_minus = . TRUE . enddo ! Check if there is a resonance right outside the integration domain: p_res = ( ms ( sproc ) * om - 1.d0 * nn * qs ( sproc )) / kpar if (( real ( p_res ). LT . pp ( sproc , 2 , 1 , 2 )). AND .& ( real ( p_res ). GE .( pp ( sproc , 2 , 1 , 2 ) - ( 1.d0 * positions_principal ) * dppar ))) found_res_plus = . TRUE . if (( real ( p_res ). GE . pp ( sproc , 2 , npar - 1 , 2 )). AND .& ( real ( p_res ). LT .( pp ( sproc , 2 , npar - 1 , 2 ) + ( 1.d0 * positions_principal ) * dppar ))) found_res_plus = . TRUE . p_res = ( ms ( sproc ) * om + 1.d0 * nn * qs ( sproc )) / kpar if (( real ( p_res ). LT . pp ( sproc , 2 , 1 , 2 )). AND .& ( real ( p_res ). GE .( pp ( sproc , 2 , 1 , 2 ) - ( 1.d0 * positions_principal ) * dppar ))) found_res_minus = . TRUE . if (( real ( p_res ). GE . pp ( sproc , 2 , npar - 1 , 2 )). AND .& ( real ( p_res ). LT .( pp ( sproc , 2 , npar - 1 , 2 ) + ( 1.d0 * positions_principal ) * dppar ))) found_res_minus = . TRUE . endif end subroutine determine_resonances double complex function full_integrate ( om , nn , mode , found_res ) !! This function returns the full integral expression according to Eq. (2.9) in the code paper. use alps_var , only : npar , relativistic , sproc use alps_fns_rel , only : integrate_res_rel , landau_integrate_rel implicit none double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: mode !! Index of the entries in the T-tensor of Eq. (2.10). logical , intent ( in ) :: found_res !! Check whether a resonance is found. full_integrate = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) if (. not . found_res ) then !Brute force integrate full_integrate = integrate ( om , nn , mode , 1 , npar - 1 ) elseif ( found_res . and . relativistic ( sproc )) then if ( aimag ( om ). GT . 0.d0 ) then full_integrate = integrate_res_rel ( om , nn , mode ) elseif ( aimag ( om ). LT . 0.d0 ) then full_integrate = integrate_res_rel ( om , nn , mode ) + 2.d0 * landau_integrate_rel ( om , nn , mode ) elseif ( aimag ( om ). EQ . 0.d0 ) then full_integrate = integrate_res_rel ( om , nn , mode ) + landau_integrate_rel ( om , nn , mode ) endif elseif (( found_res ). and .( aimag ( om ). GT . 0.d0 )) then !Brute force integrate full_integrate = integrate_res ( om , nn , mode ) elseif (( found_res ). and .( aimag ( om ). LT . 0.d0 )) then !Landau Integral full_integrate = integrate_res ( om , nn , mode ) + 2.d0 * landau_integrate ( om , nn , mode ) elseif (( found_res ). and .( aimag ( om ). EQ . 0.d0 )) then full_integrate = integrate_res ( om , nn , mode ) + landau_integrate ( om , nn , mode ) endif return end function full_integrate double complex function integrate ( om , nn , mode , iparmin , iparmax ) !! This function performs the integral in Eq. (2.9) of the code paper, but without !! accounting for the Landau contour integral. It is called by [[full_integrate(function)]]. use alps_var , only : nperp , pp , pi , sproc implicit none double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: mode !! Index of the entries in the T-tensor of Eq. (2.10). integer :: iparmin !! Minimum limit index of parallel momentum for integration. integer :: iparmax !! Maximum limit index of parallel momentum for integration. integer :: iperp !! Index to loop over perpendicular momentum. integer :: ipar !! Index to loop over parallel momentum. double precision :: dpperp !! Inifinitesimal step in perpendicular momentum. double precision :: dppar !! Inifinitesimal step in parallel momentum. integrate = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) dpperp = pp ( sproc , 2 , 2 , 1 ) - pp ( sproc , 1 , 2 , 1 ) dppar = abs ( pp ( sproc , 2 , 2 , 2 ) - pp ( sproc , 2 , 1 , 2 )) integrate = integrate + & 2.d0 * resU ( om , nn , 1 , iparmin ) * int_T ( nn , 1 , iparmin , mode ) + & 2.d0 * resU ( om , nn , 1 , iparmax ) * int_T ( nn , 1 , iparmax , mode ) + & resU ( om , nn , nperp - 1 , iparmin ) * int_T ( nn , nperp - 1 , iparmin , mode ) + & resU ( om , nn , nperp - 1 , iparmax ) * int_T ( nn , nperp - 1 , iparmax , mode ) do iperp = 2 , nperp - 2 do ipar = iparmin + 1 , iparmax - 1 integrate = integrate + 4.d0 * resU ( om , nn , iperp , ipar ) * int_T ( nn , iperp , ipar , mode ) enddo integrate = integrate + & 2.d0 * ( resU ( om , nn , iperp , iparmin ) * int_T ( nn , iperp , iparmin , mode ) + & resU ( om , nn , iperp , iparmax ) * int_T ( nn , iperp , iparmax , mode ) ) enddo do ipar = iparmin + 1 , iparmax - 1 integrate = integrate + & 2.d0 * ( 2.d0 * resU ( om , nn , 1 , ipar ) * int_T ( nn , 1 , ipar , mode ) + & resU ( om , nn , nperp - 1 , ipar ) * int_T ( nn , nperp - 1 , ipar , mode ) ) enddo integrate = 2.d0 * pi * integrate * dpperp * dppar * 0.25d0 return end function integrate double complex function integrate_res ( om , nn , mode ) !! This function performs the integration near resonances as described in Section 3.1 of the code paper. It is only called if resonances are present in or near the integration domain. use alps_var , only : nperp , npar , pp , ms , qs , kpar , pi , sproc use alps_var , only : positions_principal , n_resonance_interval , Tlim implicit none double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: mode !! Index of the entries in the T-tensor of Eq. (2.10). integer :: ipar_res !! Index of the nearest parallel momentum to the resonance. integer :: ipar !! Index to loop over parallel momentum. integer :: iperp !! Index to loop over perpendicular momentum. integer :: ntiny !! Small steps for integration near pole according to Eq. (3.5). integer :: lowerlimit !! Index of lower limit for integration according to Eq. (3.5). integer :: upperlimit !! Index of upper limit for integration according to Eq. (3.5). double precision :: dpperp !! Inifinitesimal step in perpendicular momentum. double precision :: dppar !! Inifinitesimal step in parallel momentum. double precision :: capDelta !! Size of interval \\Delta for integration according to Eq. (3.5). double precision :: smdelta !! Size of sub-interval \\delta for integration according to Eq. (3.5). double precision :: denomR !! Real part of denominator of Eq. (3.6). double precision :: denomI !! Imaginary part of denominator of Eq. (3.6). double precision :: ppar !! Parallel momentum. double precision :: correction !! Correction factor for finite size of interval \\delta. double complex :: p_res !! Resonance momentum. double complex :: ii !! Imaginary unit. double complex :: integrate_norm !! Variable to host integral without accounting for resonances. double complex :: gprimetr !! Function g&#94;{\\prime} in Eq. (3.6). logical :: found_res !! Check whether a resonance is found. dpperp = pp ( sproc , 2 , 2 , 1 ) - pp ( sproc , 1 , 2 , 1 ) dppar = pp ( sproc , 2 , 2 , 2 ) - pp ( sproc , 2 , 1 , 2 ) integrate_res = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) integrate_norm = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) ! determine the position of the resonance (i.e., the step LEFT of it): ipar = 0 ipar_res = 0 found_res = . FALSE . p_res = ( ms ( sproc ) * om - 1.d0 * nn * qs ( sproc )) / kpar do while (( ipar . LT .( npar - 2 )). AND .(. NOT . found_res )) ipar = ipar + 1 if (( pp ( sproc , 2 , ipar + 1 , 2 ). GT . real ( p_res )). and .& ( pp ( sproc , 2 , ipar , 2 ). LE . real ( p_res ))) then ipar_res = ipar found_res = . TRUE . endif enddo ! Handle resonances that are right outside the integration domain: p_res = ( ms ( sproc ) * om - ( 1.d0 * nn ) * qs ( sproc )) / kpar do ipar = 0 , positions_principal if (( real ( p_res ). GE .( pp ( sproc , 2 , 0 , 2 ) - dppar * ipar )). AND .& ( real ( p_res ). LT .( pp ( sproc , 2 , 0 , 2 ) - dppar * ( ipar - 1 )))) ipar_res = - ipar if (( real ( p_res ). GE .( pp ( sproc , 2 , npar - 1 , 2 ) + dppar * ipar )). AND .& ( real ( p_res ). LT .( pp ( sproc , 2 , npar - 1 , 2 ) + dppar * ( ipar + 1 )))) ipar_res = npar - 1 + ipar enddo ! If the resonance is close to the edge, do the normal integration: if (( ipar_res - positions_principal ). LE . 2 ) then integrate_res = integrate ( om , nn , mode , ipar_res + positions_principal , npar - 1 ) return endif if (( ipar_res + positions_principal ). GE .( npar - 2 )) then integrate_res = integrate ( om , nn , mode , 1 , ipar_res - positions_principal ) return endif ! positions_principal defines how close we can go to ipar_res with the \"normal\" integration. ! the following part is the normal function \"integrate\" on the left and on the right of ipar_res: ! left: lowerlimit = ipar_res - positions_principal integrate_norm = integrate ( om , nn , mode , 1 , lowerlimit ) ! right: if ( abs ( real ( p_res ) - pp ( sproc , 2 , ipar_res , 2 )). LT .( 0.5d0 * dppar )) then upperlimit = ipar_res + positions_principal + 1 else upperlimit = ipar_res + positions_principal + 2 endif integrate_norm = integrate_norm + integrate ( om , nn , mode , upperlimit , npar - 1 ) ! The following part includes the analytic switch described in Section 3.1 of the code paper ! We call the function that needs to be integrated WITHOUT the resonance part funct_g. ! We linearize this function. Now we can calculate the even part of the integration. ! We set Delta so that it starts at ipar_res-positions_principal. In that way, there is only ! a tiny rest left on the right side that needs to be integrated. ! split the range between the resonance and the upper limit into n_resonance_interval steps: denomR = real ( p_res ) denomI = aimag ( p_res ) capDelta = real ( p_res ) - pp ( sproc , 1 , ipar_res - positions_principal , 2 ) smdelta = capDelta / ( 1.d0 * n_resonance_interval ) if ( abs ( denomI ). GT . Tlim ) then ! regular integration according to Eq. (3.5) of the code paper: ! Integrate the boundaries: ppar = real ( p_res ) ! left end of integration interval: ! At iperp=1, we are already missing the part from iperp=0, where we should actually start. Therefore, we use 4 instead of 2 in the trapezoid integration: integrate_res = integrate_res + 2.d0 * funct_g ( ppar , 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - 2.d0 * funct_g ( 2.d0 * denomR - ppar , 1 , om , nn , mode ) / ( ppar - denomR + ii * denomI ) integrate_res = integrate_res + funct_g ( ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - funct_g ( 2.d0 * denomR - ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR + ii * denomI ) ppar = real ( p_res ) + capDelta ! right end of integration interval: integrate_res = integrate_res + 2.d0 * funct_g ( ppar , 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - 2.d0 * funct_g ( 2.d0 * denomR - ppar , 1 , om , nn , mode ) / ( ppar - denomR + ii * denomI ) integrate_res = integrate_res + funct_g ( ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - funct_g ( 2.d0 * denomR - ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR + ii * denomI ) do iperp = 2 , nperp - 2 do ipar = 1 , n_resonance_interval - 1 ppar = real ( p_res ) + smdelta * ipar integrate_res = integrate_res + 4.d0 * funct_g ( ppar , iperp , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - 4.d0 * funct_g ( 2.d0 * denomR - ppar , iperp , om , nn , mode ) / ( ppar - denomR + ii * denomI ) enddo ppar = real ( p_res ) ! left end of integration interval: integrate_res = integrate_res + 2.d0 * funct_g ( ppar , iperp , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - 2.d0 * funct_g ( 2.d0 * denomR - ppar , iperp , om , nn , mode ) / ( ppar - denomR + ii * denomI ) ppar = real ( p_res ) + capDelta ! right end of integration interval: integrate_res = integrate_res + 2.d0 * funct_g ( ppar , iperp , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - 2.d0 * funct_g ( 2.d0 * denomR - ppar , iperp , om , nn , mode ) / ( ppar - denomR + ii * denomI ) enddo do ipar = 1 , n_resonance_interval - 1 ppar = real ( p_res ) + smdelta * ipar ! At iperp=1, we are already missing the part from iperp=0, where we should actually start. Therefore, we use 4 instead of 2 in the trapezoid integration: integrate_res = integrate_res + 4.d0 * funct_g ( ppar , 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - 4.d0 * funct_g ( 2.d0 * denomR - ppar , 1 , om , nn , mode ) / ( ppar - denomR + ii * denomI ) integrate_res = integrate_res + 2.d0 * funct_g ( ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI ) integrate_res = integrate_res - 2.d0 * funct_g ( 2.d0 * denomR - ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR + ii * denomI ) enddo else ! analytic approximation according to Eq. (3.6) of the code paper: ! For ppar=real(p_res) (left end of integration interval): ppar = real ( p_res ) ! In this case, ppar is equal to denomR, so: no integration needed ! For ppar=capDelta+real(p_res) (right end of integration interval): ppar = real ( p_res ) + capDelta ! For iperp = 1: !(at iperp=1, we are already missing the part from iperp=0, where we should actually start. Therefore, we use 4 instead of 2 in the trapezoid integration): gprimetr = ( funct_g ( denomR + dppar , 1 , om , nn , mode ) - funct_g ( denomR - dppar , 1 , om , nn , mode )) / ( 2.d0 * dppar ) integrate_res = integrate_res + 2.d0 * 2.d0 * gprimetr * (( ppar - denomR ) ** 2 / (( ppar - denomR ) ** 2 + denomI ** 2 )) ! For iperp = nperp-1: gprimetr = ( funct_g ( denomR + dppar , nperp - 1 , om , nn , mode ) - funct_g ( denomR - dppar , nperp - 1 , om , nn , mode )) / ( 2.d0 * dppar ) integrate_res = integrate_res + 2.d0 * gprimetr * (( ppar - denomR ) ** 2 / (( ppar - denomR ) ** 2 + denomI ** 2 )) ! The following lines account for the first term in Eq. (3.6) in the code paper, which is evaluated via Eq. (3.7): ! We have to divide by smdelta, because the integral (at the end) is multiplied by smdelta as the integration measure. if ( denomI . GT . 0.d0 ) then integrate_res = integrate_res + 2.d0 * 2.d0 * ii * pi * funct_g ( denomR , 1 , om , nn , mode ) / smdelta integrate_res = integrate_res + 2.d0 * ii * pi * funct_g ( denomR , nperp - 1 , om , nn , mode ) / smdelta else if ( denomI . LT . 0.d0 ) then integrate_res = integrate_res - 2.d0 * 2.d0 * ii * pi * funct_g ( denomR , 1 , om , nn , mode ) / smdelta integrate_res = integrate_res - 2.d0 * ii * pi * funct_g ( denomR , nperp - 1 , om , nn , mode ) / smdelta else if ( denomI . EQ . 0.d0 ) then integrate_res = integrate_res + 0.d0 endif do iperp = 2 , nperp - 2 do ipar = 1 , n_resonance_interval - 1 ppar = real ( p_res ) + smdelta * ipar gprimetr = ( funct_g ( denomR + dppar , iperp , om , nn , mode ) - & funct_g ( denomR - dppar , iperp , om , nn , mode )) / ( 2.d0 * dppar ) ! This is the second term in Eq. (3.6): integrate_res = integrate_res + 4.d0 * 2.d0 * gprimetr * (( ppar - denomR ) ** 2 / (( ppar - denomR ) ** 2 + denomI ** 2 )) enddo ppar = real ( p_res ) ! In this case, ppar is equal to denomR, so: no integration needed ppar = real ( p_res ) + capDelta gprimetr = ( funct_g ( denomR + dppar , iperp , om , nn , mode ) - funct_g ( denomR - dppar , iperp , om , nn , mode )) / ( 2.d0 * dppar ) integrate_res = integrate_res + 2.d0 * 2.d0 * gprimetr * (( ppar - denomR ) ** 2 / (( ppar - denomR ) ** 2 + denomI ** 2 )) ! The following lines account for the first term in Eq. (3.6) in the code paper, which is evaluated via Eq. (3.7): ! We have to divide by smdelta, because the integral (at the end) is multiplied by smdelta as the integration measure. if ( denomI . GT . 0.d0 ) then integrate_res = integrate_res + 4.d0 * ii * pi * funct_g ( denomR , iperp , om , nn , mode ) / smdelta else if ( denomI . LT . 0.d0 ) then integrate_res = integrate_res - 4.d0 * ii * pi * funct_g ( denomR , iperp , om , nn , mode ) / smdelta else if ( denomI . EQ . 0.d0 ) then integrate_res = integrate_res + 0.d0 endif enddo do ipar = 1 , n_resonance_interval - 1 ppar = real ( p_res ) + smdelta * ipar gprimetr = ( funct_g ( denomR + dppar , 1 , om , nn , mode ) - funct_g ( denomR - dppar , 1 , om , nn , mode )) / ( 2.d0 * dppar ) integrate_res = integrate_res + 4.d0 * 2.d0 * gprimetr * (( ppar - denomR ) ** 2 / (( ppar - denomR ) ** 2 + denomI ** 2 )) gprimetr = ( funct_g ( denomR + dppar , nperp - 1 , om , nn , mode ) - funct_g ( denomR - dppar , nperp - 1 , om , nn , mode )) / ( 2.d0 * dppar ) integrate_res = integrate_res + 2.d0 * 2.d0 * gprimetr * (( ppar - denomR ) ** 2 / (( ppar - denomR ) ** 2 + denomI ** 2 )) enddo endif ! Calculate tiny rest left between the point real(p_res)+capDelta and the position ! pp(sproc,2,upperlimit,2). We split this interval into steps of roughly size smdelta: ntiny = int (( pp ( sproc , 2 , upperlimit , 2 ) - real ( p_res ) - capDelta ) / smdelta ) ! This integration performs Eq. (3.2) directly on the tiny rest interval. if ( ntiny . GT . 0 ) then ! Correct for the fact that smdelta is not exactly the step width in the tiny-rest integration: correction = (( pp ( sproc , 2 , upperlimit , 2 ) - real ( p_res ) - capDelta ) / ( 1.d0 * ntiny )) / smdelta ppar = real ( p_res ) + capDelta integrate_res = integrate_res + & 2.d0 * correction * ( funct_g ( ppar , 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI )) integrate_res = integrate_res + & correction * ( funct_g ( ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI )) ppar = real ( p_res ) + capDelta + correction * smdelta * ntiny integrate_res = integrate_res + & 2.d0 * correction * ( funct_g ( ppar , 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI )) integrate_res = integrate_res + & correction * ( funct_g ( ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI )) do iperp = 2 , nperp - 2 do ipar = 1 , ntiny - 1 ppar = real ( p_res ) + capDelta + correction * smdelta * ipar integrate_res = integrate_res + 4.d0 * & correction * ( funct_g ( ppar , iperp , om , nn , mode ) / ( ppar - denomR - ii * denomI )) enddo ppar = real ( p_res ) + capDelta integrate_res = integrate_res + 2.d0 * & correction * ( funct_g ( ppar , iperp , om , nn , mode ) / ( ppar - denomR - ii * denomI )) ppar = real ( p_res ) + capDelta + correction * smdelta * ntiny integrate_res = integrate_res + 2.d0 * & correction * ( funct_g ( ppar , iperp , om , nn , mode ) / ( ppar - denomR - ii * denomI )) enddo do ipar = 1 , ntiny - 1 ppar = real ( p_res ) + capDelta + correction * smdelta * ipar integrate_res = integrate_res + 2.d0 * 2.d0 * & correction * ( funct_g ( ppar , 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI )) integrate_res = integrate_res + 2.d0 * & correction * ( funct_g ( ppar , nperp - 1 , om , nn , mode ) / ( ppar - denomR - ii * denomI )) enddo endif integrate_res = 2.d0 * pi * integrate_res * smdelta * dpperp * 0.25d0 integrate_res = integrate_res + integrate_norm return end function integrate_res double complex function funct_g ( ppar_real , iperp , om , nn , mode ) !! This function returns the function g from Eq. (3.2) of the code paper. use alps_var , only : npar , pp , ms , qs , kpar , df0 , sproc implicit none double precision , intent ( in ) :: ppar_real !! Real part of the momentum at which g is evaluated. integer , intent ( in ) :: iperp !! Index of the perpendicular momentum. double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: mode !! Index of the entries in the T-tensor of Eq. (2.10). integer :: ipar !! Index of the parallel momentum. integer :: ipar_close !! Index of the parallel momentum closest to the resonance. double complex :: integrandplus !! Integrand function ahead of position. double complex :: integrandminus !! Integrand function behind of position. double complex :: integrand !! Integrand function at position. double precision :: dppar !! Inifinitesimal step in parallel momentum. dppar = abs ( pp ( sproc , 2 , 2 , 2 ) - pp ( sproc , 2 , 1 , 2 )) ipar_close = 0 ! determine the closest ipar (on the left) to this p_res_real: do ipar = 1 , npar - 1 if ( abs ( pp ( sproc , iperp , ipar , 2 ) - ppar_real ) . LE . ( 0.5d0 * dppar )) then ipar_close = ipar endif enddo if ( ipar_close . GE .( npar - 1 )) ipar_close = npar - 2 if ( ipar_close . LE . 1 ) ipar_close = 2 ! calculate the function on the grid (left and right of ppar_real): integrandplus =- qs ( sproc ) * & ( om * df0 ( sproc , iperp , ipar_close + 1 , 1 ) + ( kpar / ( ms ( sproc )) ) * & ( pp ( sproc , iperp , ipar_close + 1 , 1 ) * df0 ( sproc , iperp , ipar_close + 1 , 2 ) - & pp ( sproc , iperp , ipar_close + 1 , 2 ) * df0 ( sproc , iperp , ipar_close + 1 , 1 ) ) ) * & int_T ( nn , iperp , ipar_close + 1 , mode ) / kpar integrand =- qs ( sproc ) * & ( om * df0 ( sproc , iperp , ipar_close , 1 ) + ( kpar / ( ms ( sproc )) ) * & ( pp ( sproc , iperp , ipar_close , 1 ) * df0 ( sproc , iperp , ipar_close , 2 ) - & pp ( sproc , iperp , ipar_close , 2 ) * df0 ( sproc , iperp , ipar_close , 1 ) ) ) * & int_T ( nn , iperp , ipar_close , mode ) / kpar integrandminus =- qs ( sproc ) * & ( om * df0 ( sproc , iperp , ipar_close - 1 , 1 ) + ( kpar / ( ms ( sproc )) ) * & ( pp ( sproc , iperp , ipar_close - 1 , 1 ) * df0 ( sproc , iperp , ipar_close - 1 , 2 ) - & pp ( sproc , iperp , ipar_close - 1 , 2 ) * df0 ( sproc , iperp , ipar_close - 1 , 1 ) ) ) * & int_T ( nn , iperp , ipar_close - 1 , mode ) / kpar funct_g = integrand + & 0.5d0 * (( integrandplus - integrandminus ) / dppar ) * ( ppar_real - pp ( sproc , iperp , ipar_close , 2 )) return end function funct_g double complex function landau_integrate ( om , nn , mode ) !! This function evaluates the Landau contour according to Eqs. (3.8) and (3.9) of the code paper. use alps_var , only : nperp , pp , pi , ms , qs , kpar , sproc use alps_analyt , only : eval_fit implicit none double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: mode !! Index of the entries in the T-tensor of Eq. (2.10). double precision :: dpperp !! Inifinitesimal step in perpendicular momentum. double precision :: dppar !! Inifinitesimal step in parallel momentum. double precision :: h !! Infinitesimal step in perpendicular momentum. double complex :: ii !! Imaginary unit. double complex :: p_res !! Resonance momentum. double complex :: dfperp_C !! Derivative of f0 evaluated at resonance. double complex :: dfpar_C !! Derivative of f0 evaluated at resonance. double complex :: fpar_i !! value of distribution at (iperp,p_res+dppar) double complex :: fpar_f !! value of distribution at (iperp,p_res-dppar) double complex :: fperp_i !! value of distribution at (iperp+1,p_res) double complex :: fperp_f !! value of distribution at (iperp-1,p_res) integer :: iperp !! Index of perpendicular momentum. ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) landau_integrate = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) dpperp = pp ( sproc , 2 , 2 , 1 ) - pp ( sproc , 1 , 2 , 1 ) dppar = abs ( pp ( sproc , 2 , 2 , 2 ) - pp ( sproc , 2 , 1 , 2 )) ! Landau contour integral: ! At iperp=1, we are already missing the part from iperp=0, where we should actually start. Therefore, we use 4 instead of 2 in the trapezoid integration: do iperp = 1 , nperp - 1 !KGK: This line and the following seem to conflict... if (( iperp . EQ . 0 ). or .( iperp . EQ . ( nperp - 1 ))) then h = 0.5d0 else h = 1.d0 endif p_res = ( ms ( sproc ) * ( om ) - 1.d0 * nn * qs ( sproc )) / kpar fpar_i = eval_fit ( sproc , iperp , p_res + dppar ) fpar_f = eval_fit ( sproc , iperp , p_res - dppar ) fperp_i = eval_fit ( sproc , iperp + 1 , p_res ) fperp_f = eval_fit ( sproc , iperp - 1 , p_res ) if (( abs ( fpar_i ). eq . 0.d0 ). or .( abs ( fpar_f ). eq . 0.d0 )& . or .( abs ( fperp_i ). eq . 0.d0 ). or .( abs ( fpar_f ). eq . 0.d0 )) then landau_integrate = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) return endif ! Calculate the derivatives of f0 at the complex p_res: dfperp_C = ( fperp_i - fperp_f ) / ( 2.d0 * dpperp ) dfpar_C = ( fpar_i - fpar_f ) / ( 2.d0 * dppar ) landau_integrate = landau_integrate - h * int_T_res ( nn , iperp , p_res , mode ) * & ( qs ( sproc ) / abs ( kpar )) * ( ( pp ( sproc , iperp , 1 , 1 ) * dfpar_C - & p_res * dfperp_C ) * kpar / ( ms ( sproc )) + om * dfperp_C ) enddo iperp = 0 h = 0.5d0 p_res = ( ms ( sproc ) * ( om ) - 1.d0 * nn * qs ( sproc )) / kpar ! Calculate the derivatives of f0 at the complex p_res: dfperp_C = ( eval_fit ( sproc , iperp + 1 , p_res ) - eval_fit ( sproc , iperp , p_res )) / ( dpperp ) dfpar_C = ( eval_fit ( sproc , iperp , p_res + dppar ) - eval_fit ( sproc , iperp , p_res - dppar )) / ( 2.d0 * dppar ) landau_integrate = landau_integrate - h * int_T_res ( nn , iperp , p_res , mode ) * & ( qs ( sproc ) / abs ( kpar )) * ( ( pp ( sproc , iperp , 1 , 1 ) * dfpar_C - & p_res * dfperp_C ) * kpar / ( ms ( sproc )) + om * dfperp_C ) iperp = nperp h = 0.5d0 p_res = ( ms ( sproc ) * ( om ) - 1.d0 * nn * qs ( sproc )) / kpar ! Calculate the derivatives of f0 at the complex p_res: dfperp_C = ( eval_fit ( sproc , iperp , p_res ) - eval_fit ( sproc , iperp - 1 , p_res )) / ( dpperp ) dfpar_C = ( eval_fit ( sproc , iperp , p_res + dppar ) - eval_fit ( sproc , iperp , p_res - dppar )) / ( 2.d0 * dppar ) landau_integrate = landau_integrate - h * int_T_res ( nn , iperp , p_res , mode ) * & ( qs ( sproc ) / abs ( kpar )) * ( ( pp ( sproc , iperp , 1 , 1 ) * dfpar_C - & p_res * dfperp_C ) * kpar / ( ms ( sproc )) + om * dfperp_C ) landau_integrate = landau_integrate * ii * dpperp * pi * 2.d0 * pi ! write(*,*)p_res, nn, mode, landau_integrate return end function landau_integrate double complex function int_ee ( om ) !! This function returns the ee term in Eq. (2.9). use alps_var , only : qs , ms , nperp , npar , pp , pi , df0 , sproc implicit none double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer :: iperp !! Index to loop over perpendicular momentum. integer :: ipar !! Index to loop over parallel momentum. double precision :: dpperp !! Inifinitesimal step in perpendicular momentum. double precision :: dppar !! Inifinitesimal step in parallel momentum. int_ee = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) dpperp = pp ( sproc , 2 , 2 , 1 ) - pp ( sproc , 1 , 2 , 1 ) dppar = abs ( pp ( sproc , 2 , 2 , 2 ) - pp ( sproc , 2 , 1 , 2 )) ! At iperp=1, we are already missing the part from iperp=0, where we should actually start. Therefore, we use 4 instead of 2 in the trapezoid integration: int_ee = int_ee + & 2.d0 * pp ( sproc , 1 , 1 , 2 ) * & ( df0 ( sproc , 1 , 1 , 2 ) * pp ( sproc , 1 , 1 , 1 ) - & pp ( sproc , 1 , 1 , 1 ) * df0 ( sproc , 1 , 1 , 1 )) int_ee = int_ee + & 2.d0 * pp ( sproc , 1 , npar - 1 , 2 ) * & ( df0 ( sproc , 1 , npar - 1 , 2 ) * pp ( sproc , 1 , npar - 1 , 1 ) - & pp ( sproc , 1 , npar - 1 , 2 ) * df0 ( sproc , 1 , npar - 1 , 1 )) int_ee = int_ee + & pp ( sproc , nperp - 1 , 1 , 2 ) * & ( df0 ( sproc , nperp - 1 , 1 , 2 ) * pp ( sproc , nperp - 1 , 1 , 1 ) - & pp ( sproc , nperp - 1 , 1 , 2 ) * df0 ( sproc , nperp - 1 , 1 , 1 )) int_ee = int_ee + & pp ( sproc , nperp - 1 , npar - 1 , 2 ) * & ( df0 ( sproc , nperp - 1 , npar - 1 , 2 ) * pp ( sproc , nperp - 1 , npar - 1 , 1 ) - & pp ( sproc , nperp - 1 , npar - 1 , 2 ) * df0 ( sproc , nperp - 1 , npar - 1 , 1 )) do iperp = 2 , nperp - 2 do ipar = 2 , npar - 2 int_ee = int_ee + & 4.d0 * (& pp ( sproc , iperp , ipar , 2 ) * & ( df0 ( sproc , iperp , ipar , 2 ) * pp ( sproc , iperp , ipar , 1 ) - & pp ( sproc , iperp , ipar , 2 ) * df0 ( sproc , iperp , ipar , 1 )) ) enddo enddo do ipar = 2 , npar - 2 ! At iperp=1, we are already missing the part from iperp=0, where we should actually start. Therefore, we use 4 instead of 2 in the trapezoid integration: int_ee = int_ee + & 2.d0 * 2.d0 * (& pp ( sproc , 1 , ipar , 2 ) * & ( df0 ( sproc , 1 , ipar , 2 ) * pp ( sproc , 1 , ipar , 1 ) - & pp ( sproc , 1 , ipar , 2 ) * df0 ( sproc , 1 , ipar , 1 )) ) int_ee = int_ee + & 2.d0 * (& pp ( sproc , nperp - 1 , ipar , 2 ) * & ( df0 ( sproc , nperp - 1 , ipar , 2 ) * pp ( sproc , nperp - 1 , ipar , 1 ) - & pp ( sproc , nperp - 1 , ipar , 2 ) * df0 ( sproc , nperp - 1 , ipar , 1 )) ) enddo do iperp = 2 , nperp - 2 int_ee = int_ee + & 2.d0 * (& pp ( sproc , iperp , 1 , 2 ) * & ( df0 ( sproc , iperp , 1 , 2 ) * pp ( sproc , iperp , 1 , 1 ) - & pp ( sproc , iperp , 1 , 2 ) * df0 ( sproc , iperp , 1 , 1 )) ) int_ee = int_ee + & 2.d0 * (& pp ( sproc , iperp , npar - 1 , 2 ) * & ( df0 ( sproc , iperp , npar - 1 , 2 ) * pp ( sproc , iperp , npar - 1 , 1 ) - & pp ( sproc , iperp , npar - 1 , 2 ) * df0 ( sproc , iperp , npar - 1 , 1 ))) enddo int_ee = int_ee * 2.d0 * pi * qs ( sproc ) / ms ( sproc ) int_ee = int_ee * dpperp * dppar * 0.25d0 return end function int_ee double complex function resU ( om , nn , iperp , ipar ) !! This function evaluates the term proportional to U in Eq. (2.9) of the code paper. use ALPS_var , only : pp , kpar , ms , qs , df0 , vA , sproc , relativistic implicit none double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: iperp !! Index to loop over perpendicular momentum. integer , intent ( in ) :: ipar !! Index to loop over parallel momentum. double precision :: gamma !! Lorentz factor \\Gamma. gamma = 1.d0 ! standard for non-relativistic calculation ! For relativistic calculation: if ( relativistic ( sproc )) gamma = sqrt (( pp ( sproc , iperp , ipar , 1 ) ** 2 + & pp ( sproc , iperp , ipar , 2 ) ** 2 ) * vA ** 2 / ms ( sproc ) ** 2 + 1.d0 ) resU = qs ( sproc ) * & ( om * df0 ( sproc , iperp , ipar , 1 ) + ( kpar / ( gamma * ms ( sproc )) ) * & ( pp ( sproc , iperp , ipar , 1 ) * df0 ( sproc , iperp , ipar , 2 ) - & pp ( sproc , iperp , ipar , 2 ) * df0 ( sproc , iperp , ipar , 1 ) ) ) / & ( gamma * ms ( sproc ) * om - kpar * pp ( sproc , iperp , ipar , 2 ) - & ( 1.d0 * nn ) * qs ( sproc ) ) return end function resU double complex function int_T ( nn , iperp , ipar , mode ) !! This function returns the T-tensor according to Eq. (2.10) of the code paper. use ALPS_var , only : pp , kperp , qs , bessel_array , sproc use ALPS_var , only : kperp_norm implicit none integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: iperp !! Index to loop over perpendicular momentum. integer , intent ( in ) :: ipar !! Index to loop over parallel momentum. integer , intent ( in ) :: mode !! Index of the entries in the T-tensor of Eq. (2.10). double precision :: z !!  Argument of the Bessel functions, !!  multiplying with 1./(pperp*kperp) if kperp_norm=.false. double precision :: bessel !! Bessel function. double precision :: besselP !! First derivative of the Bessel function. double complex :: ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) !! Imaginary unit. !Bessel function argument: if ( kperp_norm ) then z = kperp / qs ( sproc ) else z = 1.d0 / qs ( sproc ) endif ! Look up array of Bessel functions: if ( nn . LT . 0 ) then bessel = (( - 1.d0 ) ** nn ) * bessel_array ( - nn , iperp ) else bessel = bessel_array ( nn , iperp ) endif ! Determine derivative of Bessel function: if ( nn . GE . 1 ) then besselP = 0.5d0 * ( bessel_array ( nn - 1 , iperp ) - bessel_array ( nn + 1 , iperp )) else if ( nn . LT . - 1 ) then besselP = 0.5d0 * (((( - 1.d0 ) ** ( nn - 1 )) * bessel_array ( - ( nn - 1 ), iperp ))& - ((( - 1.d0 ) ** ( nn + 1 )) * bessel_array ( - ( nn + 1 ), iperp ))) else if ( nn . EQ . 0 ) then besselP = - bessel_array ( 1 , iperp ) else if ( nn . EQ . - 1 ) then besselP = 0.5d0 * ( bessel_array ( 2 , iperp ) - bessel_array ( 0 , iperp )) endif select case ( mode ) ! evaluate the components of the T-tensor: case ( 1 ) !T xx if ( kperp_norm ) then int_T = 1.d0 * ( nn * nn ) * bessel * bessel / ( z * z ) else int_T = 1.d0 * ( nn * nn ) * bessel * bessel / ( z * z ) endif case ( 2 ) !T yy if ( kperp_norm ) then int_T = ( pp ( sproc , iperp , ipar , 1 ) ** 2 ) * besselP * besselP else int_T = kperp * kperp * ( pp ( sproc , iperp , ipar , 1 ) ** 2 ) * besselP * besselP endif case ( 3 ) !T zz if ( kperp_norm ) then int_T = bessel * bessel * pp ( sproc , iperp , ipar , 2 ) ** 2 else int_T = kperp * kperp * bessel * bessel * pp ( sproc , iperp , ipar , 2 ) ** 2 endif case ( 4 ) !T xy if ( kperp_norm ) then int_T = ( pp ( sproc , iperp , ipar , 1 )) * ii * ( 1.d0 * ( nn )) * bessel * besselP / z else int_T = kperp * ( pp ( sproc , iperp , ipar , 1 )) * ii * ( 1.d0 * ( nn )) * bessel * besselP / z endif case ( 5 ) !T xz if ( kperp_norm ) then int_T = ( 1.d0 * nn ) * bessel * bessel * pp ( sproc , iperp , ipar , 2 ) / z else int_T = ( 1.d0 * nn ) * kperp * bessel * bessel * pp ( sproc , iperp , ipar , 2 ) / z endif case ( 6 ) !T yz if ( kperp_norm ) then int_T = ( - 1.d0 * ii ) * bessel * besselP * pp ( sproc , iperp , ipar , 2 ) * pp ( sproc , iperp , ipar , 1 ) else int_T = ( - 1.d0 * ii ) * kperp * kperp * bessel * besselP * pp ( sproc , iperp , ipar , 2 ) * pp ( sproc , iperp , ipar , 1 ) endif end select return end function int_T double complex function int_T_res ( nn , iperp , p_res , mode ) !! This function returns the T-tensor according to Eq. (2.10) of the code paper for the case in which it is evaluated at the complex resonance momentum. use ALPS_var , only : pp , kperp , qs , bessel_array , sproc use ALPS_var , only : kperp_norm implicit none integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: iperp !! Index to loop over perpendicular momentum. double complex , intent ( in ) :: p_res !! Complex resonance momentum. integer , intent ( in ) :: mode !! Index of the entries in the T-tensor of Eq. (2.10). double precision :: z !!  Argument of the Bessel functions, !!  multiplying with 1./(pperp*kperp) if kperp_norm=.false. double precision :: bessel !! Bessel function. double precision :: besselP !! First derivative of the Bessel function. double complex :: ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) !! Imaginary unit. !Bessel function argument: if ( kperp_norm ) then z = kperp / qs ( sproc ) else z = 1.d0 / qs ( sproc ) endif ! Look up array of Bessel functions: if ( nn . LT . 0 ) then bessel = (( - 1.d0 ) ** ( nn )) * bessel_array ( - nn , iperp ) else bessel = bessel_array ( nn , iperp ) endif ! Determine derivative of Bessel function: if ( nn . GE . 1 ) then besselP = 0.5d0 * ( bessel_array ( nn - 1 , iperp ) - bessel_array ( nn + 1 , iperp )) else if ( nn . LT . - 1 ) then besselP = 0.5d0 * (((( - 1.d0 ) ** ( nn - 1 )) * bessel_array ( - ( nn - 1 ), iperp ))& - ((( - 1.d0 ) ** ( nn + 1 )) * bessel_array ( - ( nn + 1 ), iperp ))) else if ( nn . EQ . 0 ) then besselP = - bessel_array ( 1 , iperp ) else if ( nn . EQ . - 1 ) then besselP = 0.5d0 * ( bessel_array ( 2 , iperp ) - bessel_array ( 0 , iperp )) endif select case ( mode ) ! evaluate the components of the T-tensor: case ( 1 ) !T xx int_T_res = 1.d0 * ( nn * nn ) * bessel * bessel / ( z * z ) case ( 2 ) !T yy if ( kperp_norm ) then int_T_res = ( pp ( sproc , iperp , 1 , 1 ) ** 2 ) * besselP * besselP else int_T_res = kperp * kperp * ( pp ( sproc , iperp , 1 , 1 ) ** 2 ) * besselP * besselP endif case ( 3 ) !T zz if ( kperp_norm ) then int_T_res = bessel * bessel * p_res ** 2 else int_T_res = kperp * kperp * bessel * bessel * p_res ** 2 endif case ( 4 ) !T xy if ( kperp_norm ) then int_T_res = ( pp ( sproc , iperp , 1 , 1 )) * ii * ( 1.d0 * ( nn )) * bessel * besselP / z else int_T_res = kperp * ( pp ( sproc , iperp , 1 , 1 )) * ii * ( 1.d0 * ( nn )) * bessel * besselP / z endif case ( 5 ) !T xz if ( kperp_norm ) then int_T_res = ( 1.d0 * nn ) * bessel * bessel * p_res / z else int_T_res = ( 1.d0 * nn ) * kperp * bessel * bessel * p_res / z endif case ( 6 ) !T yz if ( kperp_norm ) then int_T_res = ( - 1.d0 * ii ) * bessel * besselP * p_res * pp ( sproc , iperp , 1 , 1 ) else int_T_res = ( - 1.d0 * ii ) * kperp * kperp * bessel * besselP * p_res * pp ( sproc , iperp , 1 , 1 ) endif end select return end function int_T_res subroutine secant ( om , in ) !! This subroutine applies the secant method to find the roots of the dispersion tensor. use ALPS_var , only : numiter , D_threshold , ierror , proc0 , writeOut , D_prec use mpi implicit none double complex , intent ( inout ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: in !! Root number double complex :: prevom !! Storage of previous entry of om. double complex :: ii !! Imaginary unit. double complex :: D !! Dispersion tensor. double complex :: Dprev !! Storage of previous entry of D. double complex :: jump !! Difference to be added to om. double complex :: minom !! Check variable for convergence. double complex :: minD !! Check variable for convergence. integer :: iter !! Index to loop over iterations. logical :: go_for_secant !! Check whether a secant-method step is required. ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) prevom = om * ( 1.d0 - D_prec ) Dprev = disp ( prevom ) minD = Dprev minom = prevom call mpi_barrier ( mpi_comm_world , ierror ) iter = 0 go_for_secant = . TRUE . do while (( iter . LE .( numiter - 1 )). AND .( go_for_secant )) iter = iter + 1 D = disp ( om ) if (( abs ( D - Dprev ). LT . 1.d-80 )) then prevom = prevom + 1.d-8 Dprev = disp ( prevom ) endif if (( abs ( D ). LT . D_threshold )) then jump = 0.d0 go_for_secant = . FALSE . if ( proc0 . AND . writeOut ) then write ( * , '(a,i2,a,i4)' ) ' Root ' , in , ' converged after iteration ' , iter write ( * , '(a,2es14.4e3,a,2es14.4e3)' ) ' D(' , real ( om ), aimag ( om ), ')= ' , D endif else jump = D * ( om - prevom ) / ( D - Dprev ) endif !if (proc0 .AND. writeOut) then !   write(*,'(i3,12es14.4)') iter, om, prevom, D, abs(D), Dprev, abs(Dprev), jump !endif prevom = om om = om - jump Dprev = D if ( abs ( D ). LT . abs ( minD )) then minom = om minD = D endif enddo if ( proc0 . AND . writeOut . AND .( iter . GE . numiter )) then write ( * , '(a,i4,a)' ) ' Maximum iteration ' , iter , ' reached.' om = minom write ( * , '(a,2es14.4e3,a,2es14.4e3)' ) ' D(' , real ( om ), aimag ( om ), ')= ' , D endif end subroutine secant subroutine secant_osc ( om , in ) !! Secant method with adaptive damping and Newton search fallback. use ALPS_var , only : numiter , D_threshold , ierror , proc0 , writeOut , D_prec use mpi implicit none double complex , intent ( inout ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: in !! Root number double complex :: D !! Dispersion Tensor. double complex :: Dprime !! Dispersion Tensor if we have to revert to the Newton Search fall back double complex :: prevom , prev2om , prev3om , prev4om !! Storage of previous four complex frequnecy values double complex :: prevD , prev2D , prev3D , prev4D !! Storage of previous entries of D double complex :: jump !! Difference to be added to om. double complex :: delta !!Step size for Newton Search double complex :: minom !! Check variable for convergence. double complex :: minD !! Check variable for convergence. integer :: iter !! Index to loop over iterations. logical :: go_for_secant !! Check whether a secant-method step is required. integer :: oscillation_count !! Number of previous frequency values in the secant cycle match with the current frequency. double precision :: osc_threshold !! Threshold for determining is the current frequency matches a previous guess. double precision :: damping_factor !! Reduction of secant jump if inside oscillation around a solution double precision :: lambda !! Step size for Newton search backup. double complex :: ii !! Imaginary Unit ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) delta = cmplx ( 1.d-6 , 1.d-8 , kind ( 1.d0 )) lambda = 0.1 osc_threshold = 1.E-3 !On some coarse maps, the current location is the best minima minD = 1.E13 D = disp ( om ) if ( abs ( D ). LT . abs ( minD )) then minom = om minD = D endif prevom = om * ( 1.d0 - D_prec ) prev2om = om prev3om = om prev4om = om prevD = disp ( prevom ) prev2D = D prev3D = D prev4D = D if ( abs ( prevD ). LT . abs ( minD )) then minom = prevom minD = prevD endif call mpi_barrier ( mpi_comm_world , ierror ) iter = 0 go_for_secant = . TRUE . damping_factor = 1.d0 oscillation_count = 0 do while (( iter . LE . ( numiter - 1 )) . AND . go_for_secant ) iter = iter + 1 D = disp ( om ) !! Ensure we don’t divide by a tiny value if (( abs ( D - prevD ) . LT . 1.d-80 )) then prevom = prevom + 1.d-8 prevD = disp ( prevom ) endif !! Check convergence if (( abs ( D ) . LT . D_threshold )) then jump = 0.d0 go_for_secant = . FALSE . if ( proc0 . AND . writeOut ) then write ( * , '(a,i2,a,i4)' ) ' Root ' , in , ' converged after iteration ' , iter write ( * , '(a,2es14.4e3,a,2es14.4e3)' ) ' D(' , real ( om ), aimag ( om ), ')= ' , D endif else !! Detect oscillations over last four iterations if ( iter . gt . 4 ) then if ( ((( abs ( real ( om ) - real ( prevom ))) . LT . ( abs ( real ( om )) * osc_threshold )). and .& (( abs ( aimag ( om ) - aimag ( prevom ))) . LT . ( abs ( aimag ( om )) * osc_threshold ))) . OR . & ((( abs ( real ( om ) - real ( prev2om ))) . LT . ( abs ( real ( om )) * osc_threshold )). and .& (( abs ( aimag ( om ) - aimag ( prev2om ))) . LT . ( abs ( aimag ( om )) * osc_threshold ))) . OR . & ((( abs ( real ( om ) - real ( prev3om ))) . LT . ( abs ( real ( om )) * osc_threshold )). and .& (( abs ( aimag ( om ) - aimag ( prev3om ))) . LT . ( abs ( aimag ( om )) * osc_threshold ))) . OR . & ((( abs ( real ( om ) - real ( prev4om ))) . LT . ( abs ( real ( om )) * osc_threshold )). and .& (( abs ( aimag ( om ) - aimag ( prev4om ))) . LT . ( abs ( aimag ( om )) * osc_threshold ))) ) then oscillation_count = oscillation_count + 1 damping_factor = min ( 0.5d0 , damping_factor * 0.75d0 ) !! Reduce step endif endif !! If oscillation persists, use finite-difference Newton step if ( oscillation_count . gt . 1 ) then Dprime = ( disp ( om * ( 1 + delta )) - disp ( om * ( 1 - delta ))) / ( 2.d0 * om * delta ) jump = D / ( Dprime + lambda * D ) !! Regularized Newton step else jump = damping_factor * D * ( om - prevom ) / ( D - prevD ) endif !! Apply jump limits to prevent large jumps if ( abs ( jump ) > 0.1 * abs ( om )) then jump = ( 0.1 * abs ( om )) * ( jump / abs ( jump )) !! Cap jump at 10% of om endif !! If |D| increases, reduce jump if ( abs ( D ) > abs ( prevD )) then jump = 0.5 * jump endif !if (proc0 .AND. writeOut) then !   write(*,'(i3,12es14.4)') iter, om, prevom, D, abs(D), prevD, abs(prevD), jump !endif !! Update previous values prev4om = prev3om prev3om = prev2om prev2om = prevom prevom = om prev4D = prev3D prev3D = prev2D prev2D = prevD prevD = D if ( abs ( D ). LT . abs ( minD )) then minom = om minD = D endif !! Apply update om = om - jump endif enddo if ( proc0 . AND . writeOut . AND . ( iter . GE . numiter )) then write ( * , '(a,i4,a)' ) ' Maximum iteration ' , iter , ' reached.' om = minom write ( * , '(a,2es14.4e3,a,2es14.4e3)' ) ' D(' , real ( om ), aimag ( om ), ')= ' , minD endif end subroutine secant_osc double complex function rtsec ( func , xin , in , iflag ) !! An alternative implementation of the secant method, adapted from PLUME. use alps_var , only : proc0 , writeOut , numiter , D_prec , D_tol implicit none double complex :: xin !! Initial Guess for complex frequency. integer , intent ( in ) :: in !! Root number double complex :: func !! Function whose roots are to be identified. !! For ALPS, this is the dispersion relation. double complex :: x1 !! Lower bound complex frequency at which func is evaluated. double complex :: x2 !! Upper bound complex frequency at which func is evaluated. double complex :: xl !! Swapping complex frequency. double complex :: fl !! Dispersion evaluation at x1. double complex :: f !! Dispersion evaluation at x2. double complex :: swap !! Temporary variable for swapping function values. double complex :: dx !! Step Size. integer :: iflag !! Flag for number of steps taken. integer :: j !! Step index. x1 = xin * ( 1.d0 - D_prec ) x2 = xin * ( 1.d0 + D_prec ) fl = func ( x1 ) f = func ( x2 ) if ( abs ( fl ). lt . abs ( f )) then rtsec = x1 xl = x2 swap = fl fl = f f = swap else xl = x1 rtsec = x2 endif do j = 1 , numiter - 1 iflag = j if ( abs ( f - fl ) . GT . 1.d-40 ) then dx = ( xl - rtsec ) * f / ( f - fl ) else dx = ( x2 - x1 ) / 2 5.d0 end if xl = rtsec fl = f rtsec = rtsec + dx / 2.d0 f = func ( rtsec ) if (( abs ( dx ). LT . D_tol ). OR .( abs ( f ). EQ . 0.d0 )) then !if((abs(f).LT.D_threshold)) then if ( proc0 . AND . writeOut ) then write ( * , '(a,i2,a,i4)' ) ' Root ' , in , ' converged after iteration ' , j write ( * , '(a,2es14.4e3,a,2es14.4e3)' ) ' D(' , real ( xl ), aimag ( xl ), ')= ' , f endif return endif enddo if ( proc0 . AND . writeOut ) write ( * , '(a,i4,a)' ) 'Maximum iteration ' , j , ' reached.' return end function rtsec subroutine om_scan ( ik ) !! This subroutine scans solutions along a single prescribed path in wavevector space. use ALPS_var , only : proc0 , nroots , runname , ierror , wroots , scan , sproc use ALPS_var , only : kperp , kpar , kperp_last , kpar_last use ALPS_var , only : secant_method , D_gap use ALPS_var , only : nspec use ALPS_io , only : get_unused_unit , isnancheck , alps_error use mpi implicit none integer , intent ( in ) :: ik !! Index of scan number. integer :: it !! Index to loop over steps of scan. integer :: nt !! Number of scans. integer :: in !! Number of roots character ( 500 ), dimension (:), allocatable :: scanName !! Output file name for scan. character ( 500 ), dimension (:), allocatable :: heatName !! Output file name for heating-rate calculation. character ( 500 ), dimension (:), allocatable :: heatMechName !! Output file name for heating-mechanism rate calculation. character ( 500 ), dimension (:), allocatable :: eigenName !! Output file name for eigenfunction calculation. character ( 6 ) :: scan_ID !! ID tags for scan types. double precision :: theta_0 !! Wavevector angle of previous step. double precision :: theta_1 !! Wavevector angle. double precision :: k_0 !! Wavevector magnitude of previous step. double precision :: k_tmp !! Temporary value of Wavevector magnitude. double complex :: omega !! Complex wave frequency \\omega. integer , dimension (:), allocatable :: scan_unit !! File unit for scan output. (1:nroots) integer , dimension (:), allocatable :: heat_unit !! File unit for heating-rate output. (1:nroots) integer , dimension (:), allocatable :: heat_mech_unit !! File unit for heating-mechanism-rate output. (1:nroots) integer , dimension (:), allocatable :: eigen_unit !! File unit for eigenfunction output. (1:nroots) integer :: imm !! Index to check for root jumps. logical , dimension (:), allocatable :: jump !! Check whether a jump should be applied. (1:nroots) logical :: alljump !! Check whether any root has jumped. integer :: iflag !! Number of steps taken for root finding in rtsec. double complex :: tmp !! Storage variable for determinant of dispersion tensor. double complex , dimension ( 1 : 3 ) :: ef !! Relative electric field amplitude (eigenfunction). double complex , dimension ( 1 : 3 ) :: bf !! Relative magnetic field amplitude (eigenfunction). double complex , dimension ( 1 : nspec ) :: ds !! Relative density-fluctuation amplitude (eigenfunction). double complex , dimension ( 1 : 3 , 1 : nspec ) :: Us !! Relative velocity-fluctuation amplitude (eigenfunction). double precision , dimension ( 1 : nspec ) :: Ps !! Relative heating rate of a given species. double precision , dimension ( 1 : 4 , 1 : nspec ) :: Ps_split !! Relative heating rate of a given species by component character ( 50 ) :: fmt_eigen !! Format string for eigenfunction output. character ( 50 ) :: fmt_heat !! Format string for heating-rate output. character ( 50 ) :: fmt_heat_mech !! Format string for heating-rate output. double complex , dimension (:), allocatable :: domegadk !! Gradient of the frequency in k-space along the scan direction (1:nroots). double precision :: Deltakstep !! Step through k-space (can be kperp, kpar, theta, or k-magnitude). allocate ( jump ( 1 : nroots )); jump = . true . allocate ( domegadk ( 1 : nroots )); domegadk = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) if ( proc0 ) then allocate ( scan_unit ( nroots )) allocate ( scanName ( nroots )) select case ( scan ( ik )% type_s ) case ( 0 ) ! k_0 to k_1 write ( scan_ID , '(a)' ) 'k1_k2_' case ( 1 ) ! theta_0 to theta_1 write ( scan_ID , '(a)' ) 'theta_' case ( 2 ) ! |k_0| to |k_1| @ constant theta write ( scan_ID , '(a)' ) 'kcstq_' case ( 3 ) ! kperp scan write ( scan_ID , '(a)' ) 'kperp_' case ( 4 ) ! kpar scan write ( scan_ID , '(a)' ) 'kpara_' end select if ( scan ( ik )% eigen_s ) then write ( fmt_eigen , '(a,i0,a)' ) '(4es14.4e3,12es14.4e3,' , nspec * 8 , 'es14.4e3)' allocate ( eigen_unit ( nroots )) allocate ( eigenName ( nroots )) endif if ( scan ( ik )% heat_s ) then write ( fmt_heat , '(a,i0,a)' ) '(4es14.4e3,' , nspec , 'es14.4e3)' write ( fmt_heat_mech , '(a,i0,a)' ) '(4es14.4e3,' , 4 * nspec , 'es14.4e3)' allocate ( heat_unit ( nroots )) allocate ( heat_mech_unit ( nroots )) allocate ( heatName ( nroots )) allocate ( heatMechName ( nroots )) endif do in = 1 , nroots write ( scanName ( in ), '(4a,i0,a,i0)' )& 'solution/' , trim ( runname ), '.scan_' , scan_ID , ik , '.root_' , in write ( * , '(2a)' ) ' => ' , trim ( scanName ( in )) call get_unused_unit ( scan_unit ( in )) open ( unit = scan_unit ( in ), file = trim ( scanName ( in )), status = 'replace' ) write ( scan_unit ( in ), '(4es14.4e3)' ) & kperp , kpar , wroots ( in ) close ( scan_unit ( in )) enddo endif if (( scan ( ik )% eigen_s ). or .( scan ( ik )% heat_s )) then do in = 1 , nroots omega = wroots ( in ) tmp = disp ( omega ) call calc_eigen ( omega , ef , bf , Us , ds , Ps , Ps_split , scan ( ik )% eigen_s , scan ( ik )% heat_s ) !reassign omega: omega = wroots ( in ) call mpi_barrier ( mpi_comm_world , ierror ) if ( proc0 ) then if ( scan ( ik )% eigen_s ) then write ( eigenName ( in ), '(4a,i0,a,i0)' )& 'solution/' , trim ( runname ), '.eigen_' , scan_ID , ik , '.root_' , in write ( * , '(2a)' ) ' => ' , trim ( eigenName ( in )) call get_unused_unit ( eigen_unit ( in )) open ( unit = eigen_unit ( in ), file = trim ( eigenName ( in )), status = 'replace' ) write ( eigen_unit ( in ), trim ( fmt_eigen )) & kperp , kpar , wroots ( in ), ef , bf , Us , ds close ( eigen_unit ( in )) endif if ( scan ( ik )% heat_s ) then write ( heatName ( in ), '(4a,i0,a,i0)' )& 'solution/' , trim ( runname ), '.heat_' , scan_ID , ik , '.root_' , in write ( * , '(2a)' ) ' => ' , trim ( heatName ( in )) call get_unused_unit ( heat_unit ( in )) open ( unit = heat_unit ( in ), file = trim ( heatName ( in )), status = 'replace' ) write ( heat_unit ( in ), trim ( fmt_heat )) & kperp , kpar , wroots ( in ), Ps close ( heat_unit ( in )) write ( heatMechName ( in ), '(4a,i0,a,i0)' )& 'solution/' , trim ( runname ), '.heat_mech_' , scan_ID , ik , '.root_' , in write ( * , '(2a)' ) ' => ' , trim ( heatMechName ( in )) call get_unused_unit ( heat_mech_unit ( in )) open ( unit = heat_mech_unit ( in ), file = trim ( heatMechName ( in )), status = 'replace' ) write ( heat_mech_unit ( in ), trim ( fmt_heat_mech )) & kperp , kpar , wroots ( in ), Ps_split close ( heat_mech_unit ( in )) endif endif enddo endif nt = scan ( ik )% n_out * scan ( ik )% n_res kperp_last = kperp kpar_last = kpar theta_0 = atan ( kperp_last / kpar_last ) k_0 = sqrt ( kperp_last ** 2 + kpar_last ** 2 ) do it = 1 , nt !Scan through wavevector space: select case ( scan ( ik )% type_s ) case ( 0 ) ! k_0 to k_1 if ( scan ( ik )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperp_last ) + scan ( ik )% diff * it ) kpar = 1 0.d0 ** ( log10 ( kpar_last ) + scan ( ik )% diff2 * it ) else kperp = kperp_last + scan ( ik )% diff * it kpar = kpar_last + scan ( ik )% diff2 * it endif Deltakstep = 0.d0 ! to avoid having to calculate the gradients in 2 dimensions. case ( 1 ) ! theta_0 to theta_1 if ( scan ( ik )% log_scan ) then theta_1 = 1 0.d0 ** ( log10 ( theta_0 ) + scan ( ik )% diff * it ) else theta_1 = theta_0 + scan ( ik )% diff * it endif kperp = k_0 * sin ( theta_1 ) kpar = k_0 * cos ( theta_1 ) Deltakstep = theta_1 - theta_0 case ( 2 ) ! |k_0| to |k_1| @ constant theta if ( scan ( ik )% log_scan ) then k_tmp = 1 0.d0 ** ( log10 ( k_0 ) + scan ( ik )% diff * it ) kperp = k_tmp * sin ( theta_0 ) kpar = k_tmp * cos ( theta_0 ) else k_tmp = ( k_0 ) + scan ( ik )% diff * it kperp = k_tmp * sin ( theta_0 ) kpar = k_tmp * cos ( theta_0 ) endif Deltakstep = sqrt ( kperp ** 2 + kpar ** 2 ) - sqrt ( kperp_last ** 2 + kpar_last ** 2 ) case ( 3 ) ! kperp scan if ( scan ( ik )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperp_last ) + scan ( ik )% diff * it ) else kperp = kperp_last + scan ( ik )% diff * it endif Deltakstep = kperp - kperp_last case ( 4 ) ! kpar scan if ( scan ( ik )% log_scan ) then kpar = 1 0.d0 ** ( log10 ( kpar_last ) + scan ( ik )% diff * it ) else kpar = kpar_last + scan ( ik )% diff * it endif Deltakstep = kpar - kpar_last end select if ( scan ( ik )% type_s . ne . 4 ) then ! Scan types with varying kperp require a re-call of split_processes: call determine_nmax call split_processes if (. NOT .( sproc . EQ . 0 )) call determine_bessel_array endif call mpi_barrier ( mpi_comm_world , ierror ) ! Check if all jumps are set to .false.: alljump = . FALSE . do in = 1 , nroots alljump = alljump . OR . jump ( in ) enddo if ( alljump . EQV .. FALSE .) call alps_error ( 9 ) do in = 1 , nroots !Search for new roots if ( jump ( in )) then omega = wroots ( in ) ! Extrapolate the initial guess along the direction in k-scans: !!KGK: This line causes the solution to (occasionally) !!smoothly transition to unphysical values. !!Suppressing until we understand the error. !omega=omega+domegadk(in)*Deltakstep !call secant(omega,in) !domegadk(in)=omega-wroots(in) !wroots(in)=omega !KGK: Testing Alternative Root Finding Schemes select case ( secant_method ) case ( 0 ) call secant ( omega , in ) case ( 1 ) omega = rtsec ( disp , omega , in , iflag ) case ( 2 ) call secant_osc ( omega , in ) end select wroots ( in ) = omega call mpi_bcast ( wroots ( in ), 1 , & MPI_DOUBLE_COMPLEX , 0 , MPI_COMM_WORLD , ierror ) ! Run a final instance of disp: tmp = disp ( omega ) call mpi_barrier ( mpi_comm_world , ierror ) ! Eigenfunctions and heating rates: ! only call on wavevector steps that will be output: if ( mod ( it , scan ( ik )% n_res ) == 0 ) then if (( scan ( ik )% eigen_s ). or .(( scan ( ik )% heat_s ))) then call calc_eigen ( omega , ef , bf , Us , ds , Ps , Ps_split , scan ( ik )% eigen_s , scan ( ik )% heat_s ) !reassign omega: omega = wroots ( in ) endif endif call mpi_barrier ( mpi_comm_world , ierror ) !Output and check for root jumps and NaNs: if ( proc0 ) then if ( isnancheck ( real ( omega ))) then omega = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )); jump ( in ) = . false . endif ! do imm = 1 , in - 1 if ( abs ( wroots ( in ) - wroots ( imm )). lt . D_gap ) then write ( * , '(a,6es14.4e3)' ) 'Root too close!' ,& wroots ( in ), wroots ( imm ),& real ( wroots ( in )) - real ( wroots ( imm )), & aimag ( wroots ( in )) - aimag ( wroots ( imm )) wroots ( in ) = cmplx ( 0.d0 , 0.d0 ); jump ( in ) = . false . endif enddo if ( mod ( it , scan ( ik )% n_res ) == 0 ) then open ( unit = scan_unit ( in ), file = trim ( scanName ( in )), status = 'old' , position = 'append' ) write ( scan_unit ( in ), '(4es14.4e3)' ) & kperp , kpar , wroots ( in ) close ( scan_unit ( in )) if ( scan ( ik )% eigen_s ) then open ( unit = eigen_unit ( in ), file = trim ( eigenName ( in )), status = 'old' , position = 'append' ) write ( eigen_unit ( in ), trim ( fmt_eigen )) & kperp , kpar , wroots ( in ), ef , bf , Us , ds close ( eigen_unit ( in )) endif if ( scan ( ik )% heat_s ) then open ( unit = heat_unit ( in ), file = trim ( heatName ( in )), status = 'old' , position = 'append' ) write ( heat_unit ( in ), trim ( fmt_heat )) & kperp , kpar , wroots ( in ), Ps close ( heat_unit ( in )) open ( unit = heat_mech_unit ( in ), file = trim ( heatMechName ( in )), status = 'old' , position = 'append' ) write ( heat_mech_unit ( in ), trim ( fmt_heat_mech )) & kperp , kpar , wroots ( in ), Ps_split close ( heat_mech_unit ( in )) endif endif endif call mpi_bcast ( jump ( in ), 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) end if call mpi_barrier ( mpi_comm_world , ierror ) enddo enddo if ( proc0 ) then deallocate ( scan_unit ) deallocate ( scanName ) endif end subroutine om_scan subroutine calc_eigen ( omega , electric , magnetic , vmean , ds , Ps , Ps_split , eigen_L , heat_L ) !! This subroutine calculates the relative electric and magnetic field amplitudes, the relative fluctuations in the density and velocity of all species, and the heating rates of the given solution. !! It is based on the calc_eigen routine by Greg Howes and Kris Klein, found in PLUME. !! The splitting by mechanisms is described in Huang, Howes, and Brown, JPP 2024, !! but has been reformated to isolate TTD, LD, and the n=+1 and -1 CD terms separately. use ALPS_var , only : proc0 , nspec , ns , qs , wave , chi0 , chi0_low , kperp , kpar , vA , current_int implicit none double complex , intent ( in ) :: omega !! Complex wave frequency \\omega. double complex , dimension ( 1 : 3 ), intent ( out ) :: electric !! Relative electric field amplitude (eigenfunction). double complex , dimension ( 1 : 3 ) :: electric_xy !! Components of electric field: !! (Ex, Ey, 0) double complex , dimension ( 1 : 3 ), intent ( out ) :: magnetic !! Relative magnetic field amplitude (eigenfunction). double complex , dimension ( 1 : nspec ), intent ( out ) :: ds !! Relative density-fluctuation amplitude (eigenfunction). double complex , dimension ( 1 : 3 , 1 : nspec ), intent ( out ) :: vmean !! Relative velocity-fluctuation amplitude (eigenfunction). double precision , dimension ( 1 : nspec ), intent ( out ) :: Ps !! Relative heating rate of a given species. double precision , dimension ( 1 : 4 , 1 : nspec ) :: Ps_split !! Relative heating rate of a given species split by component logical , intent ( in ) :: eigen_L !! Check whether eigenfunction calculation is requested. logical , intent ( in ) :: heat_L !! Check whether eigenfunction calculation is requested. integer :: ii !! Index to loop over tensor elements. integer :: j !! Index to loop over tensor elements. integer :: jj !! Index to loop over species. double complex :: temp1 !! Storage variable for real part of frequency and evaluated dispersion tensor. double complex , dimension ( nspec , 3 , 3 ) :: chia !! Anti-Hermitian part of the dispersion tensor. double complex , dimension ( 3 , 3 ) :: chih !! Hermitian part of the dispersion tensor. double complex , dimension ( 3 , 3 ) :: chihold !! Storage variable for the Hermitian part of the dispersion tensor. double complex , dimension ( 3 , 3 ) :: dchih !! Derivative of the Hermitian part of the dispersion tensor. double complex , dimension ( nspec , 3 ) :: term !! Tensor product in heating-rate calculation. double complex , dimension ( 3 ) :: term1 !! Tensor product in heating-rate calculation. double precision :: ewave !! Normalised wave energy. double precision , dimension ( 1 : nspec ) :: parallel_flow !! U_s/v_A,ref = `current_int`/(n_s q_s) if ( proc0 ) then !The electric and magnetic fields are needed for the heating !rate calculation; thus, we always calculate them electric ( 1 ) = cmplx ( 1.d0 , 0.d0 , kind ( 1.d0 )) electric ( 3 ) =- electric ( 1 ) * ( wave ( 2 , 1 ) * wave ( 3 , 2 ) - wave ( 3 , 1 ) * wave ( 2 , 2 )) electric ( 3 ) = electric ( 3 ) / ( wave ( 2 , 3 ) * wave ( 3 , 2 ) - wave ( 3 , 3 ) * wave ( 2 , 2 )) ! The following captures a situation that can occur in fully cold plasmas without drifts: if ( abs ( wave ( 3 , 2 )). NE . 0.d0 ) then electric ( 2 ) = - electric ( 3 ) * wave ( 3 , 3 ) - electric ( 1 ) * wave ( 3 , 1 ) electric ( 2 ) = electric ( 2 ) / wave ( 3 , 2 ) else electric ( 2 ) = wave ( 2 , 1 ) * wave ( 1 , 3 ) - wave ( 1 , 1 ) * wave ( 2 , 3 ) electric ( 2 ) = electric ( 2 ) / ( wave ( 2 , 3 ) * wave ( 1 , 2 ) - wave ( 2 , 2 ) * wave ( 1 , 3 )) endif !Calculate Magnetic Fields, normalized to E_x: magnetic ( 1 ) = - 1.d0 * kpar * electric ( 2 ) / ( omega * vA ) magnetic ( 2 ) = - 1.d0 * ( kperp * electric ( 3 ) - kpar * electric ( 1 )) / ( omega * vA ) magnetic ( 3 ) = kperp * electric ( 2 ) / ( omega * vA ) if ( eigen_L ) then ! Calculate relative velocity fluctuations: vmean (:,:) = 0.d0 do jj = 1 , nspec !Species velocity fluctuations !Calculate parallel equilibrium flow. !current_int is defined as n_s q_s P_s/m_s !where P_s is the parallel drift momentum parallel_flow ( jj ) = current_int ( jj ) / ( ns ( jj ) * qs ( jj )) if ( parallel_flow ( jj ). eq . 0. ) then do j = 1 , 3 !x,y,z vmean ( j , jj ) = - ( vA ** 2. / ( qs ( jj ) * ns ( jj ))) * & cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) * & omega * sum ( electric (:) * chi0 ( jj , j ,:)) enddo else do j = 1 , 2 !x,y vmean ( j , jj ) = - ( vA ** 2. / ( qs ( jj ) * ns ( jj ))) * & cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) * & omega * sum ( electric (:) * chi0 ( jj , j ,:)) enddo j = 3 !z vmean ( j , jj ) = - ( vA ** 2. / ( qs ( jj ) * ns ( jj ))) * & cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) * & omega * sum ( electric (:) * chi0 ( jj , j ,:))& - parallel_flow ( jj ) * kperp * vmean ( 1 , jj ) / & ( omega - kpar * parallel_flow ( jj )) vmean ( j , jj ) = vmean ( j , jj ) / & ( 1 + ( kpar * parallel_flow ( jj )) / & ( omega - kpar * parallel_flow ( jj ))) endif enddo ! Calculate relative density fluctuations: Normalized to E_x/B_0 do jj = 1 , nspec ds ( jj ) = ( 1. / vA ) * ( vmean ( 1 , jj ) * kperp + vmean ( 3 , jj ) * kpar ) / & ( omega - kpar * parallel_flow ( jj )) enddo endif endif if ( heat_L ) then ! Calculate component heating-rate: temp1 = cmplx ( real ( omega ), 0.d0 , kind ( 1.d0 )) temp1 = disp ( temp1 ) !-=-=-=- if ( proc0 ) then do ii = 1 , 3 !tensor index do j = 1 , 3 !tensor index do jj = 1 , nspec !species index chia ( jj , ii , j ) = - 0.5d0 * cmplx ( 0.d0 , 1.d0 ) * & ( chi0 ( jj , ii , j ) - conjg ( chi0 ( jj , j , ii ))) enddo chihold ( ii , j ) = 0.5 * ( sum ( chi0 (:, ii , j )) + & sum ( conjg ( chi0 (:, j , ii )))) enddo enddo term (:,:) = 0.d0 term1 (:) = 0.d0 do ii = 1 , 3 do jj = 1 , nspec term ( jj , ii ) = sum ( conjg ( electric (:)) * chia ( jj ,:, ii )) enddo enddo Ps = 0.d0 do jj = 1 , nspec Ps ( jj ) = sum ( term ( jj ,:) * electric (:)) enddo endif !-=-=-=- temp1 = disp ( cmplx ( real ( omega * 1.000001d0 ), 0.d0 , kind ( 1.d0 ))) !-=-=-=- if ( proc0 ) then do ii = 1 , 3 do j = 1 , 3 chih ( ii , j ) = 0.5d0 * ( sum ( chi0 (:, ii , j )) + & sum ( conjg ( chi0 (:, j , ii )))) dchih ( ii , j ) = ( 1.000001d0 * chih ( ii , j ) - chihold ( ii , j )) / 0.000001d0 enddo enddo ewave = 0.d0 do ii = 1 , 3 term1 ( ii ) = sum ( conjg ( electric (:)) * dchih (:, ii )) enddo ewave = sum ( term1 (:) * electric (:)) + sum ( magnetic (:) * conjg ( magnetic (:))) Ps = Ps / ewave endif !-=-=-=- !LD, TTD, and CD calculation if ( proc0 ) then do ii = 1 , 3 !tensor index do j = 1 , 3 !tensor index do jj = 1 , nspec !species index chia ( jj , ii , j ) = - 0.5d0 * cmplx ( 0.d0 , 1.d0 ) * & ( chi0_low ( jj , ii , j , 0 ) - conjg ( chi0_low ( jj , j , ii , 0 ))) enddo enddo enddo !Initialize Ps_split Ps_split (:,:) = 0. !chi_yy  (TTD term 1) Ps_split ( 1 ,:) =- 0.5 * cmplx ( 0. , 1. ) * & conjg ( electric ( 2 )) * electric ( 2 ) * & ( chi0_low (:, 2 , 2 , 0 ) - conjg ( chi0_low (:, 2 , 2 , 0 ))) !chi_yz  (TTD term 2) Ps_split ( 1 ,:) = Ps_split ( 1 ,:) - 0.5 * cmplx ( 0. , 1. ) * & ( electric ( 3 ) * conjg ( electric ( 2 )) * chi0_low (:, 2 , 3 , 0 ) - & conjg ( electric ( 3 )) * electric ( 2 ) * conjg ( chi0_low (:, 2 , 3 , 0 ))) !chi_zy  (LD term 1) Ps_split ( 2 ,:) =- 0.5 * cmplx ( 0. , 1. ) * & ( electric ( 2 ) * conjg ( electric ( 3 )) * chi0_low (:, 3 , 2 , 0 ) - & conjg ( electric ( 2 )) * electric ( 3 ) * conjg ( chi0_low (:, 3 , 2 , 0 ))) !chi_zz  (LD term 2) Ps_split ( 2 ,:) = Ps_split ( 2 ,:) - 0.5 * cmplx ( 0. , 1. ) * & conjg ( electric ( 3 )) * electric ( 3 ) * & ( chi0_low (:, 3 , 3 , 0 ) - conjg ( chi0_low (:, 3 , 3 , 0 ))) endif if ( proc0 ) then electric_xy = electric ; electric_xy ( 3 ) = cmplx ( 0. , 0. ) !N=1 do ii = 1 , 3 !tensor index do j = 1 , 3 !tensor index do jj = 1 , nspec !species index chia ( jj , ii , j ) = - 0.5 * cmplx ( 0. , 1. ) * & ( chi0_low ( jj , ii , j , 1 ) - conjg ( chi0_low ( jj , j , ii , 1 ))) enddo enddo enddo !Total n=1 terms, Eperp term (:,:) = 0. term1 (:) = 0. do ii = 1 , 3 do jj = 1 , nspec term ( jj , ii ) = sum ( conjg ( electric_xy (:)) * chia ( jj ,:, ii )) enddo enddo Ps_split ( 3 ,:) = 0. do jj = 1 , nspec Ps_split ( 3 , jj ) = sum ( term ( jj ,:) * electric_xy (:)) enddo !N=-1 do ii = 1 , 3 !tensor index do j = 1 , 3 !tensor index do jj = 1 , nspec !species index chia ( jj , ii , j ) = - 0.5 * cmplx ( 0. , 1. ) * & ( chi0_low ( jj , ii , j , - 1 ) - conjg ( chi0_low ( jj , j , ii , - 1 ))) enddo enddo enddo !Total n=-1 terms, Eperp term (:,:) = 0. term1 (:) = 0. do ii = 1 , 3 do jj = 1 , nspec term ( jj , ii ) = sum ( conjg ( electric_xy (:)) * chia ( jj ,:, ii )) enddo enddo Ps_split ( 4 ,:) = 0. do jj = 1 , nspec Ps_split ( 4 , jj ) = sum ( term ( jj ,:) * electric_xy (:)) enddo !Normalization Ps_split = Ps_split / ewave endif endif end subroutine calc_eigen subroutine om_double_scan !! This subroutine scans along a prescribed plane in wavevector space !! to map out \\omega in this space. !! It is required that n_scan=2, and is invoked with option =2 use ALPS_var , only : proc0 , nroots , runname , ierror , wroots , scan , sproc use ALPS_var , only : kperp , kpar , kperp_last , kpar_last use ALPS_var , only : secant_method , D_gap use ALPS_var , only : ierror , nspec use ALPS_io , only : get_unused_unit , alps_error , isnancheck use mpi implicit none integer :: it !! Index to loop over steps of first scan. integer :: nt !! Number of scans for first scan. integer :: itt !! Index for resetting wavevector scan. integer :: it2 !! Index to loop over steps of second scan. integer :: nt2 !! Number of scans for second scan. integer :: in !! Number of roots. character ( 500 ), dimension (:), allocatable :: scanName !! Output file name for scan. character ( 500 ), dimension (:), allocatable :: heatName !! Output file name for heating-rate calculation. character ( 500 ), dimension (:), allocatable :: heatMechName !! Output file name for heating-rate mechanism calculation. character ( 500 ), dimension (:), allocatable :: eigenName !! Output file name for eigenfunction calculation. character ( 6 ) :: scan_ID !! ID tags for scan types for first scan. character ( 5 ) :: scan_ID2 !! ID tags for scan types for second scan. double precision :: theta_0 !! Wavevector angle of previous step double precision :: theta_1 !! Wavevector angle. double precision :: k_0 !! Wavevector magnitude of previous step. double precision :: k_tmp !! Temporary value of Wavevector magnitude. double precision :: theta_i !! Wavevector angle of step i. double precision :: k_i !! Wavevector magnitude of step i. double precision :: kperpi !! Perpendicular wavenumber of step i. double precision :: kpari !! Parallel wavenumber of step i. double complex , dimension (:), allocatable :: om_tmp !! Storage variable for frequency omega. (1:nroots) complex , dimension (:), allocatable :: omlast !!Arrays with complex frequency for each solution. double complex :: omega !! Complex wave frequency \\omega. integer , dimension (:), allocatable :: scan_unit !! File unit for scan output. (1:nroots) integer , dimension (:), allocatable :: heat_unit !! File unit for heating-rate output. (1:nroots) integer , dimension (:), allocatable :: heat_mech_unit !! File unit for heating-rate output. (1:nroots) integer , dimension (:), allocatable :: eigen_unit !! File unit for eigenfunction output. (1:nroots) integer :: imm !! Index to check for root jumps. logical , dimension (:), allocatable :: jump !! Check whether a jump should be applied. (1:nroots) logical :: alljump !! Check whether any root has jumped. double complex :: tmp !! Storage variable for determinant of dispersion tensor. double complex , dimension ( 1 : 3 ) :: ef !! Relative electric field amplitude (eigenfunction). double complex , dimension ( 1 : 3 ) :: bf !! Relative magnetic field amplitude (eigenfunction). double complex , dimension ( 1 : nspec ) :: ds !! Relative density-fluctuation amplitude (eigenfunction). double complex , dimension ( 1 : 3 , 1 : nspec ) :: Us !! Relative velocity-fluctuation amplitude (eigenfunction). double precision , dimension ( 1 : nspec ) :: Ps !! Relative heating rate of a given species. double precision , dimension ( 1 : 4 , 1 : nspec ) :: Ps_split !! Relative heating rate of a given species, split by component. character ( 50 ) :: fmt_eigen !! Format string for eigenfunction output. character ( 50 ) :: fmt_heat !! Format string for heating-rate output. character ( 50 ) :: fmt_heat_mech !! Format string for heating-rate output. double complex , dimension (:), allocatable :: domegadk !! Gradient of the frequency in k-space along the scan direction (1:nroots). double precision :: Deltakstep !! Step through k-space (can be kperp, kpar, theta, or k-magnitude). integer :: iflag !! Number of steps taken for root finding in rtsec. allocate ( jump ( 1 : nroots )); jump = . true . allocate ( domegadk ( 1 : nroots )); domegadk = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) if ( scan ( 1 )% type_s == scan ( 2 )% type_s ) then call alps_error ( 5 ) endif if (( scan ( 1 )% type_s == 0 ). or .( scan ( 2 )% type_s == 0 )) then call alps_error ( 6 ) endif allocate ( om_tmp ( nroots )) if ( proc0 ) then allocate ( scan_unit ( nroots )) allocate ( scanName ( nroots )) !Name of first scan: select case ( scan ( 1 )% type_s ) case ( 0 ) ! k_0 to k_1 write ( scan_ID , '(a)' ) 'k1_k2_' case ( 1 ) ! theta_0 to theta_1 write ( scan_ID , '(a)' ) 'theta_' case ( 2 ) ! |k_0| to |k_1| @ constant theta write ( scan_ID , '(a)' ) 'kcstq_' case ( 3 ) ! kperp scan write ( scan_ID , '(a)' ) 'kperp_' case ( 4 ) ! kpar scan write ( scan_ID , '(a)' ) 'kpara_' end select !Name of second scan: select case ( scan ( 2 )% type_s ) case ( 0 ) !k_0 to k_1 write ( scan_ID2 , '(a)' ) 'k1_k2' case ( 1 ) !theta_0 to theta_1 write ( scan_ID2 , '(a)' ) 'theta' case ( 2 ) ! |k_0| to |k_1| @ constant theta write ( scan_ID2 , '(a)' ) 'kcstq' case ( 3 ) !kperp scan write ( scan_ID2 , '(a)' ) 'kperp' case ( 4 ) !kpar scan write ( scan_ID2 , '(a)' ) 'kpara' end select if ( scan ( 1 )% eigen_s ) then !Eigenfunction output. write ( fmt_eigen , '(a,i0,a)' ) '(4es14.4e3,12es14.4e3,' , nspec * 8 , 'es14.4e3)' allocate ( eigen_unit ( nroots )) allocate ( eigenName ( nroots )) endif if ( scan ( 1 )% heat_s ) then !Heating output. write ( fmt_heat , '(a,i0,a)' ) '(4es14.4e3,' , nspec , 'es14.4e3)' allocate ( heat_unit ( nroots )) allocate ( heatName ( nroots )) !Heating mechanism output. write ( fmt_heat_mech , '(a,i0,a)' ) '(4es14.4e3,' , 4 * nspec , 'es14.4e3)' allocate ( heat_mech_unit ( nroots )) allocate ( heatMechName ( nroots )) endif do in = 1 , nroots write ( scanName ( in ), '(6a,i0)' )& 'solution/' , trim ( runname ), '.scan_' , scan_ID , scan_ID2 , '.root_' , in write ( * , '(2a)' ) ' => ' , trim ( scanName ( in )) call get_unused_unit ( scan_unit ( in )) open ( unit = scan_unit ( in ), file = trim ( scanName ( in )), status = 'replace' ) close ( scan_unit ( in )) enddo endif if (( scan ( 1 )% eigen_s ). or .( scan ( 1 )% heat_s )) then do in = 1 , nroots omega = wroots ( in ) tmp = disp ( omega ) call calc_eigen ( omega , ef , bf , Us , ds , Ps , Ps_split , scan ( 1 )% eigen_s , scan ( 1 )% heat_s ) !reassign omega: omega = wroots ( in ) call mpi_barrier ( mpi_comm_world , ierror ) if ( proc0 ) then if ( scan ( 1 )% eigen_s ) then write ( eigenName ( in ), '(6a,i0)' )& 'solution/' , trim ( runname ), '.eigen_' , scan_ID , scan_ID2 , '.root_' , in write ( * , '(2a)' ) ' => ' , trim ( eigenName ( in )) call get_unused_unit ( eigen_unit ( in )) open ( unit = eigen_unit ( in ), file = trim ( eigenName ( in )), status = 'replace' ) close ( eigen_unit ( in )) endif if ( scan ( 1 )% heat_s ) then write ( heatName ( in ), '(6a,i0)' )& 'solution/' , trim ( runname ), '.heat_' , scan_ID , scan_ID2 , '.root_' , in write ( * , '(2a)' ) ' => ' , trim ( heatName ( in )) call get_unused_unit ( heat_unit ( in )) open ( unit = heat_unit ( in ), file = trim ( heatName ( in )), status = 'replace' ) close ( heat_unit ( in )) write ( heatMechName ( in ), '(6a,i0)' )& 'solution/' , trim ( runname ), '.heat_mech_' , scan_ID , scan_ID2 , '.root_' , in write ( * , '(2a)' ) ' => ' , trim ( heatMechName ( in )) call get_unused_unit ( heat_mech_unit ( in )) open ( unit = heat_mech_unit ( in ), file = trim ( heatMechName ( in )), status = 'replace' ) close ( heat_mech_unit ( in )) endif endif enddo endif !Set number of steps for both scans. nt = scan ( 1 )% n_out * scan ( 1 )% n_res nt2 = scan ( 2 )% n_out * scan ( 2 )% n_res kperp_last = kperp ; kpar_last = kpar theta_0 = atan ( kperp_last / kpar_last ) k_0 = sqrt ( kperp_last ** 2 + kpar_last ** 2 ) allocate ( omlast ( nroots )) do in = 1 , nroots omlast ( in ) = wroots ( in ) enddo do it = 0 , nt ! Scan through wavevector space: select case ( scan ( 1 )% type_s ) case ( 0 ) ! k_0 to k_1 if ( scan ( 1 )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperp_last ) + scan ( 1 )% diff * it ) kpar = 1 0.d0 ** ( log10 ( kpar_last ) + scan ( 1 )% diff2 * it ) else kperp = kperp_last + scan ( 1 )% diff * it kpar = kpar_last + scan ( 1 )% diff2 * it endif case ( 1 ) ! theta_0 to theta_1 if ( scan ( 1 )% log_scan ) then theta_1 = 1 0.d0 ** ( log10 ( theta_0 ) + scan ( 1 )% diff * it ) else theta_1 = theta_0 + scan ( 1 )% diff * it endif kperp = k_0 * sin ( theta_1 ) kpar = k_0 * cos ( theta_1 ) case ( 2 ) ! |k_0| to |k_1| @ constant theta if ( scan ( 1 )% log_scan ) then k_tmp = 1 0.d0 ** ( log10 ( k_0 ) + scan ( 1 )% diff * it ) kperp = k_tmp * sin ( theta_0 ) kpar = k_tmp * cos ( theta_0 ) else k_tmp = ( k_0 ) + scan ( 1 )% diff * it kperp = k_tmp * sin ( theta_0 ) kpar = k_tmp * cos ( theta_0 ) endif case ( 3 ) ! kperp scan if ( scan ( 1 )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperp_last ) + scan ( 1 )% diff * it ) else kperp = kperp_last + scan ( 1 )% diff * it endif case ( 4 ) ! kpar scan if ( scan ( 1 )% log_scan ) then kpar = 1 0.d0 ** ( log10 ( kpar_last ) + scan ( 1 )% diff * it ) else kpar = kpar_last + scan ( 1 )% diff * it endif end select if ( scan ( 1 )% type_s . ne . 4 ) then ! Scan types with varying kperp require a re-call of split_processes: call determine_nmax call split_processes if (. NOT .( sproc . EQ . 0 )) call determine_bessel_array endif call mpi_barrier ( mpi_comm_world , ierror ) if ( proc0 ) write ( * , '(a,es14.4e3,a,es14.4e3)' ) 'kperp: ' , kperp , ' kpar: ' , kpar ! Check if all jumps are set to .false.: alljump = . FALSE . do in = 1 , nroots alljump = alljump . OR . jump ( in ) enddo if ( alljump . EQV .. FALSE .) call alps_error ( 9 ) do in = 1 , nroots !Search for new roots if ( jump ( in )) then omega = omlast ( in ) wroots ( in ) = omlast ( in ) ! Extrapolate the initial guess along the direction in k-scans: !!KGK: This line causes the solution to (occasionally) !!smoothly transition to unphysical values. !!Suppressing until we understand the error. !omega=omega+domegadk(in)*Deltakstep !call secant(omega,in) !domegadk(in)=omega-wroots(in) !wroots(in)=omega !KGK: Alternative Root Finding Schemes select case ( secant_method ) case ( 0 ) call secant ( omega , in ) case ( 1 ) omega = rtsec ( disp , omega , in , iflag ) case ( 2 ) call secant_osc ( omega , in ) end select wroots ( in ) = omega omlast ( in ) = omega call mpi_bcast ( wroots ( in ), 1 , & MPI_DOUBLE_COMPLEX , 0 , MPI_COMM_WORLD , ierror ) ! Run a final instance of disp: tmp = disp ( omega ) call mpi_barrier ( mpi_comm_world , ierror ) !Output and check for root jumps and NaNs: if ( proc0 ) then if ( isnancheck ( real ( omega ))) then omega = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )); jump ( in ) = . false . endif ! do imm = 1 , in - 1 if ( abs ( wroots ( in ) - wroots ( imm )). lt . D_gap ) then write ( * , '(a,6es14.4e3)' ) 'Root too close!' ,& wroots ( in ), wroots ( imm ),& real ( wroots ( in )) - real ( wroots ( imm )), & aimag ( wroots ( in )) - aimag ( wroots ( imm )) wroots ( in ) = cmplx ( 0.d0 , 0.d0 ); jump ( in ) = . false . endif enddo endif call mpi_bcast ( jump ( in ), 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) end if call mpi_barrier ( mpi_comm_world , ierror ) enddo !Save roots before starting second parameter scan. om_tmp = wroots if ( mod ( it , scan ( 1 )% n_res ) == 0 ) then ! Second scan: do it2 = 0 , nt2 ! Scan through wavevector space: !if (it2==1) then if ( it2 == 0 ) then kperpi = kperp ; kpari = kpar theta_i = atan ( kperpi / kpari ) k_i = sqrt ( kperpi ** 2 + kpari ** 2 ) wroots = omlast !Deltakstep=0.d0 !domegadk=cmplx(0.d0,0.d0,kind(1.d0)) endif select case ( scan ( 2 )% type_s ) case ( 0 ) ! k_0 to k_1 if ( scan ( 2 )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperpi ) + scan ( 2 )% diff * it2 ) kpar = 1 0.d0 ** ( log10 ( kpari ) + scan ( 2 )% diff2 * it2 ) else kperp = kperpi + scan ( 2 )% diff * it2 kpar = kpari + scan ( 2 )% diff2 * it2 endif Deltakstep = 0.d0 ! to avoid having to calculate 2D gradients. case ( 1 ) ! theta_i to theta_1 if ( scan ( 2 )% log_scan ) then theta_1 = 1 0.d0 ** ( log10 ( theta_i ) + scan ( 2 )% diff * it2 ) else theta_1 = theta_i + scan ( 2 )% diff * it2 endif kperp = k_i * sin ( theta_1 ) kpar = k_i * cos ( theta_1 ) Deltakstep = theta_1 - theta_i case ( 2 ) ! |k_0| to |k_1| @ constant theta if ( scan ( 2 )% log_scan ) then k_tmp = 1 0.d0 ** ( log10 ( k_i ) + scan ( 2 )% diff * it2 ) kperp = k_tmp * sin ( theta_i ) kpar = k_tmp * cos ( theta_i ) else k_tmp = ( k_i ) + scan ( 2 )% diff * it2 kperp = k_tmp * sin ( theta_i ) kpar = k_tmp * cos ( theta_i ) endif Deltakstep = sqrt ( kperp ** 2 + kpar ** 2 ) - sqrt ( kperpi ** 2 + kpari ** 2 ) case ( 3 ) ! kperp scan if ( scan ( 2 )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperpi ) + scan ( 2 )% diff * it2 ) else kperp = kperpi + scan ( 2 )% diff * it2 endif Deltakstep = kperp - kperpi case ( 4 ) ! kpar scan if ( scan ( 2 )% log_scan ) then kpar = 1 0.d0 ** ( log10 ( kpari ) + scan ( 2 )% diff * it2 ) else kpar = kpari + scan ( 2 )% diff * it2 endif Deltakstep = kpar - kpari end select if ( scan ( 2 )% type_s . ne . 4 ) then ! Scan types with varying kperp require a re-call of split_processes: call determine_nmax call split_processes if (. NOT .( sproc . EQ . 0 )) call determine_bessel_array endif call mpi_barrier ( mpi_comm_world , ierror ) if ( proc0 ) write ( * , '(a,es14.4e3,a,es14.4e3)' ) 'kperp: ' , kperp , ' kpar: ' , kpar do in = 1 , nroots !Search for new roots: if ( jump ( in )) then omega = wroots ( in ) ! Extrapolate the initial guess along the direction in k-scans: !!KGK: This line causes the solution to (occasionally) !!smoothly transition to unphysical values. !!Suppressing until we understand the error. !omega=omega+domegadk(in)*Deltakstep !call secant(omega,in) !domegadk(in)=omega-wroots(in) !wroots(in)=omega !KGK: Testing Alternative Root Finding Schemes select case ( secant_method ) case ( 0 ) call secant ( omega , in ) case ( 1 ) omega = rtsec ( disp , omega , in , iflag ) case ( 2 ) call secant_osc ( omega , in ) end select wroots ( in ) = omega call mpi_bcast ( wroots ( in ), 1 , & MPI_DOUBLE_COMPLEX , 0 , MPI_COMM_WORLD , ierror ) tmp = disp ( omega ) call mpi_barrier ( mpi_comm_world , ierror ) ! Eigenfunctions and heating rates: ! only call on wavevector steps that will be output: if (( mod ( it , scan ( 1 )% n_res ) == 0 ). and .( mod ( it2 , scan ( 2 )% n_res ) == 0 )) then if (( scan ( 1 )% eigen_s ). or .(( scan ( 1 )% heat_s ))) then call calc_eigen ( omega , ef , bf , Us , ds , Ps , Ps_split , scan ( 1 )% eigen_s , scan ( 1 )% heat_s ) !reassign omega: omega = wroots ( in ) endif endif call mpi_barrier ( mpi_comm_world , ierror ) ! Output: if ( proc0 ) then if ( isnancheck ( real ( omega ))) then omega = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )); jump ( in ) = . false . endif ! infty Check: if ( abs ( tmp ) . gt . 1.d100 ) then omega = cmplx ( 0.d0 , 0.d0 ); jump ( in ) = . false . endif do imm = 1 , in - 1 if ( abs ( wroots ( in ) - wroots ( imm )). lt . D_gap ) then write ( * , '(a,6es14.4e3)' ) 'Root too close!' ,& wroots ( in ), wroots ( imm ),& real ( wroots ( in )) - real ( wroots ( imm )), & aimag ( wroots ( in )) - aimag ( wroots ( imm )) wroots ( in ) = cmplx ( 0.d0 , 0.d0 ); jump ( in ) = . false . endif enddo if (( mod ( it , scan ( 1 )% n_res ) == 0 ). and .(( mod ( it2 , scan ( 2 )% n_res ) == 0 ))) then open ( unit = scan_unit ( in ), file = trim ( scanName ( in )),& status = 'old' , position = 'append' ) write ( scan_unit ( in ), '(4es14.4e3)' ) & kperp , kpar , wroots ( in ) close ( scan_unit ( in )) if ( scan ( 1 )% eigen_s ) then open ( unit = eigen_unit ( in ), file = trim ( eigenName ( in )), status = 'old' , position = 'append' ) write ( eigen_unit ( in ), trim ( fmt_eigen )) & kperp , kpar , wroots ( in ), ef , bf , Us , ds close ( eigen_unit ( in )) endif if ( scan ( 1 )% heat_s ) then open ( unit = heat_unit ( in ), file = trim ( heatName ( in )), status = 'old' , position = 'append' ) write ( heat_unit ( in ), trim ( fmt_heat )) & kperp , kpar , wroots ( in ), Ps close ( heat_unit ( in )) open ( unit = heat_mech_unit ( in ), file = trim ( heatMechName ( in )), status = 'old' , position = 'append' ) write ( heat_mech_unit ( in ), trim ( fmt_heat_mech )) & kperp , kpar , wroots ( in ), Ps_split close ( heat_mech_unit ( in )) endif endif endif call mpi_bcast ( jump ( in ), 1 , MPI_LOGICAL , 0 , MPI_COMM_WORLD , ierror ) endif call mpi_barrier ( mpi_comm_world , ierror ) enddo enddo !Recall Saved roots if ( proc0 ) then write ( * , * ) '-=-=-=-=-=' write ( * , * ) '-=-=-=-=-=' endif do in = 1 , nroots !omlast(in)=omsafe(in) if ( proc0 ) & write ( * , '(a,i3,a,2es14.4)' ) 'Root ' , in , ': ' , omlast ( in ) enddo if (( proc0 ). and .( mod ( it , scan ( 1 )% n_res ) == 0 )) then do in = 1 , nroots open ( unit = scan_unit ( in ), file = trim ( scanName ( in )),& status = 'old' , position = 'append' ) write ( scan_unit ( in ), * ) close ( scan_unit ( in )) if ( scan ( 1 )% eigen_s ) then open ( unit = eigen_unit ( in ), file = trim ( eigenName ( in )), status = 'old' , position = 'append' ) write ( eigen_unit ( in ), * ) close ( eigen_unit ( in )) endif if ( scan ( 1 )% heat_s ) then open ( unit = heat_unit ( in ), file = trim ( heatName ( in )), status = 'old' , position = 'append' ) write ( heat_unit ( in ), * ) close ( heat_unit ( in )) open ( unit = heat_mech_unit ( in ), file = trim ( heatMechName ( in )), status = 'old' , position = 'append' ) write ( heat_mech_unit ( in ), * ) close ( heat_mech_unit ( in )) endif enddo endif endif itt = 0 select case ( scan ( 2 )% type_s ) case ( 0 ) ! k_0 to k_1 if ( scan ( 2 )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperp_last ) + scan ( 2 )% diff * itt ) kpar = 1 0.d0 ** ( log10 ( kpar_last ) + scan ( 2 )% diff2 * itt ) else kperp = kperp_last + scan ( 2 )% diff * itt kpar = kpar_last + scan ( 2 )% diff2 * itt endif case ( 1 ) ! theta_0 to theta_1 if ( scan ( 2 )% log_scan ) then theta_1 = 1 0.d0 ** ( log10 ( theta_0 ) + scan ( 2 )% diff * itt ) else theta_1 = theta_0 + scan ( 2 )% diff * itt endif kperp = k_0 * sin ( theta_1 ) kpar = k_0 * cos ( theta_1 ) case ( 2 ) ! |k_0| to |k_1| @ constant theta if ( scan ( 2 )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperp_last ) + scan ( 2 )% diff * itt ) kpar = 1 0.d0 ** ( log10 ( kpar_last ) + scan ( 2 )% diff2 * itt ) else kperp = kperp_last + scan ( 2 )% diff * itt kpar = kpar_last + scan ( 2 )% diff2 * itt endif case ( 3 ) ! kperp scan if ( scan ( 2 )% log_scan ) then kperp = 1 0.d0 ** ( log10 ( kperp_last ) + scan ( 2 )% diff * itt ) else kperp = kperp_last + scan ( 2 )% diff * itt endif case ( 4 ) ! kpar scan if ( scan ( 2 )% log_scan ) then kpar = 1 0.d0 ** ( log10 ( kpar_last ) + scan ( 2 )% diff * itt ) else kpar = kpar_last + scan ( 2 )% diff * itt endif end select if ( scan ( 2 )% type_s . ne . 4 ) then ! Scan types with varying kperp require a re-call of split_processes: call determine_nmax call split_processes if (. NOT .( sproc . EQ . 0 )) call determine_bessel_array endif enddo if ( proc0 ) then deallocate ( scan_unit ) deallocate ( scanName ) endif deallocate ( om_tmp ) end subroutine om_double_scan subroutine map_search !! This subroutine calculates the map of the determinant of the dispersion tensor in complex frequency space. use ALPS_var , only : ierror use ALPS_var , only : omi , omf , gami , gamf , loggridw , loggridg , determine_minima use ALPS_var , only : ni , nr , proc0 , ms , ns , qs , runname , nspec use ALPS_var , only : writeOut , kperp , kpar , wroots , numroots , nroots , nroots_max use ALPS_io , only : get_unused_unit use mpi implicit none double precision :: dr !! Infinitesimal spacing in real part of frequency. double precision :: di !! Infinitesimal spacing in imaginar part of frequency. double precision :: wr !! Real part of frequency. double precision :: wi !! Imaginary part of frequency. double precision , dimension (:,:), pointer :: val !! Real part of determinant of dispersion tensor. (1:nr,1:ni) double complex , dimension (:,:), allocatable :: cal !! Value of determinant of dispersion tensor. (1:nr,1:ni) double complex , dimension (:,:), allocatable :: om !! Array of complex wave frequency \\omega. (1:nr,1:ni) double complex :: omega !! Complex wave frequency \\omega. integer :: ir !! Index to loop over real part of frequency. integer :: ii !! Index to loop over imaginary part of frequency. integer :: is !! Index to loop over species. integer :: iw !! Index to loop over roots. character ( 500 ) :: mapName !! File name for output of map. integer , dimension ( 1 : 2 , 1 : numroots ) :: iroots !! Indices of roots in local minimum search. integer :: unit_map !! Unit for map output. double precision :: tmp !! Storage variable for determinant of dispersion tensor. if ( writeOut . and . proc0 . and . . true .) then write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-=-' write ( * , '(a)' ) 'Global Plasma Parameters:' write ( * , '(a,es14.3e3)' ) ' k_perp d_p   = ' , kperp write ( * , '(a,es14.3e3)' ) ' k_par  d_p   = ' , kpar do is = 1 , nspec write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-=-' write ( * , '(a,i3)' ) 'Parameters for species' , is write ( * , '(a,es14.3e3)' ) ' m_s/m_m =        ' , ms ( is ) write ( * , '(a,es14.3e3)' ) ' q_s/q_p =        ' , qs ( is ) write ( * , '(a,es14.3e3)' ) ' n_s/n_p =        ' , ns ( is ) enddo write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-=-' write ( * , '(a)' ) 'Searching over:' write ( * , '(a,es14.3e3,a,es14.3e3,a)' ) ' om  in [' , omi , ',' , omf , ']' write ( * , '(a,es14.3e3,a,es14.3e3,a)' ) ' gam in [' , gami , ',' , gamf , ']' write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-=-' endif ! Allocate array for map values: ! Value of dispersion relation on frequency grid: allocate ( cal ( nr , ni )); cal (:,:) = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) ! magnitude of cal: allocate ( val ( nr , ni )); val (:,:) = 0.d0 ! Array of complex frequencies: allocate ( om ( nr , ni )); om (:,:) = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) ! Determine spacing in complex omega space (Normal or log): dr = omf - omi di = gamf - gami if ( nr . GT . 1 ) dr = ( omf - omi ) / ( 1.d0 * ( nr - 1 )) if ( ni . GT . 1 ) di = ( gamf - gami ) / ( 1.d0 * ( ni - 1 )) if ( proc0 ) then write ( mapName , '(3a)' ) 'solution/' , trim ( runname ), '.map' call get_unused_unit ( unit_map ) open ( unit = unit_map , file = trim ( mapName ), status = 'replace' ) close ( unit_map ) endif ! Scan over complex frequency space and calculate dispersion relation: do ir = 1 , nr if ( loggridw ) then wr = omi if ( nr . GT . 1 ) wr = omi * (( omf / omi ) ** (( 1.d0 * ( ir - 1 )) / ( 1.d0 * ( nr - 1 )))) else wr = omi + dr * ( 1.d0 * ( ir - 1 )) endif if ( proc0 . and . writeOut )& write ( * , '(a,es14.4e3)' ) ' omega_real = ' , wr do ii = 1 , ni if ( loggridg ) then wi = gami if ( ni . GT . 1 ) wi = gami * (( gamf / gami ) ** (( 1.d0 * ( ii - 1 )) / ( 1.d0 * ( ni - 1 )))) else wi = gami + di * ( 1.d0 * ( ii - 1 )) endif !!check !if (proc0.and.writeOut)& !     write(*,'(a,es11.4)')' gamma = ',wi omega = cmplx ( wr , wi , kind ( 1.d0 )) om ( ir , ii ) = omega cal ( ir , ii ) = disp ( omega ) !!check !if (proc0.and.writeOut)& !     write(*,'(4es13.6)')omega,cal(ir,ii) val ( ir , ii ) = abs ( cal ( ir , ii )) if ( proc0 ) then tmp = cal ( ir , ii ) val ( ir , ii ) = log10 ( val ( ir , ii )) !NaN Check: if ( aimag ( cal ( ir , ii )). ne . 0.d0 ) then if (. not .( tmp . ne . cal ( ir , ii )) ) then cal ( ir , ii ) = 99999 9.d0 ; val ( ir , ii ) = 99999 9.d0 endif else if (( tmp . ne . cal ( ir , ii )) ) then cal ( ir , ii ) = 99999 9.d0 ; val ( ir , ii ) = 99999 9.d0 endif endif !infty Check: if ( abs ( tmp ) . gt . 1.d100 ) then cal ( ir , ii ) = 89999 9.d0 ; val ( ir , ii ) = 89999 9.d0 endif open ( unit = unit_map , file = trim ( mapName ), status = 'old' , position = 'append' ) write ( unit_map , '(5es16.6e3)' ) & om ( ir , ii ), val ( ir , ii ), cal ( ir , ii ) close ( unit_map ) endif enddo if ( proc0 ) then open ( unit = unit_map , file = trim ( mapName ), status = 'old' , position = 'append' ) write ( unit_map , * ) close ( unit_map ) endif enddo if ( determine_minima ) then !Search for Local Minima in Dispersion Surface: if ( proc0 . and .( nr . gt . 1 ). and .( ni . gt . 1 )) then write ( * , * ) 'finding minima' call find_minima ( val , numroots , iroots , nroots_max ) if ( writeOut ) & write ( * , '(i2,a)' ) nroots_max , '  possible local minimum found' do iw = 1 , nroots_max wroots ( iw ) = om ( iroots ( 1 , iw ), iroots ( 2 , iw )) if ( writeOut ) then write ( * , '(a,i4,a,i4)' ) 'ir = ' , iroots ( 1 , iw ), '    ii = ' , iroots ( 2 , iw ) write ( * , '(4es15.4e3)' ) wroots ( iw ) , cal ( iroots ( 1 , iw ), iroots ( 2 , iw )) endif enddo nroots = min ( nroots , nroots_max ) endif call mpi_bcast ( nroots , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( wroots (:), size ( wroots (:)), MPI_DOUBLE_COMPLEX , 0 , MPI_COMM_WORLD , ierror ) call refine_guess call mpi_bcast ( nroots , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierror ) call mpi_bcast ( wroots (:), size ( wroots (:)), MPI_DOUBLE_COMPLEX , 0 , MPI_COMM_WORLD , ierror ) endif end subroutine map_search subroutine refine_guess !! This subroutine refines the guess at the starting point of the search for solutions to the dispersion relation when scanning. It is also used by [[map_search]] to identify the roots on the map. use alps_var , only : wroots , nroots , writeOut , proc0 use alps_var , only : ierror , runname use alps_var , only : secant_method use alps_io , only : get_unused_unit use mpi implicit none double complex :: omega !! Complex wave frequency \\omega. character ( 500 ) :: mapName !! File name for output of map. double complex :: tmpDisp !! Storage variable for determinant of the dispersion tensor. integer :: iw !! Index to loop over roots. integer :: unit_refine !! File unit for refinement output. integer :: iflag !! Number of steps taken for root finding in rtsec. if ( proc0 ) then if ( writeOut ) write ( * , '(a)' ) ' Refining Roots:' write ( mapName , '(3a)' ) 'solution/' , trim ( runname ), '.roots' call get_unused_unit ( unit_refine ) open ( unit = unit_refine , file = trim ( mapName ), status = 'replace' ) endif do iw = 1 , nroots call mpi_barrier ( mpi_comm_world , ierror ) omega = wroots ( iw ) !KGK: Testing Alternative Root Finding Schemes select case ( secant_method ) case ( 0 ) call secant ( omega , iw ) case ( 1 ) omega = rtsec ( disp , omega , iw , iflag ) case ( 2 ) call secant_osc ( omega , iw ) end select wroots ( iw ) = omega tmpDisp = disp ( wroots ( iw )) if ( proc0 . and .( abs ( tmpDisp ). NE . 0.d0 )) then write ( unit_refine , '(i4,5es14.4e3)' ) iw , wroots ( iw ), log10 ( abs ( tmpDisp )), tmpDisp write ( * , '(i4,5es14.4e3)' ) iw , wroots ( iw ), log10 ( abs ( tmpDisp )), tmpDisp !       if (writeOut) write(*,'(a,2es14.4e3,a,2es14.4e3)')'D(',wroots(iw),')= ',tmpDisp endif enddo if ( proc0 ) close ( unit_refine ) end subroutine refine_guess subroutine find_minima ( val , numroots , iroots , nroots ) !! This subroutine identifies the minima of the coarse map grid. It is called by [[map_search]]. !! The code is based on a routine by Greg Howes, 2006. use ALPS_var , only : ni , nr implicit none double precision , dimension (:,:), pointer , intent ( in ) :: val !! Array of determinant of the dispersion tensor. integer , intent ( in ) :: numroots !! Number of roots. integer , dimension ( 1 : 2 , 1 : numroots ), intent ( out ) :: iroots !! Indices of roots. integer , intent ( out ) :: nroots !! Number of roots found. integer :: ir !! Index to loop over real parts of frequency. integer :: ii !! Index to loop over imaginary parts of frequency. iroots = 0 nroots = 0 do ii = ni , 1 , - 1 do ir = 1 , nr !ir = 0 if ( ir == 1 ) then if ( val ( ir , ii ) . lt . val ( ir + 1 , ii )) then if ( ii == 1 ) then if ( val ( ir , ii ) . lt . val ( ir , ii + 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif elseif ( ii == ni ) then if ( val ( ir , ii ) . lt . val ( ir , ii - 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif else if ( val ( ir , ii ) . lt . val ( ir , ii - 1 ) . and . & val ( ir , ii ) . lt . val ( ir , ii + 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif endif endif elseif ( ir == nr ) then if ( val ( ir , ii ) . lt . val ( ir - 1 , ii )) then if ( ii == 1 ) then if ( val ( ir , ii ) . lt . val ( ir , ii + 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif elseif ( ii == ni ) then if ( val ( ir , ii ) . lt . val ( ir , ii - 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif else if ( val ( ir , ii ) . lt . val ( ir , ii - 1 ) . and . & val ( ir , ii ) . lt . val ( ir , ii + 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif endif endif else if ( val ( ir , ii ) . lt . val ( ir - 1 , ii ) . and . & val ( ir , ii ) . lt . val ( ir + 1 , ii )) then if ( ii == 1 ) then if ( val ( ir , ii ) . lt . val ( ir , ii + 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif elseif ( ii == ni ) then if ( val ( ir , ii ) . lt . val ( ir , ii - 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif else if ( val ( ir , ii ) . lt . val ( ir , ii - 1 ) . and . & val ( ir , ii ) . lt . val ( ir , ii + 1 )) then nroots = nroots + 1 iroots ( 1 , nroots ) = ir iroots ( 2 , nroots ) = ii endif endif endif endif enddo enddo write ( * , * ) nroots end subroutine find_minima subroutine determine_nmax () !! This subroutine determines the maximum required order of the Bessel functions in Eq. (2.9) of the code paper. use ALPS_var , only : pp , kperp , qs , Bessel_zero , nmax , ierror use ALPS_var , only : proc0 , nperp , nspec , writeOut , nproc , usebM use ALPS_fns_rel , only : BESSJ use mpi implicit none integer :: is !! Index of particle species. integer :: nn !! Order of Bessel function. double precision :: bessel !! Bessel function. double precision :: besselmax !! Check variable for largest Bessel function. double precision :: z !! Argument of the Bessel function. integer :: iperp !! Index for loop over perpendicular momentum. integer :: ipar !! Index for loop over parallel momentum. integer :: max_procs !! Maximum number of processes. logical :: modified_nmax !! Check whether additional n are available due to number of processes. ipar = 1 max_procs = nspec do is = 1 , nspec if ( usebM ( is )) then nmax ( is ) = 1 else nn = 0 besselmax = 1 0.d0 do while ( besselmax . GT . Bessel_zero ) nn = nn + 1 if ( nn . GT . 1000 ) write ( * , * ) 'Bessel-function n is greater than 1000.' besselmax = 0.d0 do iperp = 0 , nperp z = kperp * pp ( is , iperp , ipar , 1 ) / qs ( is ) bessel = abs ( BESSJ ( nn , z )) besselmax = max ( besselmax , bessel ) enddo enddo nmax ( is ) = nn endif if ( writeOut . and . proc0 ) & write ( * , '(a,i0,a,i0,a)' ) 'Required nMax for species ' , is , ' : ' , nmax ( is ) max_procs = max_procs + nmax ( is ) enddo ! If we have too many processes, then allow for additional n's: ! The condition is that max_procs has to be greater or equal (nproc-1): is = 1 modified_nmax = . FALSE . do while ( max_procs . LT .( nproc - 1 )) if (. NOT . usebM ( is )) then modified_nmax = . TRUE . nmax ( is ) = nmax ( is ) + 1 endif is = is + 1 max_procs = max_procs + 1 if ( is . GT . nspec ) is = 1 enddo if ( modified_nmax . AND . proc0 . AND . writeOut ) then write ( * , '(a)' ) \"More processes than required. nMax is adjusted.\" do is = 1 , nspec write ( * , '(a,i0,a,i0,a)' ) ' Adjusted nMax for Species ' , is , ' : ' , nmax ( is ) enddo endif call mpi_barrier ( mpi_comm_world , ierror ) end subroutine determine_nmax subroutine split_processes () !! This subroutine defines the tasks for the individual processes. It uses the number of species and the required orders of the Bessel functions to define the splitting across the MPI processes. use alps_var , only : nproc , iproc , nmax , nlim , ierror use alps_var , only : nspec , sproc , writeOut , proc0 use mpi implicit none integer :: is !! Index of particle species. integer :: max_procs !! Maximum number of processes. integer :: ideal_ns_per_proc !! Ideal number of n's per process. integer :: proc_per_spec ( nspec ) !! Number of processes for each species. integer :: ideal_splitting ( nspec ) !! Ideal number of n's for each process associated with a given species. integer :: splitting_rest ( nspec ) !! Rest of n's after ideal splitting for each process associated with a given species. integer :: largest_rest !! Largest rest of splitting. integer :: largest_spec !! Index of species with the largest rest of splitting. integer :: used_procs !! Number of used processes. integer :: proc_count !! Index to count processes. integer :: prev_proc_count !! Storage variable for index to count processes. integer :: local_iproc !! Local process number (in species field). integer :: rest_sum !! Sum over the rests of n's. max_procs = nspec ! to include the Bessel functions with n = 0 for all species do is = 1 , nspec max_procs = max_procs + nmax ( is ) enddo ideal_ns_per_proc = ceiling (( 1. * max_procs ) / ( 1. * nproc - 1. )) used_procs = 0 rest_sum = 0 ! Define number of processes for each species: do is = 1 , nspec if (( nmax ( is ) + 1 ). LE . ideal_ns_per_proc ) then proc_per_spec ( is ) = 1 else proc_per_spec ( is ) = ( nmax ( is ) + 1 ) / ideal_ns_per_proc ! COULD LEAVE A REST endif ideal_splitting ( is ) = ( nmax ( is ) + 1 ) / proc_per_spec ( is ) ! is the ideal splitting of species is splitting_rest ( is ) = modulo (( nmax ( is ) + 1 ), proc_per_spec ( is )) ! Every process for species is should get as close as possible to this number. ! This is a little bit better than just using ideal_ns_per_proc. The last one will get the rest. !  Determine number of remaining processes: used_procs = used_procs + proc_per_spec ( is ) rest_sum = rest_sum + splitting_rest ( is ) enddo if ( proc0 . AND . writeOut ) then if ( modulo (( max_procs + rest_sum + 1 ), 2 ). EQ . 0 ) then write ( * , '(a,i0)' )& 'Ideal Number of Processors: ' , max_procs + rest_sum + 1 else write ( * , '(a,i0)' )& 'Ideal Number of Processors: ' , max_procs + rest_sum endif write ( * , '(a,i0)' ) '-=-=-=-=-=-=-=-=-=-' endif call mpi_barrier ( mpi_comm_world , ierror ) ! Determine species with the largest rest of n's: largest_spec = 1 largest_rest = 0 do is = 1 , nspec if ( splitting_rest ( is ). GT . largest_rest ) then largest_spec = is largest_rest = splitting_rest ( is ) endif enddo ! The rest of processes go to species largest_spec: proc_per_spec ( largest_spec ) = proc_per_spec ( largest_spec ) + (( nproc - 1 ) - used_procs ) ideal_splitting ( largest_spec ) = nint (( 1. * nmax ( largest_spec ) + 1. ) / ( 1. * proc_per_spec ( largest_spec ))) proc_count = 0 prev_proc_count = 0 do is = 1 , nspec proc_count = proc_count + proc_per_spec ( is ) if (( iproc . LE . proc_count ). AND .( iproc . GT . prev_proc_count )) then sproc = is local_iproc = ( iproc - prev_proc_count ) nlim ( 1 ) = ( local_iproc - 1 ) * ( ideal_splitting ( is )) nlim ( 2 ) = nlim ( 1 ) + ideal_splitting ( is ) - 1 if (( local_iproc . EQ . proc_per_spec ( is )). AND .( nlim ( 1 ). LE . nmax ( is ))) nlim ( 2 ) = nmax ( is ) endif prev_proc_count = proc_count enddo !if (writeOut) & !       write(*,'(a,i4,a,i4,a,i4,a,2i4,a)') & !       'Processor ',iproc,' of ',nproc,' ready. Species ',sproc,': n in [', nlim(1:2),']' end subroutine split_processes ! determine bessel_array (this process only works on one species subroutine determine_bessel_array () !! This subroutine determines the array of Bessel functions that is used in the T-tensor of Eq. (2.10) of the code paper. use ALPS_var , only : pp , kperp , qs , sproc , bessel_array , nperp , nlim use ALPS_io , only : get_unused_unit use ALPS_fns_rel , only : BESSJ implicit none integer :: nn !! Order of Bessel function. double precision :: z !! Argument of the Bessel function. integer :: iperp !! Index for loop over perpendicular momentum. integer :: ipar !! Index for loop over parallel momentum. ipar = 1 ! Allocate bessel_array: if ( allocated ( bessel_array )) deallocate ( bessel_array ) allocate ( bessel_array ( nlim ( 1 ) - 1 : nlim ( 2 ) + 1 , 0 : nperp )); bessel_array = 0.d0 ! Fill this array with values: do nn = nlim ( 1 ) - 1 , nlim ( 2 ) + 1 do iperp = 0 , nperp z = kperp * pp ( sproc , iperp , ipar , 1 ) / qs ( sproc ) if ( nn . EQ . - 1 ) then bessel_array ( nn , iperp ) =- BESSJ ( 1 , z ) else bessel_array ( nn , iperp ) = BESSJ ( nn , z ) endif enddo enddo end subroutine determine_bessel_array end module alps_fns","tags":"","url":"sourcefile/alps_fns.f90.html"},{"title":"ALPS_fns_rel.f90 – ALPS","text":"Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_fns_rel !! This module contains the relativistic numerical functions of ALPS. implicit none private :: int_T_rel , int_T_res_rel , integrate_resU_rel private :: funct_g_rel private :: determine_sproc_rel , fact public :: derivative_f0_rel , polyharmonic_spline public :: integrate_res_rel , landau_integrate_rel , resU_rel public :: bessj0 , bessj1 , bessj contains !-=-=-=-=-=-= subroutine derivative_f0_rel ( is , is_rel ) !! This subroutine calculates the derivatives of the background velocity distribution function f0 for the relativistic calculation. use alps_var , only : f0 , pp , nperp , npar , vA , ms , writeOut , arrayName use alps_var , only : f0_rel , df0_rel , gamma_rel , pparbar_rel , nspec_rel , ngamma , npparbar use alps_var , only : writeOut , pi use alps_io , only : get_unused_unit implicit none integer , intent ( in ) :: is !! Index of particle species. integer , intent ( in ) :: is_rel !! Index for relativistic species (if any). integer :: n_coarse !! Number of entries in coarse grid. integer :: counter !! Index to loop over coarse grid entries. integer :: igamma !! Index to loop over \\Gamma. integer :: ipparbar !! Index to loop over relativistic parallel momentum. integer :: iperp !! Index for loop over perpendicular momentum. integer :: ipar !! Index for loop over parallel momentum. double precision :: pparbar_max !! Maximum value of relativistic parallel momentum. double precision :: pparbar_min !! Minimum value of relativistic parallel momentum. double precision :: gamma_max !! Maximum value of \\Gamma. double precision :: gamma_min !! Minimum value of \\Gamma. double precision :: gamma_max_use !! Maximum usable value of \\Gamma. double precision :: dgamma_rel !! Infinitesimal step in \\Gamma. double precision :: dpparbar !! Infinitesimal step in relativistic parallel momentum. double precision , allocatable , dimension (:) :: grid_coarse !! Coarse input grid for relativistic interpolation. !! (1:n_coarse) double precision , allocatable , dimension (:) :: gamma_coarse !! Coordinates of \\Gamma on coarse grid. !! (1:n_coarse) double precision , allocatable , dimension (:) :: pparbar_coarse !! Coordinates of relativistic parallel momentum on coarse grid. !! (1:n_coarse) character ( 50 ) :: fmt !! Output format for file i/o. character ( 100 ) :: writename !! File name for file i/o. double precision :: integrate !! Integral of the distribution function. double precision :: gamma !! Lorentz factor \\Gamma. double precision :: smoothing !! Smoothing parameter for spline interpolation. integer :: unit_f !! Unit for file i/o. ! Determine the minimum and maximum values of Gamma and ppar: pparbar_min = 99999 9.d0 pparbar_max =- 99999 9.d0 gamma_min = 99999 9.d0 gamma_max =- 1.d0 do iperp = 0 , nperp do ipar = 0 , npar gamma = sqrt (( pp ( is , iperp , ipar , 1 ) ** 2 + pp ( is , iperp , ipar , 2 ) ** 2 ) * vA ** 2 / ms ( is ) ** 2 + 1.d0 ) if ( gamma . GT . gamma_max ) gamma_max = gamma if ( gamma . LT . gamma_min ) gamma_min = gamma if ( pp ( is , iperp , ipar , 2 ). LT . pparbar_min ) pparbar_min = pp ( is , iperp , ipar , 2 ) if ( pp ( is , iperp , ipar , 2 ). GT . pparbar_max ) pparbar_max = pp ( is , iperp , ipar , 2 ) enddo enddo pparbar_min = pparbar_min * vA / ms ( is ) pparbar_max = pparbar_max * vA / ms ( is ) gamma_max_use = sqrt ( 1.d0 + pp ( is , nperp , 1 , 1 ) ** 2 * vA ** 2 / ms ( is ) ** 2 ) if ( writeOut ) then write ( * , '(a,i3,a,1es14.4e3)' ) \"Maximum Gamma for species\" , is , \":\" , gamma_max write ( * , '(a,i3,a,1es14.4e3)' ) \"Minimum Gamma for species\" , is , \":\" , gamma_min write ( * , '(a,i3,a,1es14.4e3)' ) \"Maximum Pparbar: for species\" , is , \":\" , pparbar_max write ( * , '(a,i3,a,1es14.4e3)' ) \"Minimum Pparbar: for species\" , is , \":\" , pparbar_min write ( * , '(a,i3,a,1es14.4e3)' ) \"Usable Maximum Gamma for species\" , is , \":\" , gamma_max_use endif ! For now, the relativistic smoothing is set to zero. !This can become a user-defined parameter at some stage: smoothing = 0.d0 n_coarse = ( nperp + 1 ) * ( npar + 1 ) allocate ( gamma_coarse ( n_coarse )) allocate ( pparbar_coarse ( n_coarse )) allocate ( grid_coarse ( n_coarse )) counter = 0 do iperp = 0 , nperp do ipar = 0 , npar counter = counter + 1 gamma_coarse ( counter ) = sqrt ( 1.d0 + ( pp ( is , iperp , ipar , 1 ) ** 2 + pp ( is , iperp , ipar , 2 ) ** 2 ) * & vA * vA / ( ms ( is ) * ms ( is ))) pparbar_coarse ( counter ) = pp ( is , iperp , ipar , 2 ) * vA / ms ( is ) grid_coarse ( counter ) = log ( f0 ( is , iperp , ipar )) enddo enddo do igamma = 0 , ngamma do ipparbar = 0 , npparbar gamma_rel ( is_rel , igamma , ipparbar ) = gamma_min + (( gamma_max_use - gamma_min ) * igamma ) / ( 1.d0 * ngamma ) pparbar_rel ( is_rel , igamma , ipparbar ) = pparbar_min + (( pparbar_max - pparbar_min ) * ipparbar ) / ( 1.d0 * npparbar ) enddo enddo if ( writeOut ) write ( * , '(a)' ) 'Polyharmonic spline interpolation on relativistic grid...' call polyharmonic_spline ( grid_coarse , gamma_coarse , pparbar_coarse , n_coarse , gamma_rel , pparbar_rel ,& ngamma , npparbar , smoothing , f0_rel , is_rel , nspec_rel ) ! Stay within the subluminal cone: do igamma = 0 , ngamma do ipparbar = 0 , npparbar f0_rel ( is_rel , igamma , ipparbar ) = exp ( f0_rel ( is_rel , igamma , ipparbar )) if (( gamma_rel ( is_rel , igamma , ipparbar ) ** 2 - 1.d0 ). LT .( pparbar_rel ( is_rel , igamma , ipparbar ) ** 2 ))& f0_rel ( is_rel , igamma , ipparbar ) =- 1.d0 enddo enddo integrate = 0.d0 dgamma_rel = gamma_rel ( is_rel , 2 , 2 ) - gamma_rel ( is_rel , 1 , 2 ) dpparbar = pparbar_rel ( is_rel , 2 , 2 ) - pparbar_rel ( is_rel , 2 , 1 ) do igamma = 0 , ngamma do ipparbar = 0 , npparbar if ( f0_rel ( is_rel , igamma , ipparbar ). GT . - 1.d0 ) then integrate = integrate + & gamma_rel ( is_rel , igamma , ipparbar ) * f0_rel ( is_rel , igamma , ipparbar ) * & 2.d0 * pi * dgamma_rel * dpparbar * ( ms ( is ) / vA ) ** 3 endif enddo enddo write ( * , '(a,i3,a, 2es14.4e3)' ) 'Integration of species' , is , ':' , integrate if ( writeOut ) write ( * , '(a)' ) 'Writing relativistic grid to file...' write ( fmt , '(a)' ) '(2es14.4e3,1es14.4e3)' write ( writeName , '(3a,i0,a)' ) 'distribution/' , trim ( arrayName ), '_f0_rel.' , is , '.array' call get_unused_unit ( unit_f ) open ( unit = unit_f , file = trim ( writeName ), status = 'replace' ) do igamma = 0 , ngamma do ipparbar = 0 , npparbar if ( f0_rel ( is_rel , igamma , ipparbar ). NE . - 1.d0 ) f0_rel ( is_rel , igamma , ipparbar ) = f0_rel ( is_rel , igamma , ipparbar ) / integrate write ( unit_f , fmt ) gamma_rel ( is_rel , igamma , ipparbar ), pparbar_rel ( is_rel , igamma , ipparbar ),& f0_rel ( is_rel , igamma , ipparbar ) enddo write ( unit_f , * ) enddo close ( unit_f ) if ( writeOut ) write ( * , '(a)' ) 'Determining relativistic derivatives...' do igamma = 1 , ngamma - 1 do ipparbar = 1 , npparbar - 1 ! index 1-> gamma derivative: df0_rel ( is_rel , igamma , ipparbar , 1 ) = 0.d0 if (( f0_rel ( is_rel , igamma - 1 , ipparbar ). GT . 0.d0 ). AND .( f0_rel ( is_rel , igamma + 1 , ipparbar ). GT . 0.d0 )) then df0_rel ( is_rel , igamma , ipparbar , 1 ) = & ( f0_rel ( is_rel , igamma + 1 , ipparbar ) - f0_rel ( is_rel , igamma - 1 , ipparbar )) / & ( gamma_rel ( is_rel , igamma + 1 , ipparbar ) - gamma_rel ( is_rel , igamma - 1 , ipparbar )) endif ! index 2-> pparbar derivative: df0_rel ( is_rel , igamma , ipparbar , 2 ) = 0.d0 if (( f0_rel ( is_rel , igamma , ipparbar + 1 ). GT . 0.d0 ). AND .( f0_rel ( is_rel , igamma , ipparbar - 1 ). GT . 0.d0 )) then df0_rel ( is_rel , igamma , ipparbar , 2 ) = & ( f0_rel ( is_rel , igamma , ipparbar + 1 ) - f0_rel ( is_rel , igamma , ipparbar - 1 )) / & ( pparbar_rel ( is_rel , igamma , ipparbar + 1 ) - pparbar_rel ( is_rel , igamma , ipparbar - 1 )) endif if ( f0_rel ( is_rel , igamma , ipparbar ). GE . 0.d0 ) then if (( f0_rel ( is_rel , igamma , ipparbar + 1 ). LE . 0.d0 ). AND .( f0_rel ( is_rel , igamma , ipparbar - 1 ). GT . 0.d0 )) then df0_rel ( is_rel , igamma , ipparbar , 2 ) = & ( f0_rel ( is_rel , igamma , ipparbar ) - f0_rel ( is_rel , igamma , ipparbar - 1 )) / & ( pparbar_rel ( is_rel , igamma , ipparbar ) - pparbar_rel ( is_rel , igamma , ipparbar - 1 )) endif if (( f0_rel ( is_rel , igamma , ipparbar + 1 ). GT . 0.d0 ). AND .( f0_rel ( is_rel , igamma , ipparbar - 1 ). LE . 0.d0 )) then df0_rel ( is_rel , igamma , ipparbar , 2 ) = & ( f0_rel ( is_rel , igamma , ipparbar + 1 ) - f0_rel ( is_rel , igamma , ipparbar )) / & ( pparbar_rel ( is_rel , igamma , ipparbar + 1 ) - pparbar_rel ( is_rel , igamma , ipparbar )) endif endif enddo enddo if ( writeOut ) write ( * , '(a)' ) 'Writing relativistic derivatives to file...' write ( fmt , '(a)' ) '(2es14.4e3,2es14.4e3)' write ( writeName , '(3a,i0,a)' ) 'distribution/' , trim ( arrayName ), '_dfdv_rel.' , is , '.array' call get_unused_unit ( unit_f ) open ( unit = unit_f , file = trim ( writeName ), status = 'replace' ) do igamma = 0 , ngamma do ipparbar = 0 , npparbar write ( unit_f , fmt ) gamma_rel ( is_rel , igamma , ipparbar ), pparbar_rel ( is_rel , igamma , ipparbar ),& df0_rel ( is_rel , igamma , ipparbar , 1 ), df0_rel ( is_rel , igamma , ipparbar , 2 ) enddo write ( unit_f , * ) enddo close ( unit_f ) if ( writeOut ) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' end subroutine derivative_f0_rel subroutine polyharmonic_spline ( grid_coarse , gamma_coarse , pparbar_coarse , n_coarse , gamma_rel , pparbar , ngamma , npparbar ,& smoothing , f0_rel , is_rel , nspec_rel ) !! This soubroutine interpolates the grid with a polyharmonic thin-plate spline. !! This subroutine needs the LUPACK and BLAS libraries to evoke the dgesv subroutine. !! The method uses the Thin Plate Spline. !! We use these resources: !! [http://cseweb.ucsd.edu/~sjb/eccv_tps.pdf](http://cseweb.ucsd.edu/~sjb/eccv_tps.pdf) !! [http://www.univie.ac.at/nuhag-php/bibtex/open_files/po94_M%20J%20D%20Powell%2003%2093.pdf](http://www.univie.ac.at/nuhag-php/bibtex/open_files/po94_M%20J%20D%20Powell%2003%2093.pdf) !! [http://vision.ucsd.edu/sites/default/files/fulltext(4).pdf](http://vision.ucsd.edu/sites/default/files/fulltext(4).pdf) implicit none double precision , intent ( in ) :: grid_coarse ( n_coarse ) !! Coarse input grid for interpolation. double precision , intent ( in ) :: gamma_coarse ( n_coarse ) !! Coordinates of \\Gamma on coarse grid. double precision , intent ( in ) :: pparbar_coarse ( n_coarse ) !! Coordinates of relativistic parallel momentum on coarse grid. integer , intent ( in ) :: n_coarse !! Number of entries in coarse grid. double precision , intent ( in ) :: gamma_rel ( nspec_rel , 0 : ngamma , 0 : npparbar ) !! Coordinates of \\Gamma on fine grid. double precision , intent ( in ) :: pparbar ( nspec_rel , 0 : ngamma , 0 : npparbar ) !! Coordinates of relativistic parallel momentum on fine grid. integer , intent ( in ) :: ngamma !! Number of \\Gamma steps on fine output grid. integer , intent ( in ) :: npparbar !! Number of parallel momentum steps on fine output grid. double precision , intent ( in ) :: smoothing !! Smoothing parameter for spline interpolation. double precision , intent ( out ) :: f0_rel ( nspec_rel , 0 : ngamma , 0 : npparbar ) !! Fine output grid after interpolation. integer :: i !! Index to loop over n_coarse. integer :: j !! Index to loop over n_coarse. integer :: k !! Index to loop over n_coarse. integer :: permutation_index ( n_coarse + 3 ) !! Permutation index for [[dgesv]] from LUPACK/BLAS. integer :: nspec_rel !! Number of relativistic species. integer :: is_rel !! Index for relativistic species (if any). double precision :: fullmatrix ( n_coarse + 3 , n_coarse + 3 ) !! K-matrix for spline interpolation. double precision :: grid_vector ( n_coarse + 3 ) !! Vector of the coarse grid. Required for 3 additional entries compared to grid_coarse. double precision :: weight_param ( n_coarse + 3 ) !! Weight parameter for spline interpolation. double precision :: r !! Distance between coarse and fine grid points. double precision :: INFO !! Info flag for [[dgesv]] from LUPACK/BLAS. grid_vector = 0.d0 do i = 1 , n_coarse grid_vector ( i ) = grid_coarse ( i ) enddo fullmatrix = 0.d0 do i = 1 , n_coarse do j = 1 , n_coarse ! Do the K-matrix part first: r = sqrt (( gamma_coarse ( i ) - gamma_coarse ( j )) ** 2 + ( pparbar_coarse ( i ) - pparbar_coarse ( j )) ** 2 ) if ( r . GE . 1.d0 ) then fullmatrix ( i , j ) = r * r * log ( r ) elseif ( r . EQ . 0.d0 ) then fullmatrix ( i , j ) = 0.d0 else fullmatrix ( i , j ) = r * log ( r ** r ) endif enddo fullmatrix ( i , i ) = fullmatrix ( i , i ) + smoothing ! Now the P-matrix parts: fullmatrix ( i , n_coarse + 1 ) = 1.d0 fullmatrix ( i , n_coarse + 2 ) = gamma_coarse ( i ) fullmatrix ( i , n_coarse + 3 ) = pparbar_coarse ( i ) ! and the transposed P-matrix: fullmatrix ( n_coarse + 1 , i ) = 1.d0 fullmatrix ( n_coarse + 2 , i ) = gamma_coarse ( i ) fullmatrix ( n_coarse + 3 , i ) = pparbar_coarse ( i ) enddo weight_param = grid_vector call dgesv ( n_coarse + 3 , 1 , fullmatrix , n_coarse + 3 , permutation_index , weight_param , n_coarse + 3 , INFO ) f0_rel ( is_rel ,:,:) = 0.d0 do i = 0 , ngamma do j = 0 , npparbar do k = 1 , n_coarse r = sqrt (( gamma_rel ( is_rel , i , j ) - gamma_coarse ( k )) ** 2 + ( pparbar ( is_rel , i , j ) - pparbar_coarse ( k )) ** 2 ) if ( r . GE . 1.d0 ) then f0_rel ( is_rel , i , j ) = f0_rel ( is_rel , i , j ) + weight_param ( k ) * r * r * log ( r ) elseif ( r . EQ . 0.d0 ) then f0_rel ( is_rel , i , j ) = f0_rel ( is_rel , i , j ) else f0_rel ( is_rel , i , j ) = f0_rel ( is_rel , i , j ) + weight_param ( k ) * r * log ( r ** r ) endif enddo f0_rel ( is_rel , i , j ) = f0_rel ( is_rel , i , j ) + weight_param ( n_coarse + 1 ) + & weight_param ( n_coarse + 2 ) * gamma_rel ( is_rel , i , j ) + weight_param ( n_coarse + 3 ) * pparbar ( is_rel , i , j ) enddo enddo end subroutine subroutine determine_sproc_rel ( sproc_rel ) !! This subroutine determines sproc_rel for the given process. use alps_var , only : relativistic , sproc , nspec implicit none integer , intent ( out ) :: sproc_rel !! is_rel of the current process. integer :: is !! Index of particle species. integer :: is_rel !! Index for relativistic species. is_rel = 0 do is = 1 , nspec if ( relativistic ( is )) then is_rel = is_rel + 1 if ( is . EQ . sproc ) sproc_rel = is_rel endif enddo end subroutine ! This function does the relativistic integration around resonances if necessary: double complex function integrate_res_rel ( om , nn , mode ) !! This function performs the integration near resonances as described in Section 3.1 of the code paper for a relativistic calculation. It is only called if resonances are present in or near the integration domain. use alps_var , only : ngamma , gamma_rel , pparbar_rel implicit none double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: mode !! Index of the entries in the T-tensor of Eq. (2.10). integer :: igamma !! Index to loop over \\Gamma. integer :: sproc_rel !! is_rel of the current process. double precision :: dgamma_rel !! Infinitesimal step in \\Gamma. double precision :: dpparbar !! Infinitesimal step in relativistic parallel momentum. double complex :: ii !! Imaginary unit. integrate_res_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) call determine_sproc_rel ( sproc_rel ) dgamma_rel = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ! At igamma=1, we are already missing the part from igamma=0, where we should actually start. ! Therefore, we use 2 instead of 1 in the trapezoid integration: do igamma = 1 , ngamma - 2 integrate_res_rel = integrate_res_rel + 2.d0 * integrate_resU_rel ( sproc_rel , om , nn , mode , igamma ) enddo igamma = ngamma - 1 integrate_res_rel = integrate_res_rel + integrate_resU_rel ( sproc_rel , om , nn , mode , igamma ) integrate_res_rel = integrate_res_rel * dgamma_rel * 0.25d0 return end function integrate_res_rel double complex function integrate_resU_rel ( sproc_rel , om , nn , mode , igamma ) !! This function evaluates the integral with the integrand proportional to U in Eq. (2.9) of the code paper for a relativistic calculation. use alps_var , only : npparbar , sproc , positions_principal , f0_rel , kpar , vA , ms , qs use alps_var , only : gamma_rel , pparbar_rel use alps_io , only : alps_error implicit none integer , intent ( in ) :: sproc_rel !! is_rel of the current process. double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: mode !! Index of the entries in the T-tensor of Eq. (2.10). integer , intent ( in ) :: igamma !! Index to loop over \\Gamma. integer :: ipparbar !! Index to loop over relativistic parallel momentum. integer :: int_start !! Lower limit for integration. integer :: int_end !! Upper limit for integration. integer :: ipparbar_res !! Index of the nearest relativistic parallel momentum to the resonance. integer :: lowerlimit !! Index of lower limit for integration according to Eq. (3.5). integer :: upperlimit !! Index of upper limit for integration according to Eq. (3.5). integer :: ipparbar_lower !! Lower boundary of resonance range in relativistic parallel momentum. integer :: ipparbar_upper !! Upper boundary of resonance range in relativistic parallel momentum. double precision :: dgamma_rel !! Infinitesimal step in \\Gamma. double precision :: dpparbar !! Infinitesimal step in relativistic parallel momentum. double complex :: ii !! Imaginary unit. double complex :: pparbar_res !! Relativistic parallel momentum of the resonance. logical :: found_res !! Check whether a resonance is found. logical :: found_lower !! Check whether resonance lies in lower range of relativistic parallel momentum. logical :: found_upper !! Check whether resonance lies in upper range of relativistic parallel momentum. integrate_resU_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) dgamma_rel = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ! Determine the position of the resonance (i.e., the step LEFT of it): ipparbar = 0 ipparbar_res = 0 found_res = . FALSE . pparbar_res = ( gamma_rel ( sproc_rel , igamma , 1 ) * om - ( 1.d0 * nn ) * qs ( sproc ) / ms ( sproc )) * vA / kpar if (( real ( pparbar_res ) ** 2 ). LE .( gamma_rel ( sproc_rel , igamma , 1 ) ** 2 - 1.d0 )) then do while (( ipparbar . LT .( npparbar - 2 )). AND .(. NOT . found_res )) ipparbar = ipparbar + 1 if (( pparbar_rel ( sproc_rel , 2 , ipparbar + 1 ). GT . real ( pparbar_res )). and .& ( pparbar_rel ( sproc_rel , 2 , ipparbar ). LE . real ( pparbar_res ))) then ipparbar_res = ipparbar found_res = . TRUE . endif enddo endif ! Handle resonances that are right outside the integration domain: do ipparbar = 0 , positions_principal if (( real ( pparbar_res ). GE .( pparbar_rel ( sproc_rel , 2 , 0 ) - dpparbar * ipparbar )). AND .& ( real ( pparbar_res ). LT .( pparbar_rel ( sproc_rel , 2 , 0 ) - dpparbar * ( ipparbar - 1 )))) then ipparbar_res = - ipparbar found_res = . TRUE . endif if (( real ( pparbar_res ). GE .( pparbar_rel ( sproc_rel , 2 , npparbar - 1 ) + dpparbar * ipparbar )). AND .& ( real ( pparbar_res ). LT .( pparbar_rel ( sproc_rel , 2 , npparbar - 1 ) + dpparbar * ( ipparbar + 1 )))) then ipparbar_res = npparbar - 1 + ipparbar found_res = . TRUE . endif enddo ! Determine the limits for the integration: found_lower = . FALSE . found_upper = . FALSE . ipparbar_lower = 1 ipparbar_upper = npparbar - 1 do ipparbar = 1 , npparbar - 1 if ((. NOT . found_lower ). AND .( f0_rel ( sproc_rel , igamma , ipparbar - 1 ). LE . - 1.d0 ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 )) then ipparbar_lower = ipparbar found_lower = . TRUE . endif if ((. NOT . found_upper ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 ). AND .( f0_rel ( sproc_rel , igamma , ipparbar + 1 ). LE . - 1.d0 )) then ipparbar_upper = ipparbar found_upper = . TRUE . endif enddo if ( found_res ) then int_start = ipparbar_lower int_end = ipparbar_upper lowerlimit = ipparbar_res - positions_principal upperlimit = ipparbar_res + positions_principal + 1 if (( ipparbar_res . GE . 0 ). and .( ipparbar_res . LE . npparbar )) then if ( abs ( real ( pparbar_res ) - pparbar_rel ( sproc_rel , 2 , ipparbar_res )). GT .( 0.5d0 * dpparbar )) upperlimit = upperlimit + 1 endif ! Cover special circumstances: if (( lowerlimit . LT . ipparbar_lower ). AND .( upperlimit . GT . ipparbar_upper )) then call alps_error ( 8 ) elseif ( lowerlimit . LE . ipparbar_lower ) then ! resonance outside or near the left end of the subluminal cone int_start = 1 lowerlimit = 0 upperlimit = ipparbar_lower elseif ( upperlimit . GE . ipparbar_upper ) then ! resonance outside or near the right end of the subluminal cone lowerlimit = ipparbar_upper upperlimit = npparbar int_end = npparbar - 1 endif else ! no resonance (only integrate from int_start to lowerlimit) int_start = ipparbar_lower lowerlimit = ipparbar_upper int_end = npparbar - 1 upperlimit = npparbar endif ! Direct integration: if ( int_start . LE . lowerlimit ) then ipparbar = int_start integrate_resU_rel = integrate_resU_rel + resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) endif do ipparbar = int_start + 1 , lowerlimit - 1 integrate_resU_rel = integrate_resU_rel + 2.d0 * resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) enddo if ( int_start . LT . lowerlimit ) then ipparbar = lowerlimit integrate_resU_rel = integrate_resU_rel + resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) endif if ( upperlimit . LE . int_end ) then ipparbar = upperlimit integrate_resU_rel = integrate_resU_rel + resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) endif do ipparbar = upperlimit + 1 , int_end - 1 integrate_resU_rel = integrate_resU_rel + 2.d0 * resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) enddo if ( upperlimit . LT . int_end ) then ipparbar = int_end integrate_resU_rel = integrate_resU_rel + resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) & * int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) endif integrate_resU_rel = integrate_resU_rel * dpparbar ! If needed, add resonance integration: if ( found_res . AND .( lowerlimit . GE . int_start ). AND .( upperlimit . LE . int_end )) & integrate_resU_rel = integrate_resU_rel + principal_integral_rel ( sproc_rel , om , nn , mode , igamma , ipparbar_res , upperlimit ) return end function integrate_resU_rel double complex function principal_integral_rel ( sproc_rel , om , nn , mode , igamma , ipparbar_res , upperlimit ) !! This function performs the integration near resonances as described in Section 3.1 of the code paper for a relativistic calculation. It is only called if resonances are present in or near the integration domain. use alps_var , only : positions_principal , n_resonance_interval , sproc use alps_var , only : gamma_rel , pparbar_rel , vA , kpar , qs , ms , Tlim , pi implicit none integer , intent ( in ) :: sproc_rel !! is_rel of the current process. double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: mode !! Index of the entries in the T-tensor of Eq. (2.10). integer , intent ( in ) :: igamma !! Index to loop over \\Gamma. integer , intent ( in ) :: ipparbar_res !! Index of the nearest relativistic parallel momentum to the resonance. integer , intent ( in ) :: upperlimit !! Index of upper limit for integration according to Eq. (3.5). double complex :: ii !! Imaginary unit. double complex :: pparbar_res !! Relativistic parallel momentum of the resonance. double complex :: gprimetr !! Function g&#94;{\\prime} in Eq. (3.6). double precision :: denomR !! Real part of denominator of Eq. (3.6). double precision :: denomI !! Imaginary part of denominator of Eq. (3.6). double precision :: capDelta !! Size of interval \\Delta for integration according to Eq. (3.5). double precision :: smdelta !! Size of sub-interval \\delta for integration according to Eq. (3.5). double precision :: correction !! Correction factor for finite size of interval \\delta. double precision :: pparbar !! Relativistic parallel momentum. double precision :: dpparbar !! Infinitesimal step in relativistic parallel momentum. integer :: ipparbar !! Index to loop over relativistic parallel momentum. integer :: ntiny !! Small steps for integration near pole according to Eq. (3.5). ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) principal_integral_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ! Now comes the resonance part: ! We call the function that needs to be integrated WITHOUT the resonance part funct_g. ! We linearize this function. Now we can calculate the even part of the integration. ! We set Delta so that it starts at ipparbar_res-positions_principal. In that way, there is only ! a tiny rest left on the right side that needs to be integrated. ! split the range between the resonance and the upper limit into n_resonance_interval steps: denomR = real ( gamma_rel ( sproc_rel , igamma , ipparbar_res ) * om * vA / kpar - ( 1.d0 * nn ) * ( qs ( sproc ) / ms ( sproc )) * vA / kpar ) denomI = aimag ( gamma_rel ( sproc_rel , igamma , ipparbar_res ) * om * vA / kpar ) pparbar_res = denomR + denomI * ii capDelta = real ( pparbar_res ) - pparbar_rel ( sproc_rel , 1 , ipparbar_res - positions_principal ) smdelta = capDelta / ( 1.d0 * n_resonance_interval ) if ( abs ( denomI ). GT . Tlim ) then ! regular integration: ! Integrate the boundaries: pparbar = real ( pparbar_res ) principal_integral_rel = principal_integral_rel + 1.d0 * & funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI ) principal_integral_rel = principal_integral_rel - 1.d0 * & funct_g_rel ( sproc_rel , 2.d0 * denomR - pparbar , igamma , om , nn , mode ) / ( pparbar - denomR + ii * denomI ) pparbar = real ( pparbar_res ) + capDelta principal_integral_rel = principal_integral_rel + 1.d0 * & funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI ) principal_integral_rel = principal_integral_rel - 1.d0 * & funct_g_rel ( sproc_rel , 2.d0 * denomR - pparbar , igamma , om , nn , mode ) / ( pparbar - denomR + ii * denomI ) do ipparbar = 1 , n_resonance_interval - 1 pparbar = real ( pparbar_res ) + smdelta * ipparbar principal_integral_rel = principal_integral_rel + 2.d0 * & funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI ) principal_integral_rel = principal_integral_rel - 2.d0 * & funct_g_rel ( sproc_rel , 2.d0 * denomR - pparbar , igamma , om , nn , mode ) / ( pparbar - denomR + ii * denomI ) enddo else ! analytical approximation according to Eq. (3.7): gprimetr = ( funct_g_rel ( sproc_rel , denomR + dpparbar , igamma , om , nn , mode )& - funct_g_rel ( sproc_rel , denomR - dpparbar , igamma , om , nn , mode )) / ( 2.d0 * dpparbar ) ! Integrate the edges: pparbar = real ( pparbar_res ) pparbar = real ( pparbar_res ) + capDelta principal_integral_rel = principal_integral_rel & + 2.d0 * gprimetr * ( pparbar - denomR ) ** 2 / (( pparbar - denomR ) ** 2 + denomI ** 2 ) do ipparbar = 1 , n_resonance_interval - 1 pparbar = real ( pparbar_res ) + smdelta * ipparbar principal_integral_rel = principal_integral_rel & + 2.d0 * 2.d0 * gprimetr * ( pparbar - denomR ) ** 2 / (( pparbar - denomR ) ** 2 + denomI ** 2 ) enddo ! The following lines account for Eq. (3.7) in the paper: ! the factor 2 is for normalization reasons in the trapezoidal rule: if ( denomI . GT . 0.d0 ) then principal_integral_rel = principal_integral_rel & + 2.d0 * ii * pi * funct_g_rel ( sproc_rel , denomR , igamma , om , nn , mode ) / smdelta else if ( denomI . LT . 0.d0 ) then principal_integral_rel = principal_integral_rel & - 2.d0 * ii * pi * funct_g_rel ( sproc_rel , denomR , igamma , om , nn , mode ) / smdelta else if ( denomI . EQ . 0.d0 ) then principal_integral_rel = principal_integral_rel + 0.d0 endif endif ! There is a tiny rest left between the point real(pparbar_res)+capDelta and the position ! pparbar_rel(sproc_rel,iperp,upperlimit). We split this interval into steps of roughly size smdelta: ntiny = int (( pparbar_rel ( sproc_rel , igamma , upperlimit ) - real ( pparbar_res ) - capDelta ) / smdelta ) if ( ntiny . GT . 0 ) then ! Correct for the fact that smdelta is not exactly the step width in the tiny-rest integration: correction = (( pparbar_rel ( sproc_rel , igamma , upperlimit ) - real ( pparbar_res ) - capDelta ) / ( 1.d0 * ntiny )) / smdelta pparbar = real ( pparbar_res ) + capDelta principal_integral_rel = principal_integral_rel + 1.d0 * & correction * ( funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI )) pparbar = real ( pparbar_res ) + capDelta + correction * smdelta * ntiny principal_integral_rel = principal_integral_rel + 1.d0 * & correction * ( funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI )) do ipparbar = 1 , ntiny - 1 pparbar = real ( pparbar_res ) + capDelta + correction * smdelta * ipparbar principal_integral_rel = principal_integral_rel + 2.d0 * & correction * ( funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) / ( pparbar - denomR - ii * denomI )) enddo endif principal_integral_rel = principal_integral_rel * smdelta return end function double complex function funct_g_rel ( sproc_rel , pparbar , igamma , om , nn , mode ) !! This function returns the function g from Eq. (3.2) of the code paper for a relativistic calculation. use alps_var , only : ms , qs , kpar , df0_rel , sproc , vA , npparbar , pparbar_rel , pi , f0_rel implicit none integer , intent ( in ) :: sproc_rel !! is_rel of the current process. double precision , intent ( in ) :: pparbar !! Relativistic parallel momentum. integer , intent ( in ) :: igamma !! Index of \\Gamma. double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: mode !! Index of the entries in the T-tensor of Eq. (2.10). integer :: ipparbar_close !! Index of the relativistic parallel momentum closest to the resonance. integer :: ipparbar !! Index to loop over relativistic parallel momentum. double precision :: dpparbar !! Infinitesimal step in relativistic parallel momentum. double complex :: integrandplus !! Integrand function ahead of position. double complex :: integrandminus !! Integrand function behind of position. double complex :: integrand !! Integrand function at position. dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ipparbar_close =- 2 ! determine the closest ipar (on the left) to this p_res_real: do ipparbar = 0 , npparbar - 1 if (( pparbar_rel ( sproc_rel , igamma , ipparbar + 1 ). GT . pparbar ). AND .( pparbar_rel ( sproc_rel , igamma , ipparbar ). LE . pparbar )) then ipparbar_close = ipparbar endif enddo if ( f0_rel ( sproc_rel , igamma , ipparbar_close + 1 ). LE . - 1.d0 ) ipparbar_close = ipparbar_close - 1 if ( f0_rel ( sproc_rel , igamma , ipparbar_close - 1 ). LE . - 1.d0 ) ipparbar_close = ipparbar_close + 1 if ( pparbar . EQ . pparbar_rel ( sproc_rel , igamma , npparbar )) ipparbar_close = npparbar - 2 if ( ipparbar_close . GE .( npparbar - 1 )) ipparbar_close = npparbar - 2 if ( ipparbar_close . LE . 1 ) ipparbar_close = 2 ! calculate the function on the grid (left and right of pparbar): integrandplus = - 2.d0 * pi * ( ms ( sproc ) / vA ) ** 3 * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * & ( om * df0_rel ( sproc_rel , igamma , ipparbar_close + 1 , 1 ) + & ( kpar / ( vA )) * df0_rel ( sproc_rel , igamma , ipparbar_close + 1 , 2 ))& * int_T_rel ( sproc_rel , nn , igamma , ipparbar_close + 1 , mode ) integrand = - 2.d0 * pi * ( ms ( sproc ) / vA ) ** 3 * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * & ( om * df0_rel ( sproc_rel , igamma , ipparbar_close , 1 ) + & ( kpar / ( vA )) * df0_rel ( sproc_rel , igamma , ipparbar_close , 2 ))& * int_T_rel ( sproc_rel , nn , igamma , ipparbar_close , mode ) integrandminus = - 2.d0 * pi * ( ms ( sproc ) / vA ) ** 3 * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * & ( om * df0_rel ( sproc_rel , igamma , ipparbar_close - 1 , 1 ) + & ( kpar / ( vA )) * df0_rel ( sproc_rel , igamma , ipparbar_close - 1 , 2 ))& * int_T_rel ( sproc_rel , nn , igamma , ipparbar_close - 1 , mode ) funct_g_rel = integrand + & 0.5d0 * (( integrandplus - integrandminus ) / dpparbar ) * ( pparbar - pparbar_rel ( sproc_rel , igamma , ipparbar_close )) return end function funct_g_rel double complex function landau_integrate_rel ( om , nn , mode ) !! This function evaluates the Landau contour according to Eqs. (3.8) and (3.9) of the code paper for a relativistic calculation. use alps_var , only : ngamma , gamma_rel , pparbar_rel , pi , ms , qs , kpar , sproc , vA use alps_analyt , only : eval_fit implicit none double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: mode !! Index of the entries in the T-tensor of Eq. (2.10). integer :: igamma !! Index to loop over \\Gamma. integer :: sproc_rel !! is_rel of the current process. double precision :: dgamma_rel !! Infinitesimal step in \\Gamma. double precision :: dpparbar !! Infinitesimal step in relativistic parallel momentum. double precision :: h !! Scaling factor. double complex :: ii !! Imaginary unit. double complex :: dfgamma_C !! Derivative of f0 evaluated at resonance. double complex :: dfpparbar_C !! Derivative of f0 evaluated at resonance. double complex :: pparbar_res !! Relativistic parallel resonance momentum. ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) landau_integrate_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) call determine_sproc_rel ( sproc_rel ) dgamma_rel = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) ! Landau contour integral: do igamma = 1 , ngamma - 1 pparbar_res = gamma_rel ( sproc_rel , igamma , 1 ) * om * vA / kpar - ( 1.d0 * nn ) * qs ( sproc ) * vA / ( kpar * ms ( sproc )) if (( real ( pparbar_res ) ** 2 ). LE .( gamma_rel ( sproc_rel , igamma , 1 ) ** 2 - 1.d0 )) then h = 1.d0 ! At igamma=1, we are already missing the part from igamma=0, where we should actually start. ! Therefore, we use 4 instead of 2 in the trapezoid integration: if ( igamma . EQ .( ngamma - 1 )) h = 0.5d0 if ( igamma . EQ . 1 ) then dfgamma_C = ( eval_fit ( sproc , igamma + 1 , pparbar_res ) - eval_fit ( sproc , igamma , pparbar_res )) / dgamma_rel else dfgamma_C = ( eval_fit ( sproc , igamma + 1 , pparbar_res ) - eval_fit ( sproc , igamma - 1 , pparbar_res )) / ( 2.d0 * dgamma_rel ) endif dfpparbar_C = ( eval_fit ( sproc , igamma , pparbar_res + dpparbar ) - eval_fit ( sproc , igamma , pparbar_res - dpparbar )) / ( 2.d0 * dpparbar ) landau_integrate_rel = landau_integrate_rel - h * ( & om * dfgamma_C + ( kpar / ( vA )) * dfpparbar_C ) * int_T_res_rel ( sproc_rel , nn , igamma , pparbar_res , mode ) endif enddo landau_integrate_rel = landau_integrate_rel * ii * dgamma_rel * pi * 2.d0 * pi & * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * ( ms ( sproc ) / vA ) ** 3 return end function landau_integrate_rel double complex function int_ee_rel ( om ) !! This function returns the ee term in Eq. (2.9) for the relativistic calculation. use alps_var , only : qs , ms , pi , f0_rel , df0_rel , vA , sproc , gamma_rel , pparbar_rel use alps_var , only : ngamma , npparbar implicit none double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer :: igamma !! Index to loop over \\Gamma. integer :: ipparbar !! Index to loop over relativistic parallel momentum. integer :: sproc_rel !! is_rel of the current process. integer :: ipparbar_lower !! Lower boundary of resonance range in relativistic parallel momentum. integer :: ipparbar_upper !! Upper boundary of resonance range in relativistic parallel momentum. double precision :: dgamma_rel !! Infinitesimal step in \\Gamma. double precision :: dpparbar !! Infinitesimal step in relativistic parallel momentum. logical :: found_lower !! Check whether resonance lies in lower range of relativistic parallel momentum. logical :: found_upper !! Check whether resonance lies in upper range of relativistic parallel momentum. call determine_sproc_rel ( sproc_rel ) dgamma_rel = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) int_ee_rel = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) ! Determine the relevant ranges in pparbar: igamma = ngamma - 1 found_lower = . FALSE . found_upper = . FALSE . ipparbar_lower = 1 ipparbar_upper = npparbar - 1 do ipparbar = 1 , npparbar - 1 if ((. NOT . found_lower ). AND .( f0_rel ( sproc_rel , igamma , ipparbar - 1 ). LE . - 1.d0 ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 )) then ipparbar_lower = ipparbar found_lower = . TRUE . endif if ((. NOT . found_upper ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 ). AND .( f0_rel ( sproc_rel , igamma , ipparbar + 1 ). LE . - 1.d0 )) then ipparbar_upper = ipparbar found_upper = . TRUE . endif enddo int_ee_rel = int_ee_rel + & pparbar_rel ( sproc_rel , igamma , ipparbar_lower ) * df0_rel ( sproc_rel , igamma , ipparbar_lower , 2 ) int_ee_rel = int_ee_rel + & pparbar_rel ( sproc_rel , igamma , ipparbar_upper ) * df0_rel ( sproc_rel , igamma , ipparbar_upper , 2 ) do ipparbar = ipparbar_lower + 1 , ipparbar_upper - 1 int_ee_rel = int_ee_rel + & 2.d0 * pparbar_rel ( sproc_rel , igamma , ipparbar ) * df0_rel ( sproc_rel , igamma , ipparbar , 2 ) enddo ! At igamma=1, we are already missing the part from igamma=0, where we should actually start. ! Therefore, we use 4 instead of 2 in the trapezoid integration: do igamma = 1 , ngamma - 2 found_lower = . FALSE . found_upper = . FALSE . ipparbar_lower = 1 ipparbar_upper = npparbar - 1 do ipparbar = 1 , npparbar - 1 if ((. NOT . found_lower ). AND .( f0_rel ( sproc_rel , igamma , ipparbar - 1 ). LE . - 1.d0 ). AND .& ( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 )) then ipparbar_lower = ipparbar found_lower = . TRUE . endif if ((. NOT . found_upper ). AND .( f0_rel ( sproc_rel , igamma , ipparbar ). GT . - 1.d0 ). AND .& ( f0_rel ( sproc_rel , igamma , ipparbar + 1 ). LE . - 1.d0 )) then ipparbar_upper = ipparbar found_upper = . TRUE . endif enddo do ipparbar = ipparbar_lower + 1 , ipparbar_upper - 1 int_ee_rel = int_ee_rel + & 4.d0 * pparbar_rel ( sproc_rel , igamma , ipparbar ) * df0_rel ( sproc_rel , igamma , ipparbar , 2 ) enddo int_ee_rel = int_ee_rel + & 2.d0 * pparbar_rel ( sproc_rel , igamma , ipparbar_lower ) * df0_rel ( sproc_rel , igamma , ipparbar_lower , 2 ) int_ee_rel = int_ee_rel + & 2.d0 * pparbar_rel ( sproc_rel , igamma , ipparbar_upper ) * df0_rel ( sproc_rel , igamma , ipparbar_upper , 2 ) enddo int_ee_rel = int_ee_rel * 2.d0 * pi * qs ( sproc ) / ( ms ( sproc )) int_ee_rel = int_ee_rel * dgamma_rel * dpparbar * 0.25d0 * ( ms ( sproc ) / vA ) ** 3 return end function int_ee_rel double complex function resU_rel ( sproc_rel , om , nn , igamma , ipparbar ) !! This function evaluates the term proportional to U in Eq. (2.9) of the code paper for the relativistic calculation. use ALPS_var , only : kpar , ms , qs , df0_rel , vA , sproc , gamma_rel use ALPS_var , only : pi , pparbar_rel implicit none integer , intent ( in ) :: sproc_rel !! is_rel of the current process. double complex , intent ( in ) :: om !! Complex wave frequency \\omega. integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: igamma !! Index to loop over \\Gamma. integer , intent ( in ) :: ipparbar !! Index to loop over relativistic parallel momentum. resU_rel = - 2.d0 * pi * ( ms ( sproc ) / vA ) ** 3 * ( qs ( sproc ) * vA / ( kpar * ms ( sproc ))) * & ( om * df0_rel ( sproc_rel , igamma , ipparbar , 1 ) + ( kpar / ( vA )) * df0_rel ( sproc_rel , igamma , ipparbar , 2 )) / & ( pparbar_rel ( sproc_rel , igamma , ipparbar ) - gamma_rel ( sproc_rel , igamma , ipparbar ) * om * vA / kpar & + ( 1.d0 * nn ) * qs ( sproc ) * vA / ( kpar * ms ( sproc ))) return end function resU_rel !-=-=-=-=-=-= !Functions for Tij- !-=-=-=-=-=-= !Function to pass T_ij into integrator double complex function int_T_rel ( sproc_rel , nn , igamma , ipparbar , mode ) !! This function returns the T-tensor according to Eq. (2.10) of the code paper for the relativistic calculation. use ALPS_var , only : kperp , qs , sproc , pparbar_rel , gamma_rel , vA , ms use ALPS_var , only : kperp_norm implicit none integer , intent ( in ) :: sproc_rel !! is_rel of the current process. integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: igamma !! Index to loop over \\Gamma. integer , intent ( in ) :: ipparbar !! Index to loop over relativistic parallel momentum. integer , intent ( in ) :: mode !! Index of the entries in the T-tensor of Eq. (2.10). double precision :: z !! Argument of the Bessel functions. double precision :: zbar !! Argument of the Bessel function, renormalised  by multiplying with 1./(pperpbar*kperp). double precision :: pperpbar !! Relativistic parallel momentum. double precision :: bessel !! Bessel function. double precision :: besselP !! First derivative of the Bessel function. double complex :: ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) !! Imaginary unit. ! Bessel function argument: pperpbar = sqrt ( gamma_rel ( sproc_rel , igamma , ipparbar ) ** 2 - 1.d0 - pparbar_rel ( sproc_rel , igamma , ipparbar ) ** 2 ) z = ( kperp * ms ( sproc ) / ( vA * qs ( sproc ))) * pperpbar if ( kperp_norm ) then zbar = kperp * ms ( sproc ) / ( vA * qs ( sproc )) else zbar = ms ( sproc ) / ( vA * qs ( sproc )) endif ! Look up array of Bessel functions: if ( nn . LT . 0 ) then bessel = (( - 1.d0 ) ** nn ) * BESSJ ( - nn , z ) else bessel = BESSJ ( nn , z ) endif ! Determine derivative of Bessel function: if ( nn . GE . 1 ) then besselP = 0.5d0 * ( BESSJ ( nn - 1 , z ) - BESSJ ( nn + 1 , z )) else if ( nn . LT . - 1 ) then besselP = 0.5d0 * (((( - 1.d0 ) ** ( nn - 1 )) * BESSJ ( - ( nn - 1 ), z ))& - ((( - 1.d0 ) ** ( nn + 1 )) * BESSJ ( - ( nn + 1 ), z ))) else if ( nn . EQ . 0 ) then besselP = - BESSJ ( 1 , z ) else if ( nn . EQ . - 1 ) then besselP = 0.5d0 * ( BESSJ ( 2 , z ) - BESSJ ( 0 , z )) endif select case ( mode ) case ( 1 ) !T xx int_T_rel = 1.d0 * ( nn * nn ) * bessel * bessel / ( zbar * zbar ) case ( 2 ) !T yy if ( kperp_norm ) then int_T_rel = besselP * besselP * pperpbar * pperpbar else int_T_rel = kperp * kperp * besselP * besselP * pperpbar * pperpbar endif case ( 3 ) !T zz if ( kperp_norm ) then int_T_rel = bessel * bessel * pparbar_rel ( sproc_rel , igamma , ipparbar ) ** 2 else int_T_rel = kperp * kperp * bessel * bessel * pparbar_rel ( sproc_rel , igamma , ipparbar ) ** 2 endif case ( 4 ) !T xy if ( kperp_norm ) then int_T_rel = ii * ( 1.d0 * ( nn )) * bessel * besselP * pperpbar / zbar else int_T_rel = ii * ( 1.d0 * ( nn )) * kperp * bessel * besselP * pperpbar / zbar endif case ( 5 ) !T xz if ( kperp_norm ) then int_T_rel = ( 1.d0 * nn ) * bessel * bessel * pparbar_rel ( sproc_rel , igamma , ipparbar ) / zbar else int_T_rel = ( 1.d0 * nn ) * kperp * bessel * bessel * pparbar_rel ( sproc_rel , igamma , ipparbar ) / zbar endif case ( 6 ) !T yz if ( kperp_norm ) then int_T_rel = ( - 1.d0 * ii ) * bessel * besselP * pparbar_rel ( sproc_rel , igamma , ipparbar ) * pperpbar else int_T_rel = ( - 1.d0 * ii ) * kperp * kperp * bessel * besselP * pparbar_rel ( sproc_rel , igamma , ipparbar ) * pperpbar endif end select return end function int_T_rel double complex function int_T_res_rel ( sproc_rel , nn , igamma , pparbar , mode ) !! This function returns the T-tensor according to Eq. (2.10) of the code paper for the case in which it is evaluated at the complex resonance momentum for the relativistic calculation. use ALPS_var , only : kperp , qs , sproc , gamma_rel , vA , ms use ALPS_var , only : kperp_norm implicit none integer , intent ( in ) :: sproc_rel !! is_rel of the current process. integer , intent ( in ) :: nn !! Order of the Bessel function. integer , intent ( in ) :: igamma !! Index to loop over \\Gamma. double complex , intent ( in ) :: pparbar !! Relativistic parallel momentum. integer , intent ( in ) :: mode !! Index of the entries in the T-tensor of Eq. (2.10). double complex :: z !! Argument of the Bessel function. double precision :: zbar !! Argument of the Bessel function, renormalised  by multiplying with 1./(pperpbar*kperp). double complex :: pperpbar !! Relativistic parallel momentum. double complex :: bessel !! Bessel function. double complex :: besselP !! First derivative of the Bessel function. double complex :: besselH !! Storage variable for Bessel function. double complex :: ii = cmplx ( 0.d0 , 1.d0 , kind ( 1.d0 )) !! Imaginary unit. ! Bessel function argument: pperpbar = sqrt ( gamma_rel ( sproc_rel , igamma , 1 ) ** 2 - 1.d0 - pparbar ** 2 ) z = ( kperp * ms ( sproc ) / ( vA * qs ( sproc ))) * pperpbar if ( kperp_norm ) then zbar = kperp * ms ( sproc ) / ( vA * qs ( sproc )) else zbar = ms ( sproc ) / ( vA * qs ( sproc )) endif ! Look up array of Bessel functions: if ( nn . LT . 0 ) then call CBESSJ ( z , - nn , bessel ) bessel = bessel * ( - 1.d0 ) ** nn else call CBESSJ ( z , nn , bessel ) endif ! Determine derivative of Bessel function: if ( nn . GE . 1 ) then call CBESSJ ( z , nn - 1 , besselP ) call CBESSJ ( z , nn + 1 , besselH ) besselP = 0.5d0 * ( besselP - besselH ) elseif ( nn . LT . - 1 ) then call CBESSJ ( z , - ( nn - 1 ), besselP ) call CBESSJ ( z , - ( nn + 1 ), besselH ) besselP = 0.5d0 * (((( - 1.d0 ) ** ( nn - 1 )) * besselP )& - ((( - 1.d0 ) ** ( nn + 1 )) * besselH )) elseif ( nn . EQ . 0 ) then call CBESSJ ( z , 1 , besselP ) besselP = - besselP elseif ( nn . EQ . - 1 ) then call CBESSJ ( z , 2 , besselP ) call CBESSJ ( z , 0 , besselH ) besselP = 0.5d0 * ( besselP - besselH ) endif select case ( mode ) case ( 1 ) !T xx int_T_res_rel = 1.d0 * ( nn * nn ) * bessel * bessel / ( zbar * zbar ) case ( 2 ) !T yy if ( kperp_norm ) then int_T_res_rel = besselP * besselP * pperpbar * pperpbar else int_T_res_rel = kperp * kperp * besselP * besselP * pperpbar * pperpbar endif case ( 3 ) !T zz if ( kperp_norm ) then int_T_res_rel = bessel * bessel * pparbar ** 2 else int_T_res_rel = kperp * kperp * bessel * bessel * pparbar ** 2 endif case ( 4 ) !T xy if ( kperp_norm ) then int_T_res_rel = ii * ( 1.d0 * ( nn )) * bessel * besselP * pperpbar / zbar else int_T_res_rel = ii * ( 1.d0 * ( nn )) * kperp * bessel * besselP * pperpbar / zbar endif case ( 5 ) !T xz if ( kperp_norm ) then int_T_res_rel = ( 1.d0 * nn ) * bessel * bessel * pparbar / zbar else int_T_res_rel = ( 1.d0 * nn ) * kperp * bessel * bessel * pparbar / zbar endif case ( 6 ) !T yz if ( kperp_norm ) then int_T_res_rel = ( - 1.d0 * ii ) * bessel * besselP * pparbar * pperpbar else int_T_res_rel = ( - 1.d0 * ii ) * kperp * kperp * bessel * besselP * pparbar * pperpbar endif end select return end function int_T_res_rel subroutine CBESSJ ( z , nu , z1 ) !! This subroutine calculates the complex Bessel function. It is based on the CBESSJ function release 1.1 by J-P Moreau, Paris (www.jpmoreau.fr). !--------------------------------------------------- !                       inf.     (-z&#94;2/4)&#94;k !   Jnu(z) = (z/2)&#94;nu x Sum  ------------------ !                       k=0  k! x Gamma(nu+k+1) !  (nu must be >= 0). !--------------------------------------------------- implicit none double complex , intent ( in ) :: z !! Argument of the Bessel function. integer , intent ( in ) :: nu !! Order of Bessel function. double complex , intent ( out ) :: z1 !! Resulting value of Bessel function. integer :: k !! Index to loop over sum. integer :: MAXK !! Maximum value of k. double complex :: sum !! Storage variable for sum in Bessel-function calculation. double complex :: tmp !! Storage variable for divising in routine. double precision :: ZERO !! Defines zero parameter. parameter ( MAXK = 20 , ZERO = 0.d0 ) sum = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) do k = 0 , MAXK !calculate (-z**2/4)**k tmp = ( - z * z / 4.d0 ) ** k ! divide by k!: tmp = tmp / Fact ( k ) ! divide by Gamma(nu+k+1) tmp = tmp / Gamma ( 1.d0 * ( nu + k + 1 )) ! actualize sum: sum = sum + tmp end do ! calculate (z/2)**nu: tmp = ( z / 2.d0 ) ** nu ! multiply (z/2)**nu by sum z1 = tmp * sum return end subroutine double precision function Fact ( K ) !! This function returns the factorial k! of its argument k. implicit none integer , intent ( in ) :: k !! Argument of the factorial. integer :: i !! Index to loop over in factorial calculation. double precision :: f !! Resulting factorial. f = 1.d0 do i = 2 , k f = f * ( 1.d0 * i ) end do Fact = f return end function DOUBLE PRECISION FUNCTION BESSJ ( N , X ) !! This function calculates the first kind Bessel function !! of integer order N, for any REAL X. We use here the classical !! recursion formula, when X > N. For X < N, Miller's algorithm !! is used to avoid overflows. Reference: !! C.W.Clenshaw, Chebyshev Series for Mathematical Functions, Mathematical Tables, Vol. 5, 1962. IMPLICIT NONE integer , intent ( in ) :: N !! Order of Bessel function. double precision , intent ( in ) :: X !! Argument of the Bessel function. INTEGER , PARAMETER :: IACC = 40 REAL * 8 , PARAMETER :: BIGNO = 1.D10 , BIGNI = 1.D-10 INTEGER M , J , JSUM REAL * 8 TOX , BJM , BJ , BJP , SUM IF ( N . EQ . 0 ) THEN BESSJ = BESSJ0 ( X ) RETURN ENDIF IF ( N . EQ . 1 ) THEN BESSJ = BESSJ1 ( X ) RETURN ENDIF IF ( X . EQ . 0. ) THEN BESSJ = 0. RETURN ENDIF TOX = 2. / X IF ( X . GT . FLOAT ( N )) THEN BJM = BESSJ0 ( X ) BJ = BESSJ1 ( X ) DO 11 J = 1 , N - 1 BJP = J * TOX * BJ - BJM BJM = BJ BJ = BJP 11 CONTINUE BESSJ = BJ ELSE M = 2 * (( N + INT ( SQRT ( FLOAT ( IACC * N )))) / 2 ) BESSJ = 0. JSUM = 0 SUM = 0. BJP = 0. BJ = 1. DO 12 J = M , 1 , - 1 BJM = J * TOX * BJ - BJP BJP = BJ BJ = BJM IF ( ABS ( BJ ). GT . BIGNO ) THEN BJ = BJ * BIGNI BJP = BJP * BIGNI BESSJ = BESSJ * BIGNI SUM = SUM * BIGNI ENDIF IF ( JSUM . NE . 0 ) SUM = SUM + BJ JSUM = 1 - JSUM IF ( J . EQ . N ) BESSJ = BJP 12 CONTINUE SUM = 2. * SUM - BJ BESSJ = BESSJ / SUM ENDIF RETURN END FUNCTION DOUBLE PRECISION FUNCTION BESSJ0 ( X ) !! This function calculates the first kind Bessel function !! of order 0, for any REAL X. The polynomial approximation by !! series of Chebyshev polynomials is used for 0<X<8 and 0<8/X<1. References: !! M.Abramowitz, I.A.Stegun, Handbook of Mathematical Functions, 1965. C.W.Clenshaw, Chebyshev Series for Mathematical Functions, Mathematical Tables, Vol. 5, 1962. IMPLICIT NONE double precision , intent ( in ) :: X !! Argument of the Bessel function. REAL * 8 AX , FR , FS , Z , FP , FQ , XX REAL * 8 Y , P1 , P2 , P3 , P4 , P5 , R1 , R2 , R3 , R4 , R5 , R6 & , Q1 , Q2 , Q3 , Q4 , Q5 , S1 , S2 , S3 , S4 , S5 , S6 DATA P1 , P2 , P3 , P4 , P5 / 1.D0 , - . 1098628627 D - 2 ,. 2734510407 D - 4 , & - . 2073370639 D - 5 ,. 2093887211 D - 6 / DATA Q1 , Q2 , Q3 , Q4 , Q5 /- . 1562499995 D - 1 ,. 1430488765 D - 3 , & - . 6911147651 D - 5 ,. 7621095161 D - 6 , - . 9349451520 D - 7 / DATA R1 , R2 , R3 , R4 , R5 , R6 / 5756849057 4.D0 , - 1336259035 4.D0 , & 65161964 0.7D0 , - 1121442 4.18D0 , 7739 2.33017D0 , - 18 4.9052456D0 / DATA S1 , S2 , S3 , S4 , S5 , S6 / 5756849041 1.D0 , 102953298 5.D0 , & 949468 0.718D0 , 5927 2.64853D0 , 26 7.8532712D0 , 1.D0 / IF ( X . EQ . 0.D0 ) GO TO 1 AX = ABS ( X ) IF ( AX . LT . 8.D0 ) THEN Y = X * X FR = R1 + Y * ( R2 + Y * ( R3 + Y * ( R4 + Y * ( R5 + Y * R6 )))) FS = S1 + Y * ( S2 + Y * ( S3 + Y * ( S4 + Y * ( S5 + Y * S6 )))) BESSJ0 = FR / FS ELSE Z = 8.D0 / AX Y = Z * Z XX = AX - . 785398164 D0 FP = P1 + Y * ( P2 + Y * ( P3 + Y * ( P4 + Y * P5 ))) FQ = Q1 + Y * ( Q2 + Y * ( Q3 + Y * ( Q4 + Y * Q5 ))) BESSJ0 = SQRT (. 636619772 D0 / AX ) * ( FP * COS ( XX ) - Z * FQ * SIN ( XX )) ENDIF RETURN 1 BESSJ0 = 1.D0 RETURN END FUNCTION BESSJ0 double precision FUNCTION BESSJ1 ( X ) !! This subroutine calculates the First Kind Bessel Function of !! order 1, for any real number X. The polynomial approximation by !! series of Chebyshev polynomials is used for 0<X<8 and 0<8/X<1. References: !! M.Abramowitz, I.A.Stegun, Handbook of Mathematical Functions, 1965. C.W.Clenshaw, Chebyshev Series for Mathematical Functions, Mathematical Tables, Vol. 5, 1962. IMPLICIT NONE double precision , intent ( in ) :: X !! Argument of the Bessel function. REAL * 8 AX , FR , FS , Z , FP , FQ , XX REAL * 8 Y , P1 , P2 , P3 , P4 , P5 , P6 , R1 , R2 , R3 , R4 , R5 , R6 & , Q1 , Q2 , Q3 , Q4 , Q5 , S1 , S2 , S3 , S4 , S5 , S6 DATA P1 , P2 , P3 , P4 , P5 / 1.D0 ,. 183105 D - 2 , - . 3516396496 D - 4 , & . 2457520174 D - 5 , - . 240337019 D - 6 / , P6 / . 636619772 D0 / DATA Q1 , Q2 , Q3 , Q4 , Q5 / . 04687499995 D0 , - . 2002690873 D - 3 , & . 8449199096 D - 5 , - . 88228987 D - 6 ,. 105787412 D - 6 / DATA R1 , R2 , R3 , R4 , R5 , R6 / 7236261423 2.D0 , - 789505923 5.D0 , & 24239685 3.1D0 , - 297261 1.439D0 , 1570 4.48260D0 , - 3 0.16036606D0 / DATA S1 , S2 , S3 , S4 , S5 , S6 / 14472522844 2.D0 , 230053517 8.D0 , & 1858330 4.74D0 , 9944 7.43394D0 , 37 6.9991397D0 , 1.D0 / AX = ABS ( X ) IF ( AX . LT . 8. ) THEN Y = X * X FR = R1 + Y * ( R2 + Y * ( R3 + Y * ( R4 + Y * ( R5 + Y * R6 )))) FS = S1 + Y * ( S2 + Y * ( S3 + Y * ( S4 + Y * ( S5 + Y * S6 )))) BESSJ1 = X * ( FR / FS ) ELSE Z = 8. / AX Y = Z * Z XX = AX - 2.35619491 FP = P1 + Y * ( P2 + Y * ( P3 + Y * ( P4 + Y * P5 ))) FQ = Q1 + Y * ( Q2 + Y * ( Q3 + Y * ( Q4 + Y * Q5 ))) BESSJ1 = SQRT ( P6 / AX ) * ( COS ( XX ) * FP - Z * SIN ( XX ) * FQ ) * SIGN ( S6 , X ) ENDIF RETURN END FUNCTION BESSJ1 double precision Function Gamma ( xx ) !! This function returns the Gamma-function. implicit none double precision :: xx !! Argument of the Gamma-function. double precision :: ONE !! Define variable for 1.0. double precision :: FPF !! Define variable for 5.5. double precision :: HALF !! Define variable for 0.5. double precision :: cof ( 6 ) !! Coefficients for approximation. double precision :: stp !! Parameter for approximation. double precision :: x !! Storage variable for approximation. double precision :: tmp !! Storage variable for approximation. double precision :: ser !! Variable for summation in approximation. integer :: j !! Index to loop over. parameter ( ONE = 1.d0 , FPF = 5.5d0 , HALF = 0.5d0 ) cof ( 1 ) = 7 6.18009173d0 cof ( 2 ) =- 8 6.50532033d0 cof ( 3 ) = 2 4.01409822d0 cof ( 4 ) =- 1.231739516d0 cof ( 5 ) = 0.120858003d-2 cof ( 6 ) =- 0.536382d-5 stp = 2.50662827465d0 x = xx - ONE tmp = x + FPF tmp = ( x + HALF ) * LOG ( tmp ) - tmp ser = ONE do j = 1 , 6 x = x + ONE ser = ser + cof ( j ) / x end do Gamma = EXP ( tmp + LOG ( stp * ser )) return end function end module alps_fns_rel","tags":"","url":"sourcefile/alps_fns_rel.f90.html"},{"title":"ALPS_io.f90 – ALPS","text":"Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_io !!Controls input and output functions to and from main program. implicit none integer :: unit !!Index for file I/O. integer , parameter :: stdout_unit = 6 !! Standard unit for I/O. integer , save :: input_unit_no !! Saved input unit for use with multiple read in calls. integer , save :: error_unit_no = stdout_unit !! Error output unit. private :: get_runname , get_indexed_namelist_unit private :: input_unit_exist , input_unit private :: map_read , solution_read , spec_read , scan_read , bM_read private :: poly_read public :: init_param , read_f0 , get_unused_unit , alps_error public :: output_time , display_credits , isnancheck contains subroutine init_param !!Read in system parameters from *.in file. !!Only processor 0 calls this routine: use alps_var , only : runname , foldername , kperp , kpar , nroots , D_prec , D_gap use alps_var , only : kperp_last , kpar_last , kperp_0 , kpar_0 use alps_var , only : use_map , writeOut , wroots , nspec , numroots , kperp_norm use alps_var , only : nperp , npar , arrayName , fit_check , param_fit , fit_type , perp_correction use alps_var , only : ns , qs , ms , vA , Bessel_zero , numiter use alps_var , only : D_threshold , D_tol , positions_principal use alps_var , only : determine_minima , n_resonance_interval , ngamma , npparbar , Tlim use alps_var , only : scan_option , n_scan , scan , relativistic , logfit , usebM use alps_var , only : maxsteps_fit , n_fits , lambda_initial_fit , lambdafac_fit , epsilon_fit use alps_var , only : bMnmaxs , bMBessel_zeros , bMbetas , bMalphas , bMpdrifts use alps_var , only : ACmethod , poly_kind , poly_order , polynomials , poly_fit_coeffs use alps_var , only : poly_log_max , secant_method implicit none integer :: ik !!Solution index for iterating [[(solution_read(subroutine)]]. integer :: is !!Species index for iterating [[spec_read(subroutine)]], !![[read_f0(subroutine)]], [[bM_read(subroutine)]], and !![[fit_read(subroutine)]] integer :: ifit !!Fit index for iterating [[fit_read(subroutine)]]. integer :: ip !!Index for iterating [[scan_read(subroutine)]] and !!internal looping in [[init_param(subroutine)]]. !Namelist read in from input file: nameList / system / & kperp , kpar , nspec , nroots , use_map , writeOut ,& nperp , npar , ngamma , npparbar , vA , arrayName , Bessel_zero , & secant_method , numiter , kperp_norm , D_threshold , & D_prec , D_gap , D_tol , positions_principal , Tlim , & maxsteps_fit , lambda_initial_fit , lambdafac_fit , epsilon_fit , fit_check , & determine_minima , n_resonance_interval , scan_option , n_scan !Get a unassigned unit number for input/output: call get_unused_unit ( input_unit_no ) !Read in system parameters. !runname called earlier in alps_error_init: unit = input_unit_no open ( unit = unit , file = trim ( foldername ) // trim ( runname ) // \".in\" , status = 'old' , action = 'read' ) read ( unit = unit , nml = system ) if ( writeOut ) & write ( * , '(2a)' ) & 'Reading from Input File: ' , trim ( runname ) !save initial kperp,kpar values: kperp_last = kperp ; kpar_last = kpar kperp_0 = kperp ; kpar_0 = kpar !Allocate solution space for nroots dispersion solutions; allocate ( wroots ( 1 : numroots )); wroots = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) !Read in map scan parameters: if ( use_map ) then if ( writeOut ) & write ( * , '(a)' ) 'MAP ROUTINE' ik = 1 !Read in parameters for complex frequency map: unit = input_unit_no call get_indexed_namelist_unit ( unit , \"maps\" , ik ) call map_read close ( unit ) else !OR !read in guesses for solutions: if ( writeOut ) & write ( * , '(a)' ) 'GUESS ROUTINE: ' do ik = 1 , nroots unit = input_unit_no call get_indexed_namelist_unit ( unit , \"guess\" , ik ) call solution_read ( ik ) write ( * , '(a,i3,a,2es14.4e3)' )& 'Intial Guess ' , ik , ' : ' , wroots ( ik ) close ( unit ) enddo endif !Read in species density, charge, and mass from input file: if ( writeOut ) & write ( * , '(a)' ) 'SPECIES PARAMETERS: ' allocate ( ns ( 1 : nspec )); ns = 0.d0 allocate ( qs ( 1 : nspec )); qs = 0.d0 allocate ( ms ( 1 : nspec )); ms = 0.d0 !Fitting Parameters: allocate ( n_fits ( 1 : nspec )); n_fits = 1 allocate ( relativistic ( 1 : nspec )); relativistic = . FALSE . allocate ( logfit ( 1 : nspec )); logfit = . TRUE . !Bi-Maxwellian/Cold-plasma Parameters: allocate ( usebM ( 1 : nspec )); usebM = . TRUE . allocate ( bMnmaxs ( 1 : nspec )); bMnmaxs = 500 allocate ( bMBessel_zeros ( 1 : nspec )); bMBessel_zeros = 1.d-50 allocate ( bMbetas ( 1 : nspec )); bMbetas = 1.d0 allocate ( bMalphas ( 1 : nspec )); bMalphas = 1.d0 allocate ( bMpdrifts ( 1 : nspec )); bMpdrifts = 0.d0 !Basis Function Parameters: allocate ( ACmethod ( 1 : nspec )); ACmethod = 1 allocate ( poly_kind ( 1 : nspec )); poly_kind = 0 allocate ( poly_order ( 1 : nspec )); poly_order = 0 allocate ( poly_log_max ( 1 : nspec )); poly_log_max = 0 !READ IN SPECIES PARAMETERS: do is = 1 , nspec unit = input_unit_no call get_indexed_namelist_unit ( unit , \"spec\" , is ) call spec_read ( is ) write ( * , '(a,i3,a)' ) 'Species ' , is , ' : ' write ( * , '(a,es14.4e3,a,es14.4e3,a,es14.4e3)' )& ' ns/nREF = ' , ns ( is ), ' | qs/qREF = ' , qs ( is ), ' | ms/mREF = ' , ms ( is ) select case ( ACmethod ( is )) case ( 0 ) write ( * , '(a)' ) ' Using function defined in distribution/distribution_analyt.f90' case ( 1 ) write ( * , '(a,i4)' )& ' Number of fitted functions = ' , n_fits ( is ) case ( 2 ) write ( * , '(a)' )& ' Using a Polynomial Basis Representation' end select write ( * , '(a,l1)' )& ' Relativistic effects = ' , relativistic ( is ) close ( unit ) enddo allocate ( param_fit ( 1 : nspec , 0 : max ( nperp , ngamma ), 5 , maxval ( n_fits ))) allocate ( fit_type ( 1 : nspec , maxval ( n_fits ))) allocate ( perp_correction ( 1 : nspec , maxval ( n_fits ))) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' !READ IN SPECIES FIT PARAMETERS do is = 1 , nspec if ( usebM ( is )) then write ( * , '(a,i2,a)' ) 'Species ' , is ,& ' uses bi-Maxwellian/cold-plasma calculation... skipping fits. Parameters:' call get_indexed_namelist_unit ( unit , \"bM_spec\" , is ) call bM_read ( is ) write ( * , '(a,es14.4e3,a,es14.4e3,a,es14.4e3)' )& '  beta = ' , bMbetas ( is ), ', alpha = ' , bMalphas ( is ), ', drift momentum = ' , bMpdrifts ( is ) if ( bMbetas ( is ). EQ . 0.d0 ) then write ( * , '(a)' ) '  Cold-plasma calculation.' else write ( * , '(a,i4,a,es14.4e3)' )& '  nmax = ' , bMnmaxs ( is ), ',        Bessel_zero = ' , bMBessel_zeros ( is ) endif close ( unit ) else !Read in initial guesses for LM fits. select case ( ACmethod ( is )) case ( 1 ) do ifit = 1 , n_fits ( is ) call get_indexed_double_namelist_unit ( unit , \"ffit\" , is , ifit ) call fit_read ( is , ifit ) select case ( fit_type ( is , ifit )) case ( 1 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', Maxwellian fit: ' case ( 2 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', kappa fit: ' case ( 3 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', Juettner fit (pperp and ppar): ' case ( 4 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', Juettner fit (gamma-dependent only): ' case ( 5 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', Juettner fit (gamma and pparbar): ' case ( 6 ) write ( * , '(a,i2,a,i2,a)' )& 'Species ' , is , ', function ' , ifit , ', bi-Moyal fit: ' case default write ( * , '(a)' )& 'Function fit undefined' stop end select do ip = 1 , 5 write ( * , '(a,i2,a,es14.4)' )& ' Initial fit parameter ' , ip , ' = ' , param_fit ( is , 0 , ip , ifit ) enddo write ( * , '(a,es14.4)' )& ' Perpendicular correction:  ' , perp_correction ( is , ifit ) close ( unit ) enddo case ( 2 ) call get_indexed_namelist_unit ( unit , \"poly_spec\" , is ) call poly_read ( is ) select case ( poly_kind ( is )) case ( 1 ) write ( * , '(a,i0,a,i0)' )& 'Chebyshev Representation of Order ' , poly_order ( is ), ' for species ' , is case default call alps_error ( 10 ) end select close ( unit ) end select endif enddo allocate ( polynomials ( 1 : nspec , 0 : npar , 0 : maxval ( poly_order (:)))); polynomials = 0.d0 allocate ( poly_fit_coeffs ( 1 : nspec , 0 : nperp , 0 : maxval ( poly_order (:)))); poly_fit_coeffs = 0.d0 !Read in selection for scan paramter: if ( n_scan . gt . 0 ) then write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' allocate ( scan ( n_scan )) do ip = 1 , n_scan unit = input_unit_no call get_indexed_namelist_unit ( unit , \"scan_input\" , ip ) call scan_read ( ip ) close ( unit ) enddo write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' endif close ( unit ) end subroutine init_param subroutine map_read !!Reads in complex frequency map parameters. use alps_var , only : loggridw , loggridg use alps_var , only : omi , omf , gami , gamf , ni , nr implicit none nameList / maps / & loggridw , loggridg , omi , omf , gami , gamf , ni , nr read ( unit = unit , nml = maps ) end subroutine map_read subroutine solution_read ( ik ) !!Reads in initial guesses for dispersion solutions. use alps_var , only : wroots implicit none integer , intent ( in ) :: ik !!Solution index. double precision :: g_om !!Guess for real solution \\omega_{\\textrm{r}/\\Omega_p . double precision :: g_gam !!Guess for imaginary solution \\gamma/\\Omega_p . nameList / guess / & g_om , g_gam read ( unit = unit , nml = guess ) wroots ( ik ) = cmplx ( g_om , g_gam , kind ( 1.d0 )) end subroutine solution_read subroutine spec_read ( is ) !!Subroutine for reading in species parameters use alps_var , only : ns , qs , ms , n_fits use alps_var , only : relativistic , logfit , usebM use alps_var , only : ACmethod implicit none integer , intent ( in ) :: is !!Species index. double precision :: nn !! Read in value for relative density for f_j. double precision :: qq !! Read in value for charge for f_j. double precision :: mm !! Read in value for mass for f_j. double precision :: AC_method !! Read in value for Analytic Continuation Method integer :: ff !!Read in value for number of fitted functions. logical :: relat = . false . !! Treat species as non-relativistic or relativistic. logical :: log_fit = . true . !! Use linear or \\log_{10} fitting routine. logical :: use_bM = . false . !! Use actual numerical integration or bi-Maxwellian/cold-plasma proxy via NHDS. nameList / spec / & nn , qq , mm , AC_method , ff , relat , log_fit , use_bM read ( unit = unit , nml = spec ) ns ( is ) = nn ; qs ( is ) = qq ; ms ( is ) = mm n_fits ( is ) = ff ; relativistic ( is ) = relat logfit ( is ) = log_fit ; usebM ( is ) = use_bM ACmethod ( is ) = AC_method end subroutine spec_read subroutine poly_read ( is ) !!Reads in Polynomial Basis Function Parameters use alps_var , only : poly_kind , poly_order , poly_log_max implicit none integer , intent ( in ) :: is !!Species index. integer :: kind !! Selection of Orthogonal Basis Function !! 1) Chebyshev polynomials integer :: order !! Maximum order of Polynomial double precision :: log_max !! Maximum Value of Polynomial Evaluation nameList / poly_spec / & kind , order , log_max read ( unit = unit , nml = poly_spec ) poly_kind ( is ) = kind poly_order ( is ) = order poly_log_max ( is ) = log_max end subroutine poly_read subroutine bM_read ( is ) !!Reads in bi-Maxwellian/cold-plasma parameters. use alps_var , only : bMnmaxs , bMBessel_zeros , bMbetas use alps_var , only : bMalphas , bMpdrifts implicit none integer , intent ( in ) :: is !!Species index. integer :: bM_nmaxs !!Maximum number of resonances to consider. double precision :: bM_Bessel_zeros !!Precision threshold for I_n. double precision :: bM_betas !!\\beta_{\\parallel,j} of biMaxwellian distribution f_j. !! If bM_betas=0.d0, this species is treated with the cold-plasma susceptibilities. double precision :: bM_alphas !!T_{\\perp,j}/T_{\\parallel,j}  of biMaxwellian distribution f_j. double precision :: bM_pdrifts !!Relative drift of biMaxwellian distribution f_j, !!in units of m_p v_{A,p}. Also used as the drift of the cold-plasma species !! if bM_betas is set to 0.d0. nameList / bM_spec / & bM_nmaxs , bM_Bessel_zeros , bM_betas , bM_alphas , bM_pdrifts read ( unit = unit , nml = bM_spec ) bMnmaxs ( is ) = bM_nmaxs ; bMBessel_zeros ( is ) = bM_Bessel_zeros bMbetas ( is ) = bM_betas ; bMalphas ( is ) = bM_alphas ; bMpdrifts ( is ) = bM_pdrifts end subroutine bM_read subroutine scan_read ( is ) !!The most important subroutine. !!Reads in wavevector scan parameters. !!Defines [[scanner(type)]], which controls the !!behavior of the wavevector scan. use alps_var , only : scan , kperp_last , kpar_last implicit none integer , intent ( in ) :: is !!Scan index. integer :: scan_type !!Determine kind of wavevector scan. integer :: ns !!Number of output scan values. integer :: nres !!Resolution between output scan values. double precision :: swi !!Initial Scan Value. double precision :: swf !!Final Scan Value. logical :: swlog !!\\log_{10} or linear scan spacing. logical :: heating !!Activate heating calculation. logical :: eigen !!Activate eigenfunction calculation. double precision :: theta_0 !!\\atan(k_\\perp/k_\\parallel) double precision :: k_0 !!\\sqrt{k_\\perp&#94;2+k_\\parallel&#94;2} nameList / scan_input / & scan_type , swi , swf , swlog , ns , nres ,& heating , eigen read ( unit = unit , nml = scan_input ) scan ( is )% range_i = swi scan ( is )% range_f = swf scan ( is )% log_scan = swlog scan ( is )% type_s = scan_type scan ( is )% n_out = ns scan ( is )% n_res = nres scan ( is )% eigen_s = eigen scan ( is )% heat_s = heating !Calculate step size: select case ( scan_type ) case ( 0 ) !Scan from k_0 to k_1: write ( * , '(a,i0,a,es14.4e3,a,es14.4e3,a,es14.4e3,a,es14.4e3,a)' )& 'Scan ' , is , ': (kpar,kperp) from (' ,& kperp_last , ',' , kpar_last , ') to (' , swi , ',' , swf , ')' if ( swlog ) then scan ( is )% diff = ( log10 ( swi ) - log10 ( kperp_last )) / & ( 1.d0 * ns * nres ) scan ( is )% diff2 = ( log10 ( swf ) - log10 ( kpar_last )) / & ( 1.d0 * ns * nres ) else scan ( is )% diff = ( swi - kperp_last ) / ( 1.d0 * ns * nres ) scan ( is )% diff2 = ( swf - kpar_last ) / ( 1.d0 * ns * nres ) endif kperp_last = swi ; kpar_last = swf case ( 1 ) !Scan from theta_0 to theta_1: theta_0 = atan ( kperp_last / kpar_last ) k_0 = sqrt ( kperp_last ** 2 + kpar_last ** 2 ) write ( * , '(a,i0,a,es14.4e3,a,es14.4e3)' )& 'Scan ' , is , ': theta from ' ,& theta_0 * 18 0.d0 / ( 4.d0 * atan ( 1.d0 )), ' to ' , swf if ( swlog ) then scan ( is )% diff = ( log10 ( swf * 4.d0 * atan ( 1.d0 ) / 18 0. ) - & log10 ( theta_0 )) / ( 1.d0 * ns * nres ) else scan ( is )% diff = (( swf * 4.d0 * atan ( 1.d0 ) / 18 0. ) - theta_0 ) / & ( 1.d0 * ns * nres ) endif kpar_last = k_0 * cos ( swf * 4.d0 * atan ( 1.d0 ) / 18 0.d0 ) kperp_last = k_0 * sin ( swf * 4.d0 * atan ( 1.d0 ) / 18 0.d0 ) case ( 2 ) !Scan from |k_0| to |k_1| at constant theta. theta_0 = atan ( kperp_last / kpar_last ) k_0 = sqrt ( kperp_last ** 2 + kpar_last ** 2 ) write ( * , '(a,i0,a,es14.4e3,a,es14.4e3,a,es14.4e3,a,es14.4e3,a)' )& 'Scan ' , is , ': |k| from ' ,& k_0 , ' to ' , swf , ' at theta=' , theta_0 * 18 0.d0 / & ( 4.d0 * atan ( 1.d0 )) if ( swlog ) then scan ( is )% diff = ( log10 ( swf ) - log10 ( k_0 )) / & ( 1.d0 * ns * nres ) else scan ( is )% diff = ( swf - k_0 ) / ( 1.d0 * ns * nres ) endif kpar_last = k_0 * cos ( theta_0 ) kperp_last = k_0 * sin ( theta_0 ) case ( 3 ) !Scan of kperp; kpar constant: write ( * , '(a,i0,a,es14.4e3,a,es14.4e3)' )& 'Scan ' , is , ': kperp from ' , kperp_last , ' to ' , swf if ( swlog ) then scan ( is )% diff = ( log10 ( swf ) - log10 ( kperp_last )) / ( 1.d0 * ns * nres ) else scan ( is )% diff = ( swf - kperp_last ) / ( 1.d0 * ns * nres ) endif kperp_last = swf case ( 4 ) !Scan of kpar; kperp constant: write ( * , '(a,i0,a,es14.4e3,a,es14.4e3)' )& 'Scan ' , is , ': kpar from ' , kpar_last , ' to ' , swf if ( swlog ) then scan ( is )% diff = ( log10 ( swf ) - log10 ( kpar_last )) / ( 1.d0 * ns * nres ) else scan ( is )% diff = ( swf - kpar_last ) / ( 1.d0 * ns * nres ) endif kpar_last = swf end select end subroutine scan_read subroutine fit_read ( is , ifit ) !!Reads in fit parameters for component is. use alps_var , only : fit_type , param_fit , perp_correction implicit none integer , intent ( in ) :: is !!Species index. integer , intent ( in ) :: ifit !Fit index. double precision :: fit_1 !! Read in values for fit component 1. double precision :: fit_2 !! Read in values for fit component 2. double precision :: fit_3 !! Read in values for fit component 3. double precision :: fit_4 !! Read in values for fit component 4. double precision :: fit_5 !! Read in values for fit component 5. double precision :: perpcorr !!Perpendicular correction to compensate for exponential !!dependency of drift to make fit more reliable !![y in Eqn B1 of Verscharen et al 2018]. integer :: fit_type_in !!Read in value for type of analytic function. nameList / ffit / & fit_type_in , fit_1 , fit_2 , fit_3 , fit_4 , fit_5 , perpcorr fit_1 = 0.d0 ; fit_2 = 0.d0 ; fit_3 = 0.d0 ; fit_4 = 0.d0 ; fit_5 = 0.d0 ; perpcorr = 0.d0 read ( unit = unit , nml = ffit ) fit_type ( is , ifit ) = fit_type_in param_fit ( is , 0 , 1 , ifit ) = fit_1 param_fit ( is , 0 , 2 , ifit ) = fit_2 param_fit ( is , 0 , 3 , ifit ) = fit_3 param_fit ( is , 0 , 4 , ifit ) = fit_4 param_fit ( is , 0 , 5 , ifit ) = fit_5 perp_correction ( is , ifit ) = perpcorr end subroutine fit_read subroutine get_runname ( runname , foldername ) !! Get runname for output files from input argument. implicit none integer :: l !!Dummy Length. integer :: pathend !!Directory divider. character ( 500 ) :: arg !!Input Argument. character ( 500 ), intent ( out ) :: runname !!Basename for file I/O. character ( 500 ), intent ( out ) :: foldername !!Directory in which input file is stored. !Get the first argument of the program execution command: call getarg ( 1 , arg ) pathend = 0 !Check if this is the input file and trim .in extension to get runname. !Also remove any folder structure from the runname: l = len_trim ( arg ) pathend = scan ( arg , \"/\" , . true .) if ( l > 3 . and . arg ( l - 2 : l ) == \".in\" ) then runname = arg ( pathend + 1 : l - 3 ) foldername = arg ( 1 : pathend ) end if end subroutine get_runname subroutine read_f0 !! Subroutine for reading in background distribution function use alps_var , only : nperp , npar , arrayName , f0 , pp , nspec use alps_var , only : writeOut , usebM implicit none integer :: ipar !Parallel index. integer :: iperp !!Perpendicular index. integer :: is !!Species index. character ( 100 ) :: readname !!Base I/O name. if ( writeOut ) & write ( * , '(2a)' )& 'Attempting to read f0 array from file: ' , trim ( arrayName ) call get_unused_unit ( input_unit_no ) unit = input_unit_no !The f0 arrays are stored in the distribution folder. !arrayName is read in from *.in input file. !each species is has a unique file for f0 as a function of pp. do is = 1 , nspec if ( usebM ( is )) then write ( * , '(a,i2)' ) ' Bi-Maxwellian/cold-plasma calculation: not reading f0 array for species ' , is f0 ( is ,:,:) = 0.d0 pp ( is ,:,:,:) = 0.d0 else write ( readname , '(3a,i0,a)' ) & \"distribution/\" , trim ( arrayName ), '.' , is , \".array\" open ( unit = unit , file = trim ( readname ), status = 'old' , action = 'read' ) do iperp = 0 , nperp do ipar = 0 , npar read ( unit , * ) pp ( is , iperp , ipar , 1 ), pp ( is , iperp , ipar , 2 ), f0 ( is , iperp , ipar ) enddo enddo close ( unit ) endif enddo end subroutine read_f0 subroutine get_indexed_namelist_unit ( unit , nml , index_in ) !!Determines unused I/O unit. use alps_var , only : runname implicit none integer , intent ( out ) :: unit !!Unit to be defined. character ( * ), intent ( in ) :: nml !!Character string for namelist to be read in. integer , intent ( in ) :: index_in !!Index of namelist to be read in. character ( 500 ) :: line !!I/O dummy variable. integer :: iunit , iostat , in_file !!I/O dummy indices. integer :: ind_slash !!I/O dummy index. logical :: exist !!Check if namelist is open. call get_unused_unit ( unit ) ind_slash = index ( runname , \"/\" ,. True .) if ( ind_slash . EQ . 0 ) then !No slash in name !Original behaviour open ( unit = unit , file = '.' // trim ( runname ) // '.scratch' ) else !General behaviour open ( unit = unit , file = trim ( runname ( 1 : ind_slash )) // \".\" // trim ( runname ( ind_slash + 1 :)) // \".scratch\" ) endif write ( line , * ) index_in line = nml // \"_\" // trim ( adjustl ( line )) in_file = input_unit_exist ( trim ( line ), exist ) if ( exist ) then iunit = input_unit ( trim ( line )) else call alps_error ( 1 ) end if read ( unit = iunit , fmt = \"(a)\" ) line write ( unit = unit , fmt = \"('&',a)\" ) nml do read ( unit = iunit , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 . or . trim ( adjustl ( line )) == \"/\" ) exit write ( unit = unit , fmt = \"(a)\" ) trim ( line ) end do write ( unit = unit , fmt = \"('/')\" ) rewind ( unit = unit ) end subroutine get_indexed_namelist_unit subroutine get_indexed_double_namelist_unit ( unit , nml , spec_in , index_in ) !!A version of [[get_indexed_namelist_unit(subroutine)]], extended !!to allow for double indexing in order to read in multiple fits !!for a single species. use alps_var , only : runname implicit none integer , intent ( out ) :: unit !!Unit to be defined. character ( * ), intent ( in ) :: nml !!Character string for namelist to be read in. integer , intent ( in ) :: spec_in !!First index of namelist to be read in. integer , intent ( in ) :: index_in !!Second index of namelist to be read in. character ( 500 ) :: line , lines !!I/O dummy variable. integer :: iunit , iostat , in_file !!I/O dummy indices. integer :: ind_slash !!I/O dummy index. logical :: exist !!Check if namelist is open. call get_unused_unit ( unit ) ind_slash = index ( runname , \"/\" ,. True .) if ( ind_slash . EQ . 0 ) then !No slash in name !Original behaviour open ( unit = unit , file = '.' // trim ( runname ) // '.scratch' ) else !General behaviour open ( unit = unit , file = trim ( runname ( 1 : ind_slash )) // \".\" // trim ( runname ( ind_slash + 1 :)) // \".scratch\" ) endif write ( line , * ) index_in write ( lines , * ) spec_in line = nml // \"_\" // trim ( adjustl ( lines )) // \"_\" // trim ( adjustl ( line )) in_file = input_unit_exist ( trim ( line ), exist ) if ( exist ) then iunit = input_unit ( trim ( line )) else call alps_error ( 1 ) end if read ( unit = iunit , fmt = \"(a)\" ) line write ( unit = unit , fmt = \"('&',a)\" ) nml do read ( unit = iunit , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 . or . trim ( adjustl ( line )) == \"/\" ) exit write ( unit = unit , fmt = \"(a)\" ) trim ( line ) end do write ( unit = unit , fmt = \"('/')\" ) rewind ( unit = unit ) end subroutine get_indexed_double_namelist_unit function input_unit_exist ( nml , exist ) !!Determine if a particular namelist already opened. implicit none character ( * ), intent ( in ) :: nml !!Namelist to be opened. logical , intent ( out ) :: exist !!Determination if namelist is open. integer :: input_unit_exist , iostat !!I/O dummy indices. character ( 500 ) :: line !!I/O dummy variable. intrinsic adjustl , trim input_unit_exist = input_unit_no exist = . true . if ( input_unit_no > 0 ) then rewind ( unit = input_unit_no ) do read ( unit = input_unit_no , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) then rewind ( unit = input_unit_no ) exit end if if ( trim ( adjustl ( line )) == \"&\" // nml ) then backspace ( unit = input_unit_no ) return end if end do end if exist = . false . end function input_unit_exist function input_unit ( nml ) !!Assigns input unit for namelist opening. implicit none character ( * ), intent ( in ) :: nml !! Namelist string. integer :: input_unit , iostat !!I/O dummy indices. character ( 500 ) :: line !!I/O dummy variable. intrinsic adjustl , trim input_unit = input_unit_no if ( input_unit_no > 0 ) then rewind ( unit = input_unit_no ) do read ( unit = input_unit_no , fmt = \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) then rewind ( unit = input_unit_no ) exit end if if ( trim ( adjustl ( line )) == \"&\" // nml ) then backspace ( unit = input_unit_no ) return end if end do end if write ( unit = error_unit_no , fmt = \"('Couldn''t find namelist: ',a)\" ) nml write ( unit =* , fmt = \"('Couldn''t find namelist: ',a)\" ) nml end function input_unit subroutine get_unused_unit ( unit ) !!Determine unused number for I/O index. implicit none integer , intent ( out ) :: unit !!Unit to be assigned. logical :: od unit = 50 do inquire ( unit = unit , opened = od ) if (. not . od ) return unit = unit + 1 end do end subroutine get_unused_unit subroutine alps_error_init !!Open a file for the error log. use alps_var , only : unit_error , runname , foldername implicit none call get_unused_unit ( unit_error ) !Get the run name, which comes from the name !of the input file appended after the executable: !mpirun -np 8 ./alps.e sample.in !yields a run name of 'sample' call get_runname ( runname , foldername ) open ( unit = unit_error , file = trim ( foldername ) // trim ( runname ) // \".log\" , status = 'replace' ) end subroutine alps_error_init subroutine alps_error ( error_id ) !!Error catching subroutine. use alps_var , only : ierror , unit_error , nproc , scan_option use mpi implicit none integer :: error_id !!Index of error message. !    if (proc0) then select case ( error_id ) case ( 0 ) !seen by all processors write ( * , '(a,i6)' ) 'ERROR: Number of processors must be even and greater than 2: nproc= ' , nproc write ( unit_error , '(a,i6)' ) 'ERROR: Number of processors must be even and greater than 2: nproc= ' , nproc case ( 1 ) !seen by proc0 write ( * , '(2a)' ) \"get_indexed_namelist: required input namelist not found \" write ( unit_error , '(2a)' ) \"get_indexed_namelist: required input namelist not found \" case ( 2 ) !seen by proc0 write ( * , '(a)' ) \"ERROR: More fit parameters than data points.\" write ( unit_error , '(a)' ) \"ERROR: More fit parameters than data points.\" case ( 3 ) !seen by all processors write ( * , '(a,i6)' )& 'ERROR: scan_option not set to allowable value:' , scan_option write ( unit_error , '(a,i6)' )& 'ERROR: scan_option not set to allowable value:' , scan_option case ( 4 ) !seen by all processors write ( * , '(a)' )& 'ERROR: n_scan .ne.2 for scan_option=2' write ( unit_error , '(a)' )& 'ERROR: n_scan .ne.2 for scan_option=2' case ( 5 ) !seen by all processors write ( * , '(a)' )& 'ERROR: scan(1)%type_s==scan(2)%type_s for double k scan' write ( unit_error , '(a)' )& 'ERROR: scan(1)%type_s==scan(2)%type_s for double k scan' case ( 6 ) !seen by all processors write ( * , '(a)' )& 'ERROR: scan(*)%type_s=0 not allowed for double k scan' write ( unit_error , '(a)' )& 'ERROR: scan(*)%type_s=0 not allowed for double k scan' case ( 7 ) !seen by all processors write ( * , '(a)' )& 'ERROR: Fit for analytical continuation failed. Adjustment of perpcorr may resolve this problem.' write ( unit_error , '(a)' )& 'ERROR: Fit for analytical continuation failed. Adjustment of perpcorr may resolve this problem.' case ( 8 ) !seen by all processors write ( * , '(a)' )& 'ERROR: Resonance integration covers entire subluminal cone.' write ( * , '(a)' )& '       Adjustment of positions_principal, npar, or a non-relativistic run may resolve this problem.' write ( unit_error , '(a)' )& 'ERROR: Resonance integration covers entire subluminal cone.' write ( unit_error , '(a)' )& '       Adjustment of positions_principal, npar, or a non-relativistic run may resolve this problem.' case ( 9 ) !seen by all processors write ( * , '(a)' )& 'ERROR: All roots diverged. Adjustment of initial guesses or step width may resolve this problem.' write ( unit_error , '(a)' )& 'ERROR: All roots diverged. Adjustment of initial guesses or step width may resolve this problem.' case ( 10 ) !seen by proc0 write ( * , '(a)' ) \"ERROR: Unspecified Orthogonal Representation.\" write ( unit_error , '(a)' ) \"ERROR: Unspecified Orthogonal Representation.\" case default write ( * , '(a)' ) 'ERROR: Unspecified...' write ( unit_error , '(a)' ) 'ERROR: Unspecified...' end select write ( * , '(a)' ) 'Finishing ALPS==================================' write ( * , '(a)' ) \"Time:\" call output_time write ( * , '(a)' ) '================================================' close ( unit_error ) call mpi_abort ( MPI_COMM_WORLD , error_id , ierror ) stop end subroutine alps_error logical function isnancheck ( input ) !!Checks if double precision number input is NaN. implicit none double precision :: input !! Variable to be checked. isnancheck = . FALSE . if ( abs ( input ). GE . huge ( 1.d0 )) isnancheck = . TRUE . if ( input . NE . input ) isnancheck = . TRUE . end function isnancheck subroutine output_time !!Outputs the date and time in a given format using intrinsic !!FORTRAN function. implicit none character ( 8 ) :: date !!Date. character ( 10 ) :: time !!Time. character ( 5 ) :: zone !!Time Zone. integer , dimension ( 8 ) :: value !!Output Time Values. call date_and_time ( date , time , zone , value ) write ( * , '(i4,a,i2.2,a,i2.2,a,i2.2,a,i2.2,a,i2.2)' ) value ( 1 ), \"-\" , value ( 2 ), \"-\" , value ( 3 ), \" -- \" , value ( 5 ), \":\" , value ( 6 ), \":\" , value ( 7 ) end subroutine output_time subroutine display_credits !!Writes the opening credits. implicit none write ( * , * ) \"===========================================================\" write ( * , * ) \"I                                                         I\" write ( * , * ) \"I                       A  L  P  S                        I\" write ( * , * ) \"I              Arbitrary Linear Plasma Solver             I\" write ( * , * ) \"I                                                         I\" write ( * , * ) \"I                       Version 1.0                       I\" write ( * , * ) \"I                                                         I\" write ( * , * ) \"I  Kristopher Klein   (kgklein@arizona.edu)               I\" write ( * , * ) \"I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)            I\" write ( * , * ) \"I                                                         I\" write ( * , * ) \"===========================================================\" end subroutine display_credits end module alps_io","tags":"","url":"sourcefile/alps_io.f90.html"},{"title":"ALPS_analyt.f90 – ALPS","text":"Source Code !Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen !All rights reserved. ! !This source code is licensed under the BSD-style license found in the !LICENSE file in the root directory of this source tree. ! !=============================================================================== !I                                                                             I !I                              A  L  P  S                                     I !I                     Arbitrary Linear Plasma Solver                          I !I                                                                             I !I                              Version 1.0                                    I !I                                                                             I !I  Kristopher Klein   (kgklein@arizona.edu)                                   I !I  Daniel Verscharen  (d.verscharen@ucl.ac.uk)                                I !I                                                                             I !=============================================================================== module alps_analyt !! This module contains functions and subroutines for the hybrid analytical continuation. implicit none public :: eval_fit , determine_param_fit private :: set_polynomial_basis private :: fit_function , output_fit , determine_JT , LM_nonlinear_fit private :: determine_GLLS , factorial contains double complex function eval_fit ( is , iperp , ppar_valC ) !! This function evaluates the fit to f0 at and the complex parallel !! momentum ppar_valC. It requires the fit parameters that will be determined !! by the subroutine [[determine_param_fit(subroutine)]]. use alps_var , only : fit_type , pp , param_fit , n_fits , gamma_rel , nspec , relativistic use alps_var , only : ACmethod , poly_fit_coeffs , poly_order use alps_distribution_analyt , only : distribution_analyt implicit none integer , intent ( in ) :: is !! Index of species for which [[eval_fit(function)]] is executed. integer , intent ( in ) :: iperp !! Index of perpendicular momentum at which [[eval_fit(function)]] is executed. double complex , intent ( in ) :: ppar_valC !! Complex parallel momentum at which [[eval_fit(function)]] is executed. double precision :: pperp_val !! Perpendicular momentum corrsponding to index iperp. integer :: par_ind !! Parameter index for the fit parameters. integer :: ifit !! Index for the fits that add up to the total fit for a given species. integer :: n_params !! Total number of fit parameters for a given species. integer :: is_rel !! Index for relativistic species (if any). integer :: sproc_rel !! MPI process number for relativistic species. integer :: is_run !! Running variable over species to determine relativistic evaluation. double precision , allocatable , dimension (:) :: params !! Array of fit parameters. select case ( ACmethod ( is )) case ( 0 ) ! Use the pre-coded distribution from distribution/distribution_analyt.f90 eval_fit = distribution_analyt ( is , pp ( is , iperp , 1 , 1 ), ppar_valC ) return case ( 1 ) ! Use the 'n_fits' functions described with 'fit_type' n_params = 0 ! total number of fit_parameters do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) n_params = n_params + 3 ! Maxwell if ( fit_type ( is , ifit ). EQ . 2 ) n_params = n_params + 5 ! kappa if ( fit_type ( is , ifit ). EQ . 3 ) n_params = n_params + 3 ! Juettner with pperp and ppar if ( fit_type ( is , ifit ). EQ . 4 ) n_params = n_params + 1 ! Juettner with gamma and pparbar, constant in pparbar if ( fit_type ( is , ifit ). EQ . 5 ) n_params = n_params + 3 ! Juettner with gamma and pparbar with pparbar-dependence if ( fit_type ( is , ifit ). EQ . 6 ) n_params = n_params + 4 ! Bi-Moyal distribution enddo allocate ( params ( n_params )) par_ind = 0 do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell pperp_val = pp ( is , iperp , 1 , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa pperp_val = pp ( is , iperp , 1 , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) params ( ifit + par_ind + 3 ) = param_fit ( is , iperp , 4 , ifit ) params ( ifit + par_ind + 4 ) = param_fit ( is , iperp , 5 , ifit ) par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner in pperp and ppar pperp_val = pp ( is , iperp , 1 , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner in gamma and pparbar, constant in pparbar ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo pperp_val = gamma_rel ( sproc_rel , iperp , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) par_ind = par_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner in gamma and pparbar with pparbar-dependence ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo pperp_val = gamma_rel ( sproc_rel , iperp , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! Bi-Moyal pperp_val = pp ( is , iperp , 1 , 1 ) params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) params ( ifit + par_ind + 3 ) = param_fit ( is , iperp , 4 , ifit ) par_ind = par_ind + 3 endif enddo eval_fit = fit_function ( is , n_params , params , pperp_val , ppar_valC ) deallocate ( params ) return case ( 2 ) ! use the orthogonal polynomials of kind described in &poly_is !write(*,*)iproc,is,iperp,ppar_valC eval_fit = fit_function_poly ( is , iperp , ppar_valC , poly_order ( is ),& poly_fit_coeffs ( is , iperp , 0 : poly_order ( is ))) !write(*,*)iproc,is,iperp,ppar_valC,eval_fit end select end function eval_fit double complex function fit_function ( is , n_params , params , pperp_val , ppar_val ) !! This function evaluates the fit to f0 at real pperp_val and complex ppar_val, !! provided that the one-dimensional fit-parameter array params is fed into the !! function. This is only used during the fitting. For the evaluation in ALPS, !! use [[eval_fit(function)]]. use alps_var , only : fit_type , n_fits , ms , vA , perp_correction implicit none integer , intent ( in ) :: is !! Index of species for which [[eval_fit(function)]] is executed. integer , intent ( in ) :: n_params !! Total number of fit parameters for a given species. double precision , intent ( in ) :: params ( n_params ) !! Array of fit parameters. double precision , intent ( in ) :: pperp_val !! Perpendicular momentum. double complex , intent ( in ) :: ppar_val !! Complex parallel momentum. integer :: ifit !! Index for the fits that add up to the total fit for a given species. integer :: par_ind !! Parameter index to loop over fits. double complex :: sqrtpart !! Square-root part of Juettner distribution. double complex :: kappapart !! Kappa part of the kappa distribution. fit_function = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) par_ind = 0 do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( - perp_correction ( is , ifit ) * pperp_val ** 2 )& * exp ( - params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa kappapart = 1.d0 + params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 & + perp_correction ( is , ifit ) * params ( ifit + par_ind + 4 ) * pperp_val ** 2 fit_function = fit_function + params ( ifit + par_ind + 0 ) * kappapart ** params ( ifit + par_ind + 3 ) par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner in pperp and ppar sqrtpart = sqrt ( 1.d0 + ( pperp_val ** 2 + ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) * vA * vA / ( ms ( is ) * ms ( is ))) fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( - params ( ifit + par_ind + 1 ) * sqrtpart ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner in gamma only, constant in pparbar fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( - perp_correction ( is , ifit ) * pperp_val ) par_ind = par_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner in gamma and pparbar with pparbar-dependence fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( - perp_correction ( is , ifit ) * pperp_val ) * & exp ( - params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! Bi-Moyal fit_function = fit_function + params ( ifit + par_ind + 0 ) * exp ( 0.5d0 * ( params ( ifit + par_ind + 3 ) * & perp_correction ( is , ifit ) * pperp_val ** 2 + params ( ifit + par_ind + 1 ) * & ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 - & exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) )) par_ind = par_ind + 3 endif enddo return end function fit_function double complex function fit_function_poly ( is , iperp , ppar_val , n_poly , fit_coeffs ) !! This function evaluates the orthogonal polynomical fit to f0 !! at real pperp_val and complex ppar_val, !! with the one-dimensional polynomical coefficient array fit_coeffs is fed into the !! function. !! For the evaluation in ALPS, use [[eval_fit(function)]]. use alps_var , only : pp , poly_kind , npar , logfit use alps_var , only : poly_log_max implicit none integer :: n_poly !! Maximum Polynomial Order integer , intent ( in ) :: is !! Index of species for which [[eval_fit(function)]] is executed. double precision , intent ( in ) :: fit_coeffs ( 0 : n_poly ) !! Array of polynomial coefficients double complex :: poly_basis ( 0 : n_poly ) !! Array of polynomial coefficients integer :: n !! Polynomial Order Index integer , intent ( in ) :: iperp !! Index of perpendicular momentum at which [[fit_function_poly(function)]] is executed. double complex :: ppar_val !! Complex parallel momentum. double complex :: ppar_val_tmp !! Complex parallel momentum. double precision :: norm_1 , norm_2 !! Range of p_parallel for rescaling polynomials fit_function_poly = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) select case ( poly_kind ( is )) case ( 1 ) !Chebyshev polynomials range from [-1,1] norm_1 = 5.d-1 * ( pp ( is , iperp , npar , 2 ) + pp ( is , iperp , 0 , 2 )) norm_2 = 5.d-1 * ( pp ( is , iperp , npar , 2 ) - pp ( is , iperp , 0 , 2 )) ppar_val_tmp = ( ppar_val - norm_1 ) / norm_2 if ( abs ( ppar_val_tmp ). gt . 1.d0 ) then !!kgk: should this be .gt. or .ge. ? fit_function_poly = 0.d0 else n = 0 poly_basis ( n ) = cmplx ( 1.d0 , 0.d0 , kind ( 1.d0 )) fit_function_poly = fit_function_poly + fit_coeffs ( n ) * poly_basis ( n ) n = 1 poly_basis ( n ) = ppar_val_tmp fit_function_poly = fit_function_poly + fit_coeffs ( n ) * poly_basis ( n ) do n = 2 , n_poly poly_basis ( n ) = cmplx ( 2.d0 , 0.d0 , kind ( 1.d0 )) * ppar_val_tmp * poly_basis ( n - 1 ) - poly_basis ( n - 2 ) fit_function_poly = fit_function_poly + fit_coeffs ( n ) * poly_basis ( n ) enddo if ( logfit ( is )) then !if (abs(fit_function_poly).gt.20.) then !KGK: how does this impact the 'noise' !if ((real(fit_function_poly).gt.1.).or.(aimag(fit_function_poly).gt.1.)& !     .or.(real(fit_function_poly).lt.-18.).or.(aimag(fit_function_poly).lt.-18.)) then !if ((real(fit_function_poly).gt.10.).or.(aimag(fit_function_poly).gt.10.)& !     .or.(real(fit_function_poly).lt.-22.).or.(aimag(fit_function_poly).lt.-22.)) then !KGK: Need to investigate the appropriate threshold here for when this functional !representation ceases to work. !if ((real(fit_function_poly).gt.17.).or.(aimag(fit_function_poly).gt.17.)& !if ((real(fit_function_poly).lt.-poly_log_max(is)).or.& !?? !(aimag(fit_function_poly).lt.-poly_log_max(is))) then if (( real ( fit_function_poly ). lt . - poly_log_max ( is )). or .& !?? ( aimag ( fit_function_poly ). lt . - poly_log_max ( is )). or .& ( real ( fit_function_poly ). gt . poly_log_max ( is )). or .& !?? ( aimag ( fit_function_poly ). gt . poly_log_max ( is ))) then !if ((abs(fit_function_poly).lt.-100.d0).or.(abs(fit_function_poly).gt.100.d0)) then !if ((abs(fit_function_poly).lt.-50.d0).or.(abs(fit_function_poly).gt.50.d0)) then !if (abs(fit_function_poly).gt.poly_log_max(is)) then fit_function_poly = cmplx ( 0.d0 , 0.d0 , kind ( 1.d0 )) else !write(*,*)iproc,is,iperp,ppar_val,ppar_val_tmp,fit_function_poly fit_function_poly = 1 0.d0 ** ( fit_function_poly ) !write(*,*)iproc,is,iperp,ppar_val,ppar_val_tmp,fit_function_poly endif endif endif end select return end function fit_function_poly subroutine determine_param_fit !! This is the fitting routine for the hybrid analytic continuation. It determines !! the full field [[alps_var(module):param_fit(variable)]]. use alps_var , only : writeOut , fit_type , param_fit , n_fits , nspec , f0 , nperp , npar , logfit , runname use alps_var , only : relativistic , npparbar , f0_rel , ngamma , perp_correction , gamma_rel , usebM use alps_var , only : ACmethod , poly_fit_coeffs implicit none integer :: ifit !! Index for the fits that add up to the total fit for a given species. integer :: n_params !! Total number of fit parameters for a given species. integer :: par_ind !! Parameter index for the fit parameters. integer :: iperp !! Index of perpendicular momentum. integer :: is !! Index of species. integer :: is_run !! Running variable over species to determine relativistic evaluation. integer :: is_rel !! Index for relativistic species (if any). integer :: sproc_rel !! Local process index for relativistic calculation. integer :: nJT !! First dimension of matrix JT. integer :: ipparbar !! Index of parallel momentum (relativistic). integer :: ipparbar_lower !! Lower index of parallel momentum (relativistic). integer :: ipparbar_upper !! Upper index of parallel momentum (relativistic). integer :: upperlimit !! Upper limit of iperp space (relativistic and non-relativistic). integer :: unit_spec !! Unit to write fit parameters to file. logical :: found_lower !! Check whether lower boundary was found. logical :: found_upper !! Check whether upper boundary was found. double precision :: quality !! Quality of the individual fit result. double precision :: qualitytotal !! Quality of the total fit result. logical , allocatable , dimension (:) :: param_mask !! Bit mask for required fit parameters. double precision , allocatable , dimension (:) :: g !! Array of function to be fitted. double precision , allocatable , dimension (:) :: params !! Array of fit parameters. character ( 10 ) :: specwrite !! File name to write fit parameters to file. if ( writeOut ) then write ( * , '(a)' ) 'Determine fit parameters for hybrid analytic continuation...' endif qualitytotal = 0.d0 do is = 1 , nspec if ( usebM ( is )) then write ( * , '(a,i2)' ) ' Bi-Maxwellian/cold-plasma calculation: no fits necessary for species ' , is param_fit ( is ,:,:,:) = 0.d0 fit_type ( is ,:) = 1 perp_correction ( is ,:) = 1.d0 elseif ( ACmethod ( is ). EQ . 0 ) then write ( * , '(a,i2)' ) ' Using analytical function from distribution/distribution_analyt.f90: no fits necessary for species ' , is param_fit ( is ,:,:,:) = 0.d0 fit_type ( is ,:) = 1 perp_correction ( is ,:) = 1.d0 elseif ( ACmethod ( is ). EQ . 2 ) then write ( * , '(a,i2)' ) ' Using polynomial representation for species ' , is param_fit ( is ,:,:,:) = 0.d0 fit_type ( is ,:) = 1 perp_correction ( is ,:) = 1.d0 call set_polynomial_basis ( is ) call determine_GLLS ( is ) unit_spec = 2500 + is write ( specwrite , '(i0)' ) is open ( unit = unit_spec , file = 'distribution/' & // trim ( runname ) // '.poly_parameters.' // trim ( specwrite )& // '.out' , status = 'replace' ) do iperp = 0 , nperp write ( unit_spec , * )& iperp , poly_fit_coeffs ( is , iperp ,:) enddo close ( unit_spec ) else ! For all fit types that include a fit parameter for the perpendicular momentum (kappa and Moyal), ! we must not fit this parameter when pperp=0. Otherwise, the LM matrix is singular: n_params = 0 ! total number of fit_parameters do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) n_params = n_params + 3 ! Maxwell if ( fit_type ( is , ifit ). EQ . 2 ) n_params = n_params + 5 ! kappa if ( fit_type ( is , ifit ). EQ . 3 ) n_params = n_params + 3 ! Juettner with pperp and ppar if ( fit_type ( is , ifit ). EQ . 4 ) n_params = n_params + 1 ! Juettner with gamma and pparbar, constant in pparbar if ( fit_type ( is , ifit ). EQ . 5 ) n_params = n_params + 3 ! Juettner with gamma and pparbar with pparbar-dependence if ( fit_type ( is , ifit ). EQ . 6 ) n_params = n_params + 4 ! Bi-Moyal enddo allocate ( params ( n_params )) allocate ( param_mask ( n_params )) if ( relativistic ( is )) then upperlimit = ngamma else upperlimit = nperp endif unit_spec = 2500 + is write ( specwrite , '(i0)' ) is open ( unit = unit_spec , file = 'distribution/' // trim ( runname ) // '.fit_parameters.' // trim ( specwrite ) // '.out' , status = 'replace' ) do iperp = 0 , upperlimit ! Every step that is not iperp = 0 should use the previous result as a start value: if ( iperp . NE . 0 ) param_fit ( is , iperp ,:,:) = param_fit ( is , iperp - 1 ,:,:) par_ind = 0 nJT = 0 param_mask = . TRUE . do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) params ( ifit + par_ind + 3 ) = param_fit ( is , iperp , 4 , ifit ) params ( ifit + par_ind + 4 ) = param_fit ( is , iperp , 5 , ifit ) if ( iperp . EQ . 0 ) then nJT = nJT - 1 param_mask ( ifit + par_ind + 4 ) = . FALSE . endif par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner in pperp and ppar params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner in gamma and pparbar, constant in pparbar params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) par_ind = par_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner in gamma and pparbar with pparbar-dependence params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! Bi-Moyal params ( ifit + par_ind + 0 ) = param_fit ( is , iperp , 1 , ifit ) params ( ifit + par_ind + 1 ) = param_fit ( is , iperp , 2 , ifit ) params ( ifit + par_ind + 2 ) = param_fit ( is , iperp , 3 , ifit ) params ( ifit + par_ind + 3 ) = param_fit ( is , iperp , 4 , ifit ) if ( iperp . EQ . 0 ) then nJT = nJT - 1 param_mask ( ifit + par_ind + 3 ) = . FALSE . endif par_ind = par_ind + 3 endif enddo nJT = nJT + n_params ! Fit and return everything in one array \"params\": if ( relativistic ( is )) then ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo ! What are the relevant ranges in pparbar: found_lower = . FALSE . found_upper = . FALSE . ipparbar_lower = 1 ipparbar_upper = npparbar - 1 do ipparbar = 1 , npparbar - 1 if ((. NOT . found_lower ). AND .( f0_rel ( sproc_rel , iperp , ipparbar - 1 ). LE . - 1.d0 ). AND .( f0_rel ( sproc_rel , iperp , ipparbar ). GT . - 1.d0 )) then ipparbar_lower = ipparbar found_lower = . TRUE . endif if ((. NOT . found_upper ). AND .( f0_rel ( sproc_rel , iperp , ipparbar ). GT . - 1.d0 ). AND .( f0_rel ( sproc_rel , iperp , ipparbar + 1 ). LE . - 1.d0 )) then ipparbar_upper = ipparbar found_upper = . TRUE . endif enddo if (( ipparbar_upper - ipparbar_lower ). GT . 2 ) then allocate ( g ( 0 : ipparbar_upper - ipparbar_lower )) if ( logfit ( is )) then g = log ( f0_rel ( sproc_rel , iperp , ipparbar_lower : ipparbar_upper )) else g = f0_rel ( sproc_rel , iperp , ipparbar_lower : ipparbar_upper ) endif call LM_nonlinear_fit ( is , g , n_params , nJT , params , param_mask , iperp ,& ( ipparbar_upper - ipparbar_lower ), ipparbar_lower , quality ) deallocate ( g ) else par_ind = 0 do ifit = 1 , n_fits ( is ) params ( ifit + par_ind + 0 ) = f0_rel ( sproc_rel , iperp ,( ipparbar_upper + ipparbar_lower ) / 2 ) / & exp ( - perp_correction ( is , ifit ) * gamma_rel ( sproc_rel , iperp , 1 )) if ( fit_type ( is , ifit ). EQ . 5 ) then params ( ifit + par_ind + 1 ) = 1.d-12 params ( ifit + par_ind + 2 ) = 0.d0 par_ind = par_ind + 2 endif enddo endif else ! non-relativistic allocate ( g ( 0 : npar )) if ( logfit ( is )) then g = log ( f0 ( is , iperp ,:)) else g = f0 ( is , iperp ,:) endif call LM_nonlinear_fit ( is , g , n_params , nJT , params , param_mask , iperp , npar , 0 , quality ) deallocate ( g ) endif qualitytotal = qualitytotal + quality ! Write  Fit parameters to output files write ( unit_spec , * ) iperp , params ! Fill it back into the param_fit field: par_ind = 0 do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) param_fit ( is , iperp , 4 , ifit ) = params ( ifit + par_ind + 3 ) param_fit ( is , iperp , 5 , ifit ) = params ( ifit + par_ind + 4 ) par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner in pperp and ppar param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner in gamma and pparbar, constant in pparbar param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) par_ind = par_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner in gamma and pparbar with pparbar-dependence param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) par_ind = par_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! Bi-Moyal param_fit ( is , iperp , 1 , ifit ) = params ( ifit + par_ind + 0 ) param_fit ( is , iperp , 2 , ifit ) = params ( ifit + par_ind + 1 ) param_fit ( is , iperp , 3 , ifit ) = params ( ifit + par_ind + 2 ) param_fit ( is , iperp , 4 , ifit ) = params ( ifit + par_ind + 3 ) par_ind = par_ind + 3 endif enddo enddo ! End loop over iperp close ( unit_spec ) deallocate ( params ) deallocate ( param_mask ) endif !end if (bM or ACmethod) selection enddo ! End loop over is if ( writeOut ) then call output_fit ( qualitytotal ) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=-' endif end subroutine determine_param_fit subroutine determine_GLLS ( is ) !! This subroutine evaluates the General Linear Least Squares fit !! to the distribution function for component 'is' using the selected !! polynomial basis functions. use alps_var , only : polynomials , nperp , npar , f0 , poly_fit_coeffs , poly_order use alps_var , only : logfit implicit none integer :: is !! Index of species. integer :: iperp !! Perpendicular index. integer :: ipar !! parallel index double precision , dimension (:), allocatable :: f0_fit double precision :: min_val write ( * , '(a,i2)' ) 'Determining GLLS Coefficients for Component: ' , is allocate ( f0_fit ( 0 : npar )); f0_fit = 0.d0 do iperp = 0 , nperp if ( logfit ( is )) then if ( minval ( f0 ( is , iperp ,:)) . gt . 0.d0 ) then f0_fit (:) = log10 ( f0 ( is , iperp ,:)) else ! Get min nonzero value from f0(is,iperp,:) before log10 conversion: if ( any ( f0 ( is , iperp ,:) > 0.d0 )) then min_val = minval ( f0 ( is , iperp ,:), mask = ( f0 ( is , iperp ,:) > 0.d0 )) else ! Fallback value if all entries are zero; adjust as needed. min_val = 1.0d-6 endif ! Copy the slice and replace zeros with 0.01*min_val: f0_fit (:) = f0 ( is , iperp ,:) do ipar = 0 , npar if ( f0_fit ( ipar ) == 0.d0 ) then f0_fit ( ipar ) = 0.01d0 * min_val endif enddo do ipar = 0 , npar if ( f0_fit ( ipar ) <= 0.0d0 ) then print * , 'Non-positive value at index' , ipar , f0_fit ( ipar ) endif enddo f0_fit (:) = log10 ( f0_fit (:)) !else !   f0_fit(:)=log10(f0(is,iperp,:)) endif else f0_fit (:) = f0 ( is , iperp ,:) endif call least_squares_fit ( polynomials ( is ,:,:), f0_fit , poly_fit_coeffs ( is , iperp ,:), poly_order ( is )) enddo deallocate ( f0_fit ) end subroutine determine_GLLS subroutine least_squares_fit ( AA , BB , coeffs , npoly ) !!Solves General Linear Least Squares Normal Equation use alps_var , only : npar implicit none integer :: npoly !! Order for polyhedral representation double precision , intent ( in ) :: BB ( 0 : npar ) !! f0(is,iperp,:) double precision , intent ( out ) :: coeffs ( 0 : npoly ) !! fit coefficients double precision , intent ( in ) :: AA ( 0 : npar , 0 : npoly ) !! Polynomial Basis integer , dimension ( 0 : npoly ) :: ipiv !!Pivot Indices integer :: info !!LAPACK error diagnostics double precision :: alpha ( 0 : npoly , 0 : npoly ) !! A&#94;T.A component of General Linear Least Square calculation !! e.g. Eqn 15.4.7 from Numerical Recipies double precision :: beta ( 0 : npoly ) !! A&#94;T.b component of General Linear Least Square calculation !! e.g. Eqn 15.4.7 from Numerical Recipies alpha = 0.d0 beta = 0.d0 ! Calculate (A&#94;T * A) for the normal equation solution call dgemm ( 'T' , 'N' , npoly + 1 , npoly + 1 , npar + 1 , 1.0d0 , AA ( 0 : npar , 0 : npoly ), & npar + 1 , AA ( 0 : npar , 0 : npoly ), npar + 1 , 0.0d0 , alpha ( 0 : npoly , 0 : npoly ), npoly + 1 ) ! Calculate (A&#94;T * B) for the normal equation solution call dgemv ( 'T' , npar + 1 , npoly + 1 , 1.0d0 , AA ( 0 : npar , 0 : npoly ), & npar + 1 , BB ( 0 : npar ), 1 , 0.0d0 , beta ( 0 : npoly ), 1 ) ! Solve for the coefficients using the LAPACK routine call dgesv ( npoly + 1 , 1 , alpha ( 0 : npoly , 0 : npoly ), npoly + 1 , & ipiv ( 0 : npoly ), beta ( 0 : npoly ), npoly + 1 , info ) coeffs ( 0 : npoly ) = beta ( 0 : npoly ) if ( info /= 0 ) then print * , \"Error in dgesv:\" , info stop end if end subroutine least_squares_fit subroutine set_polynomial_basis ( is ) !! This subroutine evaluates the General Linear Least Squares fit !! to the distribution function for component 'is' using the selected !! polynomial basis functions. use alps_var , only : polynomials , poly_kind , poly_order use alps_var , only : writeOut , npar use alps_io , only : alps_error implicit none integer :: is !! Index of species. integer :: ipar !! Index of parallel momentum. integer :: n !! Polynomial Order double precision :: yy !! Argument of Polynomial select case ( poly_kind ( is )) case ( 1 ) !Chebyshev Polynomial Basis if ( writeOut ) & write ( * , '(a,i2)' ) 'Constructing Chebyshev Basis for Component ' , is polynomials ( is ,:, 0 ) = 1.0 do ipar = 0 , npar yy =- 1.d0 + ipar * ( 2.d0 / npar ) polynomials ( is , ipar , 1 ) = yy do n = 2 , poly_order ( is ) polynomials ( is , ipar , n ) = & 2.0 * yy * polynomials ( is , ipar , n - 1 ) - polynomials ( is , ipar , n - 2 ) end do enddo case default call alps_error ( 10 ) end select end subroutine set_polynomial_basis subroutine output_fit ( qualitytotal ) !! This subroutine outputs the fit parameters for iperp=0 to stdout to monitor the fit. use alps_io , only : isnancheck , alps_error use alps_var , only : fit_type , param_fit , n_fits , nspec , nperp , npar , pp , f0 , pi , vA , runname use alps_var , only : relativistic , gamma_rel , pparbar_rel , ngamma , npparbar , f0_rel , ms , usebM use alps_var , only : ACmethod use alps_var , only : ns , qs , ms , bMpdrifts use alps_var , only : density_int , current_int , poly_order implicit none double precision , intent ( in ) :: qualitytotal !! Quality of the total fit result. integer :: is !! Index of species. integer :: ifit !! Index for the fits that add up to the total fit for a given species. integer :: n_params !! Total number of fit parameters for a given species. integer :: iparam !! Variable running over fit parameters. integer :: unit_spec !! Unit to write fit results to file. integer :: ipar !! Index of parallel momentum. integer :: iperp !! Index of perpendicular momentum. integer :: is_rel !! Index for relativistic species (if any). integer :: sproc_rel !! Local process index for relativistic calculation. integer :: igamma !! Index of gamma (relativistic). integer :: ipparbar !! Index of pparbar (relativistic). integer :: is_run !! Index for relativistic species (if any). double precision :: integrate !! Integration of fit result. double precision , dimension ( 0 : nspec ) :: charge !! Charge Density of species. !! Zeroth index is sum over all species double precision , dimension ( 0 : nspec ) :: current !! Current Density of species. !! Zeroth index is sum over all species. double precision :: dpperp !! Step size in pperp for integration of fit result. double precision :: dppar !! Step size in ppar for integration of fit result. double precision :: dgamma_rel !! Step size in gamma for integration of relativistic fit result. double precision :: dpparbar !! Step size in pparbar for integration of relativistic fit result. double complex :: ppar_comp !! Complex parallel momentum to evaluate fit function at. character ( 10 ) :: specwrite !! File name to write fit results to file. write ( * , '(a)' ) ' Results of the fit for hybrid analytic continuation at iperp = 1:' do is = 1 , nspec select case ( ACmethod ( is )) case ( 1 ) do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) n_params = 3 if ( fit_type ( is , ifit ). EQ . 2 ) n_params = 5 if ( fit_type ( is , ifit ). EQ . 3 ) n_params = 3 if ( fit_type ( is , ifit ). EQ . 4 ) n_params = 1 if ( fit_type ( is , ifit ). EQ . 5 ) n_params = 3 if ( fit_type ( is , ifit ). EQ . 6 ) n_params = 4 if (. not . usebM ( is )) then do iparam = 1 , n_params write ( * , '(a,i2,a,i2,a,i2,a,2es14.4)' ) '  param_fit(' , is , ', 1,' , iparam , ',' , ifit , ') = ' , param_fit ( is , 1 , iparam , ifit ) enddo write ( * , '(a)' ) ' ' endif enddo case ( 2 ) end select enddo write ( * , '(a,es14.4e3)' ) ' Sum of all least-squares: ' , qualitytotal write ( * , '(a,es14.4e3)' ) ' Standard error of the estimate: ' , sqrt ( qualitytotal / ( 1.d0 * ( nspec * nperp * npar ))) if ( isnancheck ( qualitytotal )) call alps_error ( 7 ) charge = 0.d0 current = 0.d0 write ( * , '(a)' ) ' Writing fit result to files' do is = 1 , nspec if ( usebM ( is )) then charge ( is ) = ns ( is ) * qs ( is ) current ( is ) = ns ( is ) * qs ( is ) * & bMpdrifts ( is ) / ms ( is ) write ( * , '(a)' )& '-=-=-=-=' write ( * , '(a,i3,a)' )& 'Bi-Maxwellian/cold-plasma Species ' , is , ':' write ( * , '(a, 2es14.4e3)' ) & ' Charge density:           ' , charge ( is ) write ( * , '(a, 2es14.4e3)' ) & ' Parallel current density: ' , current ( is ) else select case ( ACmethod ( is )) case ( 1 ) unit_spec = 2000 + is write ( specwrite , '(i0)' ) is open ( unit = unit_spec , file = 'distribution/' // trim ( runname ) // '.fit_result.' // trim ( specwrite ) // '.out' , status = 'replace' ) integrate = 0.d0 if ( relativistic ( is )) then ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo dgamma_rel = gamma_rel ( sproc_rel , 2 , 2 ) - gamma_rel ( sproc_rel , 1 , 2 ) dpparbar = pparbar_rel ( sproc_rel , 2 , 2 ) - pparbar_rel ( sproc_rel , 2 , 1 ) do igamma = 0 , ngamma do ipparbar = 0 , npparbar ppar_comp = pparbar_rel ( sproc_rel , igamma , ipparbar ) if ( f0_rel ( sproc_rel , igamma , ipparbar ). EQ . - 1.d0 ) then write ( unit_spec , * ) gamma_rel ( sproc_rel , igamma , ipparbar ), pparbar_rel ( sproc_rel , igamma , ipparbar ),& \"-1.0\" , abs ( - 1.d0 - f0_rel ( sproc_rel , igamma , ipparbar )) else write ( unit_spec , * ) gamma_rel ( sproc_rel , igamma , ipparbar ), pparbar_rel ( sproc_rel , igamma , ipparbar ),& real ( eval_fit ( is , igamma , ppar_comp )),& abs ( real ( eval_fit ( is , igamma , ppar_comp )) - f0_rel ( sproc_rel , igamma , ipparbar )) / f0_rel ( sproc_rel , igamma , ipparbar ) integrate = integrate + & gamma_rel ( is_rel , igamma , ipparbar ) * real ( eval_fit ( is , igamma , ppar_comp )) * & 2.d0 * pi * dgamma_rel * dpparbar * ( ms ( is ) / vA ) ** 3 charge ( is ) = charge ( is ) + & qs ( is ) * ns ( is ) * gamma_rel ( is_rel , igamma , ipparbar ) * real ( eval_fit ( is , igamma , ppar_comp )) * & 2.d0 * pi * dgamma_rel * dpparbar * ( ms ( is ) / vA ) ** 3 current ( is ) = current ( is ) + & ( ppar_comp / ms ( is )) * qs ( is ) * ns ( is ) * real ( eval_fit ( is , igamma , ppar_comp )) * & 2.d0 * pi * dgamma_rel * dpparbar * ( ms ( is ) / vA ) ** 3 endif enddo enddo else ! non-relativistic: dpperp = pp ( is , 2 , 2 , 1 ) - pp ( is , 1 , 2 , 1 ) dppar = pp ( is , 2 , 2 , 2 ) - pp ( is , 2 , 1 , 2 ) do iperp = 0 , nperp do ipar = 0 , npar ppar_comp = pp ( is , iperp , ipar , 2 ) write ( unit_spec , * ) pp ( is , iperp , ipar , 1 ), pp ( is , iperp , ipar , 2 ), real ( eval_fit ( is , iperp , ppar_comp )), & abs ( real ( eval_fit ( is , iperp , ppar_comp )) - f0 ( is , iperp , ipar )) / f0 ( is , iperp , ipar ) integrate = integrate + pp ( is , iperp , ipar , 1 ) * real ( eval_fit ( is , iperp , ppar_comp )) * & 2.d0 * pi * dpperp * dppar charge ( is ) = charge ( is ) + qs ( is ) * ns ( is ) * pp ( is , iperp , ipar , 1 ) * real ( eval_fit ( is , iperp , ppar_comp )) * & 2.d0 * pi * dpperp * dppar current ( is ) = current ( is ) + ( qs ( is ) * ns ( is ) / ms ( is )) * & pp ( is , iperp , ipar , 2 ) * pp ( is , iperp , ipar , 1 ) * real ( eval_fit ( is , iperp , ppar_comp )) * & 2.d0 * pi * dpperp * dppar enddo enddo endif close ( unit_spec ) write ( * , '(a)' )& '-=-=-=-=' write ( * , '(a,i3,a)' )& 'Species ' , is , ':' write ( * , '(a, 2es14.4e3)' ) & ' Integration of fit/analytical function:              ' , integrate write ( * , '(a, 2es14.4e3)' ) & ' Charge density of fit/analytical function:           ' , charge ( is ) write ( * , '(a, 2es14.4e3)' ) & ' Parallel current density of fit/analytical function: ' , current ( is ) case ( 2 ) integrate = 0.d0 dpperp = pp ( is , 2 , 2 , 1 ) - pp ( is , 1 , 2 , 1 ) dppar = pp ( is , 2 , 2 , 2 ) - pp ( is , 2 , 1 , 2 ) unit_spec = 2000 + is write ( specwrite , '(i0)' ) is open ( unit = unit_spec , file = 'distribution/' // trim ( runname ) // '.poly_fit_result.' // trim ( specwrite ) // '.out' , status = 'replace' ) write ( * , '(a,i0)' ) ' Writing GLLS fit result to files: ispec' , is do iperp = 0 , nperp do ipar = 0 , npar ppar_comp = pp ( is , iperp , ipar , 2 ) if ( f0 ( is , iperp , ipar ). gt . 0.d0 ) then write ( unit_spec , * ) pp ( is , iperp , ipar , 1 ), pp ( is , iperp , ipar , 2 ), & real ( eval_fit ( is , iperp , ppar_comp )), & abs ( real ( eval_fit ( is , iperp , ppar_comp )) - f0 ( is , iperp , ipar )) / f0 ( is , iperp , ipar ) else write ( unit_spec , * ) pp ( is , iperp , ipar , 1 ), pp ( is , iperp , ipar , 2 ), & real ( eval_fit ( is , iperp , ppar_comp )), & 0.d0 endif integrate = integrate + pp ( is , iperp , ipar , 1 ) * real ( eval_fit ( is , iperp , ppar_comp )) * & 2.d0 * pi * dpperp * dppar charge ( is ) = charge ( is ) + qs ( is ) * ns ( is ) * pp ( is , iperp , ipar , 1 ) * real ( eval_fit ( is , iperp , ppar_comp )) * & 2.d0 * pi * dpperp * dppar current ( is ) = current ( is ) + ( qs ( is ) * ns ( is ) / ms ( is )) * & pp ( is , iperp , ipar , 2 ) * pp ( is , iperp , ipar , 1 ) * real ( eval_fit ( is , iperp , ppar_comp )) * & 2.d0 * pi * dpperp * dppar enddo enddo close ( unit_spec ) write ( * , '(a)' )& '-=-=-=-=' write ( * , '(a,i3,a)' )& 'Species ' , is , ':' write ( * , '(a, 2es14.4)' ) & ' Integration of polynomial representation:              ' , integrate write ( * , '(a, i0, es14.4)' ) & ' Relative Percent Difference in density for Order:' , poly_order ( is ), & 2.d0 * ( abs ( density_int ( is )) - abs ( integrate )) / ( abs ( density_int ( is )) + abs ( integrate )) write ( * , '(a, 2es14.4)' ) & ' Charge density of polynomial representation:           ' , charge ( is ) if ( relativistic ( is )) then write ( * , '(a)' ) 'Relativistic parallel current density not yet implemented!' else write ( * , '(a, es14.4)' ) & ' Parallel current density of polynomial representation: ' , current ( is ) write ( * , '(a, i0, es14.4)' ) & ' Relative Percent Difference in current density for Order:' , poly_order ( is ), & 2.d0 * ( abs ( current ( is )) - abs ( current_int ( is ))) / ( abs ( current_int ( is )) + abs ( current ( is ))) endif end select endif enddo write ( * , '(a)' ) '-=-=-=-=' write ( * , '(a, es14.4e3)' ) ' Total charge density of fit/analytical function:           ' , sum ( charge ( 1 : nspec )) write ( * , '(a, es14.4e3)' ) ' Total parallel current density of fit/analytical function: ' , sum ( current ( 1 : nspec )) write ( * , '(a)' ) '-=-=-=-=-=-=-=-=' end subroutine output_fit subroutine determine_JT ( is , n_params , nJT , JT , params , iperp , upper_limit , ipparbar_lower ) !! This subroutine calculates the transposed Jacobian matrix of the fit function with respect to the !! fit parameter array. use alps_var , only : fit_type , n_fits , pp , ms , vA , perp_correction use alps_var , only : gamma_rel , pparbar_rel , nspec , relativistic implicit none integer , intent ( in ) :: is !! Index of species for which [[determine_JT]] is executed. integer , intent ( in ) :: n_params !! Total number of fit parameters for a given species. integer , intent ( in ) :: nJT !! First dimension of matrix JT. integer , intent ( in ) :: upper_limit !! Upper limit of iperp space (relativistic and non-relativistic). double precision , intent ( out ) :: JT ( nJT , 0 : upper_limit ) !! Transposed Jacobian matrix of the fit function. double precision , intent ( in ) :: params ( n_params ) !! Array of fit parameters. integer , intent ( in ) :: iperp !! Index of perpendicular momentum at which JT is evaluated. integer , intent ( in ) :: ipparbar_lower !! Lower index of parallel momentum (relativistic). integer :: ifit !! Index for the fits that add up to the total fit for a given species. integer :: par_ind !! Parameter index to loop over fits. integer :: ipar !! Index of parallel momentum. integer :: is_rel !! Index for relativistic species (if any). integer :: sproc_rel !! Local process index for relativistic calculation. integer :: is_run !! Index for relativistic species (if any). integer :: JT_ind !! Index running over [[JT]] double precision :: ppar_val !! Parallel momentum. double precision :: pperp_val !! Perpendicular momentum. double precision :: sqrtpart !! Square-root part of Juettner distribution. double precision :: expterm !! Exponential part of the Maxwellian distribution. double precision :: kappapart !! Kappa part of the kappa distribution. if ( relativistic ( is )) then ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo endif do ipar = 0 , upper_limit if ( relativistic ( is )) then pperp_val = gamma_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) ppar_val = pparbar_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) else pperp_val = pp ( is , iperp , ipar , 1 ) ppar_val = pp ( is , iperp , ipar , 2 ) endif par_ind = 0 JT_ind = 0 do ifit = 1 , n_fits ( is ) if ( fit_type ( is , ifit ). EQ . 1 ) then ! Maxwell expterm = exp ( - params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 & - perp_correction ( is , ifit ) * pperp_val ** 2 ) JT ( ifit + JT_ind + 0 , ipar ) = expterm JT ( ifit + JT_ind + 1 , ipar ) =- (( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) * params ( ifit + par_ind + 0 ) * expterm JT ( ifit + JT_ind + 2 , ipar ) = 2.d0 * params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) * & params ( ifit + par_ind + 0 ) * expterm par_ind = par_ind + 2 JT_ind = JT_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 2 ) then ! kappa kappapart = 1.d0 + params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 & + perp_correction ( is , ifit ) * params ( ifit + par_ind + 4 ) * pperp_val ** 2 JT ( ifit + JT_ind + 0 , ipar ) = kappapart ** params ( ifit + par_ind + 3 ) JT ( ifit + JT_ind + 1 , ipar ) = params ( ifit + par_ind + 0 ) * params ( ifit + par_ind + 3 ) * kappapart ** ( params ( ifit + par_ind + 3 ) - 1.d0 ) * & ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 JT ( ifit + JT_ind + 2 , ipar ) = params ( ifit + par_ind + 0 ) * params ( ifit + par_ind + 3 ) * kappapart ** ( params ( ifit + par_ind + 3 ) - 1.d0 ) * & 2.d0 * params ( ifit + par_ind + 1 ) * ( params ( ifit + par_ind + 2 ) - ppar_val ) JT ( ifit + JT_ind + 3 , ipar ) = log ( kappapart ) * params ( ifit + par_ind + 0 ) * kappapart ** params ( ifit + par_ind + 3 ) if ( iperp . EQ . 0 ) then JT_ind = JT_ind + 3 else JT ( ifit + JT_ind + 4 , ipar ) = params ( ifit + par_ind + 0 ) * params ( ifit + par_ind + 3 ) * & kappapart ** ( params ( ifit + par_ind + 3 ) - 1.d0 ) * perp_correction ( is , ifit ) * pperp_val ** 2 JT_ind = JT_ind + 4 endif par_ind = par_ind + 4 endif if ( fit_type ( is , ifit ). EQ . 3 ) then ! Juettner with pperp and ppar sqrtpart = sqrt ( 1.d0 + ( pperp_val ** 2 + ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) * vA * vA / ( ms ( is ) * ms ( is ))) JT ( ifit + JT_ind + 0 , ipar ) = exp ( - params ( ifit + par_ind + 1 ) * sqrtpart ) JT ( ifit + JT_ind + 1 , ipar ) =- params ( ifit + par_ind + 0 ) * exp ( - params ( ifit + par_ind + 1 ) * sqrtpart ) * sqrtpart JT ( ifit + JT_ind + 2 , ipar ) = params ( ifit + par_ind + 0 ) * exp ( - params ( ifit + par_ind + 1 ) * sqrtpart ) * & ( params ( ifit + par_ind + 1 ) / sqrtpart ) * ( ppar_val - params ( ifit + par_ind + 2 )) * vA * vA / ( ms ( is ) * ms ( is )) par_ind = par_ind + 2 JT_ind = JT_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 4 ) then ! Juettner with gamma and pparbar, constant in pparbar JT ( ifit + JT_ind + 0 , ipar ) = exp ( - perp_correction ( is , ifit ) * pperp_val ) par_ind = par_ind + 0 JT_ind = JT_ind + 0 endif if ( fit_type ( is , ifit ). EQ . 5 ) then ! Juettner with gamma and pparbar with pparbar-dependence expterm = exp ( - params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) * & exp ( - perp_correction ( is , ifit ) * pperp_val ) JT ( ifit + JT_ind + 0 , ipar ) = expterm JT ( ifit + JT_ind + 1 , ipar ) =- params ( ifit + par_ind + 0 ) * expterm * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 JT ( ifit + JT_ind + 2 , ipar ) = 2.d0 * params ( ifit + par_ind + 0 ) * ( ppar_val - params ( ifit + par_ind + 2 )) * & params ( ifit + par_ind + 1 ) * expterm par_ind = par_ind + 2 JT_ind = JT_ind + 2 endif if ( fit_type ( is , ifit ). EQ . 6 ) then ! bi-Moyal expterm = exp ( 0.5d0 * ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 - & exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) )) JT ( ifit + JT_ind + 0 , ipar ) = expterm JT ( ifit + JT_ind + 1 , ipar ) = params ( ifit + par_ind + 0 ) * expterm * 0.5d0 * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 * & ( 1.d0 - exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) ) JT ( ifit + JT_ind + 2 , ipar ) = params ( ifit + par_ind + 0 ) * expterm * params ( ifit + par_ind + 1 ) * & ( params ( ifit + par_ind + 2 ) - ppar_val ) * & ( 1.d0 - exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) ) if ( iperp . EQ . 0 ) then JT_ind = JT_ind + 2 else JT ( ifit + JT_ind + 3 , ipar ) = params ( ifit + par_ind + 0 ) * expterm * 0.5d0 * perp_correction ( is , ifit ) * pperp_val ** 2 * & ( 1.d0 - exp ( params ( ifit + par_ind + 3 ) * perp_correction ( is , ifit ) * pperp_val ** 2 + & params ( ifit + par_ind + 1 ) * ( ppar_val - params ( ifit + par_ind + 2 )) ** 2 ) ) JT_ind = JT_ind + 3 endif par_ind = par_ind + 3 endif enddo enddo end subroutine subroutine LM_nonlinear_fit ( is , g , n_params , nJT , params , param_mask , iperp , npar , ipparbar_lower , quality ) !! This subroutine processes the nonlinear Levenberg-Marquart algorithm and returns !! the one-dimensional array params at a given iperp. !! The variable quality is the sum of the squares of all residuals. use alps_var , only : lambda_initial_fit , pp , lambdafac_fit , logfit use alps_var , only : epsilon_fit , maxsteps_fit use alps_var , only : gamma_rel , pparbar_rel , relativistic , nspec use alps_io , only : alps_error use mpi implicit none integer , intent ( in ) :: is !! Index of species for which [[LM_nonlinear_fit]] is executed. double precision , intent ( in ) :: g ( 0 : npar ) !! Array of function to be fitted. integer , intent ( in ) :: n_params !! Total number of fit parameters for a given species. integer , intent ( in ) :: nJT !! First dimension of matrix JT (see [[determine_JT(subroutine)]]). double precision , intent ( inout ) :: params ( n_params ) !! Array of fit parameters. logical , intent ( in ) :: param_mask ( n_params ) !! Bit mask for required fit parameters. integer , intent ( in ) :: iperp !! Index of perpendicular momentum. integer , intent ( in ) :: npar !! Number of steps in parallel momentum integer , intent ( in ) :: ipparbar_lower !! Lower index of parallel momentum (relativistic). double precision , intent ( out ) :: quality !! Quality of the individual fit result. logical :: converged !! Check whether fit has converged. integer :: ipar !! Index running over parallel momentum. integer :: k !! Index running over entries of [[JT]]. integer :: counter !! Count of fit iterations. integer :: is_rel !! Index for relativistic species (if any). integer :: is_run !! Index for relativistic species (if any). integer :: sproc_rel !! Local process index for relativistic calculation. integer :: l !! Index running over the delta's in the L-M fit. integer :: ipiv ( nJT ) !! Integer array required for matrix inversion. integer :: info !! Integer required for matrix inversion. double precision :: LSQ !! Least squares for L-M fit. double precision :: LSQnew !! Next iteration of least squares for L-M fit. double precision :: lambda_fit !! Lambda in L-M fit. double precision :: pperp_val !! Perpendicular momentum. double precision :: ppar_val !! Parallel momentum. double precision :: residuals ( 0 : npar ) !! Array of residuals. double precision :: deltaparam_fit ( nJT ) !! delta's in the L-M fit. double precision :: JTJ ( nJT , nJT ) !! Matrix product of JT and J. double precision :: JT ( nJT , 0 : npar ) !! Transposed Jacobian matrix of the fit function. double precision :: diagmat ( nJT , nJT ) !! Diagonal matrix of JT. double precision :: Amat ( nJT , nJT ) !! Matrix to be inverted. double precision :: work_array ( nJT ) !! Work array for matrix inversion. converged = . FALSE . counter = 0 lambda_fit = lambda_initial_fit if (( 1 + npar ). LT . n_params ) call alps_error ( 2 ) if ( relativistic ( is )) then ! Determine your sproc_rel: is_rel = 0 do is_run = 1 , nspec if ( relativistic ( is_run )) then is_rel = is_rel + 1 if ( is_run . EQ . is ) sproc_rel = is_rel endif enddo endif do while (. NOT . converged ) counter = counter + 1 LSQ = 0.d0 ! Determine the transposed Jacobian and the residuals: call determine_JT ( is , n_params , nJT , JT , params , iperp , npar , ipparbar_lower ) do ipar = 0 , npar if ( relativistic ( is )) then pperp_val = gamma_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) ppar_val = pparbar_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) else pperp_val = pp ( is , iperp , ipar , 1 ) ppar_val = pp ( is , iperp , ipar , 2 ) endif if ( logfit ( is )) then do k = 1 , nJT JT ( k , ipar ) = JT ( k , ipar ) / fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 ))) enddo residuals ( ipar ) = g ( ipar ) - log ( real ( fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 ))))) else residuals ( ipar ) = g ( ipar ) - real ( fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 )))) endif ! Least squares: LSQ = LSQ + residuals ( ipar ) * residuals ( ipar ) enddo JTJ = matmul ( JT , transpose ( JT )) diagmat = 0.d0 do k = 1 , nJT diagmat ( k , k ) = JTJ ( k , k ) enddo Amat = JTJ + lambda_fit * diagmat ! The following routine is from LAPACK to invert the matrix: call dgetrf ( nJT , nJT , Amat , nJT , ipiv , info ) if ( info . NE . 0 ) stop \"Fit matrix is numerically singular.\" call dgetri ( nJT , Amat , nJT , ipiv , work_array , nJT , info ) if ( info . NE . 0 ) stop \"Fit matrix inversion failed.\" ! Now Amat is the inverse of JTJ+lambda_fit*diagmat deltaparam_fit = matmul ( Amat , matmul ( JT , residuals )) l = 0 do k = 1 , n_params if ( param_mask ( k )) then l = l + 1 params ( k ) = params ( k ) + deltaparam_fit ( l ) endif enddo ! With the new param_fit, what is the new mean square error: LSQnew = 0.d0 do ipar = 0 , npar if ( relativistic ( is )) then pperp_val = gamma_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) ppar_val = pparbar_rel ( sproc_rel , iperp , ipar + ipparbar_lower ) else pperp_val = pp ( is , iperp , ipar , 1 ) ppar_val = pp ( is , iperp , ipar , 2 ) endif if ( logfit ( is )) then residuals ( ipar ) = g ( ipar ) - log ( real ( fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 ))))) else residuals ( ipar ) = g ( ipar ) - real ( fit_function ( is , n_params , params , pperp_val , cmplx ( ppar_val , 0.d0 , kind ( 1.d0 )))) endif ! Least squares: LSQnew = LSQnew + residuals ( ipar ) * residuals ( ipar ) enddo if ( LSQnew . GT . LSQ ) then l = 0 do k = 1 , n_params if ( param_mask ( k )) then l = l + 1 params ( k ) = params ( k ) - deltaparam_fit ( l ) endif enddo lambda_fit = lambda_fit * lambdafac_fit else lambda_fit = lambda_fit / lambdafac_fit endif ! Check if it converged (we can add further break criteria): if ( abs ( LSQnew - LSQ ). LT . epsilon_fit ) converged = . TRUE . if ( counter . EQ . maxsteps_fit ) converged = . TRUE . enddo quality = LSQ end subroutine LM_nonlinear_fit integer function factorial ( n ) implicit none integer , intent ( in ) :: n integer :: i , Ans Ans = 1 do i = 1 , n Ans = Ans * i enddo Factorial = Ans end function factorial end module alps_analyt","tags":"","url":"sourcefile/alps_analyt.f90.html"},{"title":"Readme – ALPS","text":"ALPS: The Arbitrary Linear Plasma Solver This is the ALPS code: the Arbitrary Linear Plasma Solver. Authors Kristopher Klein   (kgklein@arizona.edu) Daniel Verscharen  (d.verscharen@ucl.ac.uk) Contents What is ALPS? Acknowledgements Installing the ALPS Code Running the ALPS Code License 1. What is ALPS? ALPS is a parallelised numerical code that solves the Vlasov-Maxwell dispersion\nrelation in hot (even relativistic) magnetised plasma. ALPS allows for any\nnumber of particle species with arbitrary gyrotropic background distribution\nfunctions supporting waves with any direction of propagation with respect to\nthe background magnetic field. If you use the code for a science publication, please provide the code website github.com/danielver02/ALPS in the acknowledgements, cite the DOI of the code: @software { alps_2023_8075682 , author = {{ Klein } , K . G . and { Verscharen } , D . and { Koskela } , T . and { Stansby } , D . } , title = { danielver02 / ALPS : Zenodo release } , month = jun , year = 2023 , publisher = { Zenodo } , version = { v1 .0.1 } , doi = { 10.5281 / zenodo .8075682 } , url = { https : // doi . org / 10.5281 / zenodo .8075682 } } and cite the code paper: Verscharen, D., Klein, K. G., Chandran, B. D. G., Stevens, M. L., Salem, C. S.,\nand Bale, S. D.: ALPS: the Arbitrary Linear Plasma Solver, J. Plasma Phys. 84,\n905840403, 2018, doi: 10.1017/S0022377818000739 The documentation of the code can be found on alps.space . Details on updates to the code can be found in: Klein, K. G. and Verscharen, D.: The Dielectric Response of Plasmas with Arbitrary Gyrotropic Velocity Distributions, Phys. Plasmas 32, 092104, 2025, doi: 10.1063/5.0286477 2. Acknowledgements The development of the ALPS code was supported by NASA Grant NNX16AG81G. The code developers appreciate support from the UK Science\nand Technology Facilities Council (STFC) Ernest Rutherford Fellowship ST/P003826/1,\nSTFC Consolidated Grants ST/S000240/1 and ST/W001004/1, and the Open Source\nSoftware Sustainability Funding programme from UCL's Advanced Research Computing\nCentre and UCL's eResearch Domain. We appreciate software engineering support by\nDavid Stansby and Tuomas Koskela from UCL. 3. Installing the ALPS code For advice on the installation of the code, please check INSTALL.md 4. Running the ALPS code ALPS works with input files that specify the plasma and numerical parameters for\nthe calculation. We recommend that you start by checking out the provided test\ncases as a guidance for the creation of input files. These test cases are listed\nin the scripts run_test.sh and run_test_suite.sh in the subfolder ./tests . All associated input files have\na name starting with test_ . You can execute the ALPS code through the following command: mpirun -np <NP> ./src/ALPS <input_file.in> where <NP> is the number of processors you want to use. This number must be greater\nthan or equal to 4, and it must be an even number. <input_file.in> is the input file\nthat includes all parameters for your run. On some systems, depending on the MPI configuration, the oversubscribe flag is\nrequired. In this case, the above command must be replaced with mpirun -np <NP> --oversubscribe ./src/ALPS <input_file.in> For first-time users, we recommend working through our ALPS Tutorial . The key input parameters for ALPS are described on the ALPS Input page. The output format of ALPS is described on the ALPS Output page. 5. License BSD 2-Clause License Copyright (c) 2023, Kristopher G. Klein and Daniel Verscharen\nAll rights reserved. Redistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","tags":"","url":"page/index.html"},{"title":"Installing ALPS – ALPS","text":"ALPS: The Arbitrary Linear Plasma Solver These are the install instructions for the ALPS code: the Arbitrary Linear\nPlasma Solver. Authors Kristopher Klein   (kgklein@arizona.edu)\nDaniel Verscharen  (d.verscharen@ucl.ac.uk) CONTENTS Requirements and Dependencies Setting up Computer Environments Getting the ALPS Code Installing the ALPS Code Execution of Test Runs REQUIREMENTS AND DEPENDENCIES ALPS has the following requirements: A UNIX, Linux, or macOS operating system with a working shell GNU make, in some cases it is useful to have the autoconf/automake tools Fortran 90 compiler (e.g., gfortran) - we recommend using the latest version\n  of the compiler to avoid any surprises in the evaluation. MPI (e.g., Open MPI or MPICH) - likewise, this should also be the latest version BLAS and LAPACK - these two libraries are used for the polyharmonic spline\n  interpolation in ALPS. They are directly linked during the compilation SETTING UP COMPUTER ENVIRONMENTS For Ubuntu and macOS users, the following instructions have proven to be useful.\nOn both systems, we recommend deactivating potential anaconda installations\nthat could interfere with the ALPS installation: conda deactivate On Ubuntu, the following installation routines obtain the necessary software\npackages for ALPS: sudo apt-get install -y libopenmpi-dev\nsudo apt-get install -y libopenblas-dev libblas-dev liblapack-dev If an older compiler or MPI version is still installed, it may be necessary to\ndeinstall this before using apt-get. On macOS, homebrew is a good way to install the necessary packages: brew install gcc open-mpi There have been reports about issues with Open MPI when used with certain compilers on macOS. In that case, it is worth trying MPICH instead of Open MPI: brew unlink open - mpi brew install mpich GETTING THE ALPS CODE We recommend pulling the latest version of ALPS from GitHub. For this, go to\nthe directory where you want to install ALPS and execute the following command: git clone https://github.com/danielver02/ALPS Alternatively, you can also go to the website https://github.com/danielver02/ALPS\ndirectly and download the source code from there. The advantage of using the git\ncommand is that you can now contribute to the development of the ALPS code. If\nyou make any changes to the code, GitHub will run automatic tests (via workflows)\nto ensure that the changes do not break the code. INSTALLING THE ALPS CODE If all requirements are available, the code can be compiled with the following\ncommands: . / configure make sudo make install ( this option is only required if you want to make the ALPS executable available to all users ) The Makefile.in in the repository has been generated with automake from Makefile.am . If you have a different version of automake , make may fail. In that case, start again with autoreconf -i -f before the execution of ./configure . If you want to use a different version of the BLAS or LAPACK libraries, you can specify this with the options --with-blas and --with-lapack . For example, if you want to use Intel MKL instead: ./configure --with-blas=\"-lmkl_rt\" --with-lapack=\"-lmkl_rt\" EXECUTION OF TEST RUNS ALPS comes with a selection of test runs that cycle through various test\nproblems. To execute a small set of tests, execute the following shell script: ./run_test.sh This script will test the interpolation routine, the routine to generate pre-\ndescribed distribution functions, and a simply fast dispersion relation. To execute a more complete set of test problems, execute the following shell\nscript: ./run_test_suite.sh This script will test the interpolation routine and then a number of ALPS test\ncases, including the generation of the relevant distribution functions. The test\nroutine outputs time stamps during each steps to compare the speed of the ALPS\ncode and to facilitate scaling tests. For each test, the script will explain\nwhether errors occurred or not in any of the tests. The code output itself will\nbe piped into the .out and .error files in the home directory. For advice on running ALPS, please see the README file. Building the documentation ALPS uses Ford to build its documentation. The documentation is automatically built and deployed to github.io by the doc workflow . To build the documentation locally, follow the Build documentation step in the workflow, summarized here:\n1. Install ford by e.g. pip install ford . See Ford documentation for details\n2. Create a docs directory by mkdir docs 3. Add a line title: Readme to the top of README.md and copy it to docs/index.md 4. Add a line title: Install to the top of INSTALL.md and copy it to docs/INSTALL.md 5. Run ford ford_project.md 6. Open docs/index.html in a browser to view the documentation Adding static pages to documentation The README.md and INSTALL.md files are added to the Ford documentation as static pages. You can add more static pages to the documentation by\n1. Add the content in a markdown file to the repository.\n2. Add a title: line to the beginning of the file and copy it to docs/ in the doc workflow . See steps 3-4 in the previous section, or the Build documentation step in the workflow.\n3. Add the name of the markdown file as a new line under ordered_subpage in ford_project.md","tags":"","url":"page/INSTALL.html"},{"title":"Papers citing ALPS – ALPS","text":"Papers citing ALPS 2025 Bharati Das, S., & Terres, M., Recovering Ion Distribution Functions. I. Slepian Reconstruction of Velocity Distribution Functions from MMS and Solar Orbiter , The Astrophysical Journal 982, 96, 2025, 10.3847/1538-4357/adb6a0 Fitzmaurice, A., Drake, J. F., & Swisdak, M., Ion beam instabilities during solar flare energy release , Physics of Plasmas 32, 042114, 2025, 10.1063/5.0260878 Klein, K. G., & Verscharen, D., The dielectric response of plasmas with arbitrary gyrotropic velocity distributions , Physics of Plasmas 32, 092104, 2025, 10.1063/5.0286477 Martinović, M. M., Klein, K. G., et al., Impact of Two-population α-particle Distributions on Plasma Stability , The Astrophysical Journal 988, L25, 2025, 10.3847/2041-8213/adeaac Micera, A., Verscharen, D., et al., Quasi-parallel Antisunward-propagating Whistler Waves Associated with the Electron Deficit in the Near-Sun Solar Wind: Particle-in-cell Simulation , The Astrophysical Journal 979, 226, 2025, 10.3847/1538-4357/ada3d7 Sadykov, V. M., Ofman, L., et al., Identification of Ion-kinetic Instabilities in Hybrid-PIC Simulations of Solar Wind Plasma with Machine Learning , The Astrophysical Journal Supplement Series 279, 28, 2025, 10.3847/1538-4365/addd07 Schröder, D. L., Fichtner, H., et al., Temperature anisotropy instabilities of solar wind electrons with regularized kappa-halos resolved with ALPS , Physics of Plasmas 32, 032109, 2025, 10.1063/5.0254526 Schröder, D. L., Lazar, M., et al., Heat-flux Instabilities of Regularized Kappa Distributed Strahl Electrons Resolved with ALPS , The Astrophysical Journal 987, 110, 2025, 10.3847/1538-4357/ade0c0 Xie, H., Efficient framework for solving plasma waves with arbitrary distributions , Physics of Plasmas 32, 060702, 2025, 10.1063/5.0275307 Zhang, M. F., Kunz, M. W., et al., Extreme Heating of Minor Ions in Imbalanced Solar-wind Turbulence , The Astrophysical Journal 979, 121, 2025, 10.3847/1538-4357/ad95fc Zhao, L., Zank, G., & Li, H., Non-propagating structures and propagating waves in solar wind turbulence revealed by simulations and observations , Reviews of Modern Plasma Physics 9, 24, 2025, 10.1007/s41614-025-00200-y 2024 Afshari, A. S., Howes, G. G., et al., Direct observation of ion cyclotron damping of turbulence in Earth's magnetosheath plasma , Nature Communications 15, 7870, 2024, 10.1038/s41467-024-52125-8 Coburn, J. T., Verscharen, D., et al., The Regulation of the Solar Wind Electron Heat Flux by Wave–Particle Interactions , The Astrophysical Journal 964, 100, 2024, 10.3847/1538-4357/ad1329 Fitzmaurice, A., Drake, J. F., & Swisdak, M., Wave Generation by Flare-accelerated Ions and Implications for 3 He Acceleration , The Astrophysical Journal 964, 97, 2024, 10.3847/1538-4357/ad217f Jiang, W., Verscharen, D., et al., Velocity-space Signatures of Resonant Energy Transfer between Whistler Waves and Electrons in the Earth's Magnetosheath , The Astrophysical Journal 960, 30, 2024, 10.3847/1538-4357/ad0df8 Kocharovsky, V. V., Nechaev, A. A., & Garasev, M. A., Electron Weibel instability and quasi-magnetostatic structures in an expanding collisionless plasma , Reviews of Modern Plasma Physics 8, 17, 2024, 10.1007/s41614-024-00157-4 McManus, M. D., Klein, K. G., et al., Proton- and Alpha-driven Instabilities in an Ion Cyclotron Wave Event , The Astrophysical Journal 961, 142, 2024, 10.3847/1538-4357/ad05ba Mościbrodzka, M., & Gammie, C. F., Stochastic Averaging of Radiative Transfer Coefficients for Relativistic Electrons , The Astrophysical Journal 968, 6, 2024, 10.3847/1538-4357/ad4636 Yoon, P. H., López, R. A., et al., Quasi-linear Analysis of Proton-cyclotron Instability , The Astrophysical Journal 976, 173, 2024, 10.3847/1538-4357/ad86be 2023 Jeong, S.-Y., & Watt, C., The wave energy density and growth rate for the resonant instability in relativistic plasmas , Monthly Notices of the Royal Astronomical Society 521, 6170, 2023, 10.1093/mnras/stad934 Walters, J., Klein, K. G., et al., The Effects of Nonequilibrium Velocity Distributions on Alfvén Ion-cyclotron Waves in the Solar Wind , The Astrophysical Journal 955, 97, 2023, 10.3847/1538-4357/acf1fa 2022 Artekha, N. S., & Shklyar, D. R., Kinetic Description of a Whistler Wave Propagating in Plasma Along the Magnetic Field , Plasma Physics Reports 48, 754, 2022, 10.1134/S1063780X2260044X Jeong, S.-Y., Abraham, J. B., et al., The Stability of the Electron Strahl against the Oblique Fast-magnetosonic/Whistler Instability in the Inner Heliosphere , The Astrophysical Journal 926, L26, 2022, 10.3847/2041-8213/ac4dff Jiang, W., Verscharen, D., et al., Whistler Waves as a Signature of Converging Magnetic Holes in Space Plasmas , The Astrophysical Journal 935, 169, 2022, 10.3847/1538-4357/ac7ce2 Verscharen, D., Chandran, B. D. G., et al., Electron-Driven Instabilities in the Solar Wind , Frontiers in Astronomy and Space Sciences 9, 951628, 2022, 10.3389/fspas.2022.951628 2021 Klein, K. G., Verniero, J. L., et al., Inferred Linear Stability of Parker Solar Probe Observations Using One- and Two-component Proton Distributions , The Astrophysical Journal 909, 7, 2021, 10.3847/1538-4357/abd7a0 2020 Chapman, B., Dendy, R. O., et al., Comparing theory and simulation of ion cyclotron emission from energetic ion populations with spherical shell and ring-beam distributions in velocity-space , Plasma Physics and Controlled Fusion 62, 055003, 2020, 10.1088/1361-6587/ab7a3b Husidic, E., Lazar, M., et al., Linear dispersion theory of parallel electromagnetic modes for regularized Kappa-distributions , Physics of Plasmas 27, 042110, 2020, 10.1063/1.5145181 Verscharen, D., Parashar, T. N., et al., Dependence of kinetic plasma waves on ion-to-electron mass ratio and light-to-Alfvén speed ratio , Monthly Notices of the Royal Astronomical Society 494, 2905, 2020, 10.1093/mnras/staa977 Wilson, L. B., Chen, L.-J., et al., Electron Energy Partition across Interplanetary Shocks. III. Analysis , The Astrophysical Journal 893, 22, 2020, 10.3847/1538-4357/ab7d39 2019 Klein, K. G., Martinović, M., et al., Linear Stability in the Inner Heliosphere: Helios Re-evaluated , The Astrophysical Journal 887, 234, 2019, 10.3847/1538-4357/ab5802 Ley, F., Riquelme, M., et al., Stochastic Ion Acceleration by the Ion-cyclotron Instability in a Growing Magnetic Field , The Astrophysical Journal 880, 100, 2019, 10.3847/1538-4357/ab2592 Verscharen, D., Chandran, B. D. G., et al., Self-induced Scattering of Strahl Electrons in the Solar Wind , The Astrophysical Journal 886, 136, 2019, 10.3847/1538-4357/ab4c30 Verscharen, D., Klein, K. G., & Maruca, B. A., The multi-scale nature of the solar wind , Living Reviews in Solar Physics 16, 5, 2019, 10.1007/s41116-019-0021-0 Xie, H., A Unified Numerically Solvable Framework for Complicated Kinetic Plasma Dispersion Relations , arXiv e-prints , arXiv:1901.06902, 2019, 10.48550/arXiv.1901.06902 Xie, H.-. sheng ., BO: A unified tool for plasma waves and instabilities analysis , Computer Physics Communications 244, 343, 2019, 10.1016/j.cpc.2019.06.014 2018 Klein, K. G., Alterman, B. L., et al., Majority of Solar Wind Intervals Support Ion-Driven Instabilities , Physical Review Letters 120, 205102, 2018, 10.1103/PhysRevLett.120.205102 Verscharen, D., Klein, K. G., et al., ALPS: the Arbitrary Linear Plasma Solver , Journal of Plasma Physics 84, 905840403, 2018, 10.1017/S0022377818000739","tags":"","url":"page/citingpapers.html"},{"title":"ALPS Input – ALPS","text":"ALPS Input This is a reference for the key input parameters used by ALPS. Namelists in execution input files. The following namelists and associated input parameters are read in by ALPS from the input file. &system General system parameters. kperp Initial perpendicular wavevector $k_{\\perp} d_{ref}$. kpar Initial parallel wavevector $k_{\\parallel} d_{ref}$. nspec Number of plasma species. nroots Number of dispersion solutions to find and follow. use_map Choice of: True: Searching for roots over a map in complex frequency space (see &maps_1 namelist). False: Input nroots guesses for solutions (see &guess_1 namelist). writeOut Write or suppress output to screen. nperp Perpendicular momentum space resolution, $N_{\\perp}$.\nThe input file must have $N_{\\perp}+1$ values spanning parallel momentum space. npar Parallel momentum space resolution, $N_{\\parallel}$.\nThe input file must have $N_{\\parallel}+1$ values spanning parallel momentum space. ngamma Relativistic momentum space resolution, $N_{\\Gamma}$. npparbar Relativistic parallel momentum space resolution, $N_{\\bar{p}_{\\parallel}}$. vA Reference Alfven velocity, normalized to the speed of light, $v_{A,ref}/c$. arrayName Name of input array, located in 'distribution' folder. Bessel_zero Maximum amplitude of Bessel function to determine nmax . secant_method Selection for root finding method.\n0: secant method from NHDS\n1: rtsec method from PLUME\n2: Improved secant method to reduce oscillations around solutions. numiter Maximum number of iterations in secant method. kperp_norm Choice of: True: Follow's Stix (10-57) normalization convention. False: Multiplies Stix (10-57) by $k_{\\perp}&#94;2 d_{ref}&#94;2$. Depending on the user's choice of normalization, D_threshold needs to be adjusted to account for additional factors of $k_{\\perp}&#94;6 d_{ref}&#94;6$. D_threshold Minimum threshold for secant method. D_prec Size of bounding region for secant method. D_gap Size of allowable difference between roots. D_tol Tolerance for secant method = 1, rtsec. positions_principal Number of parallel momentum steps distant from the resonant momentum\nincluded in the numerical calculation of Eqn 3.5, $M_{I}$. n_resonance_interval How many steps should be used to integrate around the resonance,\n$M_{P}$, used for integrating near poles (see section 3.1). Tlim Threshold for analytical principal-value integration, $t_{\\mathrm{lim}}$. maxsteps_fit=500 Maximum number of fitting iterations. lambda_initial_fit Inital Levenberg-Marquardt damping parameter. lambdafac_fit Adjustment factor for Levenberg-Marquardt damping parameter. epsilon_fit Convergence for Levenberg-Marquardt fit. fit_check If true, output fitted functions for each species to file in distribution directory. determine_minima If true, after map search, determine minima and refine solutions. scan_option Select case for wavevector scans: 1: Consecutive scans along input paths in wavevector space, 2: Double scan over wavevector plane. n_scan Number of wavevector scans. 0 turns off wavevector scans. Must be 1 or larger for scan_option =1. Must be set to 2 for scan_option =2. &guess_m Initial guess of complex frequency for $m$th solution. Only used when use_map =.false. Need to have number of name lists equal to nroots . g_om Guess for real solution $\\omega_{r}/\\Omega_{ref} $. g_gam Guess for imaginary solution $\\gamma/\\Omega_{ref} $. &maps_1 Range of complex frequencies for map_scan subroutine. Only used when use_map =.true. loggridw Linear (F) or Log (T) spacing for $\\omega_{r}/\\Omega_{ref}$ map search.\nSpacing automatically calculated between omi and omf . loggridg Linear (F) or Log (T) spacing for $\\gamma/\\Omega_{ref}$ map search.\nSpacing automatically calculated between gami and gamf omi Smallest $\\omega_{r}/\\Omega_{ref}$ value for complex map search. omf Largest $\\omega_{r}/\\Omega_{ref}$ value for complex map search. gami Smallest $\\gamma/\\Omega_{ref}$ value for complex map search. gamf Largest $\\gamma/\\Omega_{ref}$ value for complex map search. ni Number of $\\gamma/\\Omega_{p}$ points in frequency grid. nr Number of $\\omega_{r}/\\Omega_{ref}$ points in frequency grid. &spec_j Species parameters list for distribution $f_{j}$.\nThe first species is set as the reference. nn Relative density $n_{j}/n_{ref}$. qq Relative charge $q_{j}/q_{ref}$. mm Relative mass $m_{j}/m_{ref}$. ff Number of fitted functions for analytical continuation calculation. relat Treat $f_{j}$ as non-relativistic or relativistic. log_fit Use linear or $\\log_{10}$ fitting routine. use_bM Use actual numerical integration (F) or bi-Maxwellian/cold-plasma proxy via NHDS routines,\nwith parameters read in from &bM_spec_j namelist. AC_method Choose the method for the evaluation of the analytic continuation: 0: Use the function that is defined analytically in distribution/distribution_analyt.f90 1: Use the fit routine as defined in the &ffit_j_k namelist. 2: Use a polynomial basis representation as defined in the &poly_spec_j namelist. This method should only be used if $|\\gamma|\\ll |\\omega_{r}|$. &ffit_j_k Initial Fit Values for species $j$, function $k$. fit_type_in Kind of fit function: 1: Maxwellian, 2: Kappa, 3: Juettner with $p_{\\perp},p_{\\parallel}$, 4: Juettner with variable $\\Gamma$, constant $\\bar{p}_{\\parallel}$, 5: Juettner with $p_{\\perp},p_{\\parallel}$; variable $\\bar{p}_{\\parallel}$, 6: Bi-Moyal distribution fit_1 - fit_5 Fit parameters, $u_{1}$ - $u_{5}$, defined in the above equations for each of the types of fit functions.\nNot all parameters will be used for all functions. Suggested values for parameters generated by generate_distribution. perpcorr This parameter, $y$ in Eqn. B1, compensates for the strong\n$p_{\\perp}$ dependence of $u_1$, making the fit more reliable. &bM_spec_j Bi-Maxwellian/cold-plasma parameters; for species j.\nOnly used if use_bM=T . bM_nmaxs Maximum number of resonances to consider. bM_Bessel Precision threshold for $I_n$. bM_betas $\\beta_{\\parallel,j}$ of bi-Maxwellian distribution $f_{j}$. If this variable is set to 0.d0, then the code will treat the given species with the susceptibility from cold-plasma theory. bM_alphas $T_{\\perp,j}/T_{\\parallel,j}$ of bi-Maxwellian distribution $f_{j}$. bM_pdrifts Relative drift of bi-Maxwellian distribution $f_{j}$ or the cold plasma species in units of $m_{ref} v_{A,ref}$. &poly_spec_j Input for the polynomial representation of the input distribution for the analytical continuation.\nOnly used if AC_method=2 . kind Type of the basis polynomial: 1: Chebychev order Maximum order of the basis polynomial. log_max When using logfit for the polynomial representation, set all output values to zero if the log(fit_function_poly) is greater than this variable. &scan_input_l Inputs for scanning parameter space for $l$th scan. scan_type Type of parameter scan: 0: Current value of $\\textbf{k}$ to $k_{\\perp}$= swi and $k_{\\parallel}$ = swf . 1: $\\theta_0 \\rightarrow \\theta_1$ at fixed $|k|$ from current value of $\\theta=\\mathrm{atan}(k_{\\perp}/k_{\\parallel})$ to swf . 2: Wavevector scan at fixed angle $\\theta_{k,B}$ to $|k|$ = swf . 3: $k_{\\perp}$ scan with constant $k_{\\parallel}$ to $k_{\\perp}$= swf . 4: $k_{\\parallel}$ scan with constant $k_{\\perp}$ to $k_{\\parallel}$= swf . swi Scan variable to define end of scan through wavevector space (only for scan_type=1 ). swf Scan variable to define end of scan through wavevector space. swlog Use $\\log_{10}$ (T) or linear (F) spacing. ns Number of output scan values. nres Resolution between output scan values. heating Calculates heating rates if true. eigen Calculates eigenfunctions if true. Namelists in distribution input files. The following namelists and associated input parameters are read in by the routine generate_distribution from input files. This generates nspec arrays of distributions that are read in by ALPS &system General system parameters. nspec Number of plasma species. beta Reference plasma beta. vA Reference Alfven velocity, normalized to the speed of light, $v_{A,ref}/c$. nperp Perpendicular momentum space resolution, $N_{\\perp}$.\nThe input file will have $N_{\\perp}+1$ values spanning parallel momentum space.\nSet the same values of nperp in both the distribution input file and ALPS execution input file. npar Parallel momentum space resolution, $N_{\\parallel}$.\nThe input file will have $N_{\\parallel}+1$ values spanning parallel momentum space.\nSet the same values of npar in both the distribution input file and ALPS execution input file. maxP Maximum value of reference Alfven momentum, $m_{ref} v_{A,ref}$. writeName Name of output arrays. &spec_j ms_read Mass ratio $m_j/m_{ref}$. taus Temperature ratio $T_{\\parallel,j}/T_{\\parallel,ref}$. alphs Temperature anisotropy $T_{\\perp,j}/T_{\\parallel,j}$. ps Normalized drift momentum $m_j v_{drift}/m_{ref} v_{A,ref}$. kappas $\\kappa$ index.\nOnly used if distribution =2. distributions Type of distribution: 0: Use distribution from distribution_analyt. 1: Bi-Maxwellian distribution. 2: Bi-Kappa distribution. 3: Anisotropic Juettner distribution. 4: Bi-Moyal distribution. autoscaleS If autoscaleS =.true., define maximum momentum for each array automatically using global value maxP . maxPperpS If autoscaleS =.false., force maximum perpendicular momentum for species array. maxPparS If autoscaleS =.false., force maximum parallel momentum for species array.","tags":"","url":"page/input.html"},{"title":"ALPS Output – ALPS","text":"ALPS Output ALPS writes output solutions to the /solution directory. All output file names start with the name of the input file used in running ALPS, e.g. mpirun -np 4 ./src/ALPS filename.in will produce output files all starting with the string filename . filename .map Value of the dispersion tensor $\\mathcal{D}(\\omega_{\\textrm{r}},\\gamma)$ on a defined complex frequency grid. Solutions to the dispersion relation satisfy $|\\mathcal{D}|  =0$.\nThis file is generated from the map_search subroutine in ALPS_fns.f90, and invoked when use_map =.true. . The data is ordered in columns as 1. $\\omega_r$ 2. $\\gamma$ 3. $\\log_{10} |\\mathcal{D}|$ 4. Re $[|\\mathcal{D}|]$ 5. Im $[|\\mathcal{D}|]$ The &maps_1 namelist in filename .in determines the structure of filename .map. The range of $\\omega_{\\textrm{r}}/\\Omega_{ref}$ is from omi to omi with nr steps. Logorithmic or linear spacing is selected with loggridw .\nThe range of $\\gamma_{\\textrm{r}}/\\Omega_{ref}$ is from gami to gami with ni steps. Logorithmic or linear spacing is selected with loggridg . filename .roots Identified solutions to the dispersion relation $|\\mathcal{D}|  =0$, calculated using refine_guess in ALPS_fns.f90 when determine_minima is set to true. The data is ordered as 1. Solution number\n2. $\\omega_r/\\Omega_{ref}$ 3. $\\gamma/Omega_{ref}$ 4. $\\log_{10} |\\mathcal{D}|$ 5. Re $[|\\mathcal{D}|]$ 6. Im $[|\\mathcal{D}|]$ The routine uses  either the coarse dispersion tensor map generated from the map_search subroutine (in the case of use_map = .true.) or from the input guesses (for use_map = .false.). Only the first nroots solutions will be identified and written to file. filename .scan_ scan_type_l .root_m The complex frequencies associated with solution m calculated from om_scan in the &scan_input_l namelist. The data is ordered as 1. $k_\\perp d_{ref}$\n2. $k_\\parallel d_{ref}$ 3. $\\omega_{\\textrm{r}}/\\Omega_{ref}$ 4. $\\gamma/\\Omega_{ref}$ See the &scan_input namelist description in the Quick Guide for details on determining the kind of wavevector scan. This same data structure is preserved for the output from om_double_scan . filename .eigen_ scan_type_l .root_m The eigenfunctions associated with solution m calculated from om_scan when eigen is set to .true.\nin the &scan_input_l namelist. The data is ordered as 1. $k_\\perp d_{ref}$\n2. $k_\\parallel d_{ref}$ 3. $\\omega_{\\textrm{r}}/\\Omega_{ref}$ 4. $\\gamma/\\Omega_{ref}$ 5. Re $[E_x]$ \n6. Im $[E_x]$ \n7. Re $[E_y]$ \n8. Im $[E_y]$ \n9. Re $[E_z]$ \n10. Im $[E_z]$ \n11. Re $[B_x]$ \n12. Im $[B_x]$ \n13. Re $[B_y]$ \n14. Im $[B_y]$ \n15. Re $[B_z]$ \n16. Im $[B_z]$ 17. [+6(is-1)] Re $[\\delta U_{x,is}]$ 18. [+6(is-1)] Im $[\\delta U_{x,is}]$ 19. [+6(is-1)] Re $[\\delta U_{y,is}]$ 20. [+6(is-1)] Im $[\\delta U_{y,is}]$ 21. [+6(is-1)] Re $[\\delta U_{z,is}]$ 22. [+6(is-1)] Im $[\\delta U_{z,is}]$ 17. [+6( nspec )+2(is-1)] Re $[\\delta n_{is}]$ 18. [+6( nspec )+2(is-1)] Im $[\\delta n_{is}]$ This same data structure is preserved for the output from om_double_scan . filename .heat_ scan_type_l .root_m The heating rates associated with solution m calculated from om_scan when heating is set to .true.\nin the &scan_input_l namelist. The data is ordered as 1. $k_\\perp d_{ref}$\n2. $k_\\parallel d_{ref}$ 3. $\\omega_{\\textrm{r}}/\\Omega_{ref}$ 4. $\\gamma/\\Omega_{ref}$ 5. [+(is-1)] $\\gamma_{is}/\\omega_{\\textrm{r}}$ This same data structure is preserved for the output from om_double_scan . filename .heat_mech scan_type_l .root_m The heating rates associated with Landau damping, Transit Time damping, and the $n=\\pm 1$ cyclotron resonance are computed following Huang et al 2024 JPP and expressed in Appendix C of Klein & Verscharen 2025 PoP . The values associated with solution m are calculated in the routine om_scan when heating is set to .true. in the &scan_input_l namelist. The Transit time damping terms given by the sum of $\\gamma_{is}&#94;{yy}/\\omega_{\\textrm{r}}$ and $\\gamma_{is}&#94;{yz}/\\omega_{\\textrm{r}}$.\nThe Landau damping terms by the sum of $\\gamma_{is}&#94;{zy}/\\omega_{\\textrm{r}}$ and $\\gamma_{is}&#94;{zz}/\\omega_{\\textrm{r}}$.\nUnlike Huang et al 2024 JPP, we separate the n=-1 and n=+1 terms.\nThese calculations are accurate in weak damping limit $\\gamma < \\omega_{\\textrm{r}}$. The data is ordered as 1. $k_\\perp d_{ref}$ \n2. $k_\\parallel d_{ref}$ 3. $\\omega_{\\textrm{r}}/\\Omega_{ref}$ 4. $\\gamma/\\Omega_{ref}$ 5. [+4(is-1)] $\\gamma_{is}&#94;{TTD}/\\omega_{\\textrm{r}}$ \n6. [+4(is-1)] $\\gamma_{is}&#94;{LD}/\\omega_{\\textrm{r}}$ \n7. [+4(is-1)] $\\gamma_{is}&#94;{n=+1}/\\omega_{\\textrm{r}}$ \n8. [+4(is-1)] $\\gamma_{is}&#94;{n=-1}/\\omega_{\\textrm{r}}$","tags":"","url":"page/output.html"},{"title":"ALPS Tutorial – ALPS","text":"ALPS Tutorial This is a tutorial for ALPS. It will guide you through the setting up of some basic input files, the running of the code, and the basic output. For more details, we refer to the ALPS Input page, the ALPS Output page, and the ALPS Documentation . Authors Kristopher Klein   (kgklein@arizona.edu) Daniel Verscharen  (d.verscharen@ucl.ac.uk) Contents Before getting started Installing ALPS Setting up input distributions Running ALPS on f0-tables Interpolation of input distributions Using analytical expressions for the background distribution Running bi-Maxwellian species Running cold-plasma species 1. Before getting started Before starting with the steps described in this tutorial, we recommend that you familiarise yourself with the code papers Verscharen, D., Klein, K. G., Chandran, B. D. G., Stevens, M. L., Salem, C. S.,\nand Bale, S. D.: ALPS: the Arbitrary Linear Plasma Solver, J. Plasma Phys. 84,\n905840403, 2018, doi: 10.1017/S0022377818000739 and Klein, K. G. and Verscharen, D.: The Dielectric Response of Plasmas with Arbitrary Gyrotropic Velocity Distributions, Phys. Plasmas 32, 092104, 2025, doi: 10.1063/5.0286477 You don't need to go through all details, but it is certainly helpful to know what ALPS does and doesn't calculate. The 2018 paper also explains the numerical techniques used in the code, and the ALPS Documentation often refers explicitly to equations and sections in the code paper. We also recommend checking the Readme file. For a listing of recommendations when using ALPS, see the ALPS Best Practices page. 2. Installing ALPS This tutorial assumes that you have a working copy of ALPS on your computer, including all the required dependencies. You can find the installation guide here . Make sure you have a version of ALPS that compiled completely without error messages after typing ./configure  \nmake 3. Setting up input distributions 3.1 The format of f0-tables ALPS calculates the linear Vlasov-Maxwell dispersion relation for a plasma with arbitrary background distribution functions $f_{0j}$. These input distributions are called f0-tables . All f0-tables for ALPS are stored in the folder ./distribution within the ALPS directory structure. The format of f0-tables is a simple ASCII table with three columns. The columns can be separated with tabs or spaces, but don't add empty lines in the file. The three columns have the following meanings: Perpendicular momentum $p_{\\perp}$ normalised to $m_{\\mathrm ref}v_{\\mathrm A}$ Parallel momentum $p_{\\parallel}$ normalised to $m_{\\mathrm ref}v_{\\mathrm A}$ Value of the background distribution function $f_{0j}$ at momentum $(p_{\\perp},p_{\\parallel})$ normalised to $(m_{\\mathrm ref}v_{\\mathrm A})&#94;{-3}$ In these definitions, $m_{\\mathrm ref}$ is the proton mass and $v_{\\mathrm A}$ is the proton Alfvén speed. The distribution function $f_{0j}$ must be normalised to one if integrated over cylindrical momentum space. 3.2 Generating f0-tables In most cases, you may want to use an f0-table generated from observations or numerical simulations. If you can create such a table directly in the ALPS format, that would be ideal. Simply store it in an ASCII file with the following format: dist_name.N.array where dist_name is the name that you want to give the distribution, and N is an integer number indicating the plasma species (e.g., 1 for protons, 2 for electrons). In some cases, you may need to interpolate distributions from an irregular momentum grid to a regular grid in the ALPS coordinates. ALPS comes with an interpolation routine, which is described further below . In other cases, you may want to create an f0-table based on a pre-defined function (e.g., Maxwellian, bi-Maxwellian, or $\\kappa$-distribution). For this tutorial, let's create a simple Maxwellian distribution and run this through ALPS. For this exercise, use your terminal to go into the ./distribution folder: cd ./distribution In the standard ALPS package, you'll find a number of input files to generate distributions. Let's open the file test_ICW_dist.in which includes all parameters needed to create Maxwellian f0-tables for the protons and for the electrons. The various parameters are explained in comments in this input file. Feel free to modify some of these parameters if you want to experiment with it a bit. In general, it's a good idea to use one of the test files as the basis to create new input files for your purposes. When a quantity has the index ref added to it, this refers to the reference species. For example, m_j/m_ref stands for the mass of the current species j in units of the mass of the reference species, which in the example case is the protons. Let's generate the distributions for this example. Simply execute the command ./generate_distribution test_ICW_dist.in The code now generates the following output: Species 1 Integration : 9.9958 E - 01 Norm : 5.9862 E - 02 pperp_max : 1.0392 E + 01 ppar_max : 6.0000 E + 00 Fit type : 1 ideal fit_1 : 5.9862 E - 02 ideal fit_2 : 1.0000 E + 00 ideal fit_3 : 0.0000 E + 00 ideal perpcorr : 3.3333 E - 01 ============================ Species 2 Integration : 9.9958 E - 01 Norm : 1.4128 E + 04 pperp_max : 1.4003 E - 01 ppar_max : 1.4003 E - 01 Fit type : 1 ideal fit_1 : 1.4128 E + 04 ideal fit_2 : 1.8360 E + 03 ideal fit_3 : 0.0000 E + 00 ideal perpcorr : 1.8360 E + 03 ============================ Species 1 corresponds to the protons, and species 2 corresponds to the electrons in this case. The output gives us some information about the integration and normalisation of $f_{0j}$ as well as some suggestions for the fit parameters ( ideal fit and ideal perpcorr ) that will become important later for the hybrid-analytic continuation. In addition to this output, the code has also created two files: test_ICW.1.array and test_ICW.2.array . These are the the two f0-tables, which now include the pre-defined Maxwellian distributions for the protons and electrons. Let's open the proton file test_ICW.1.array and have a look: 0.0000000000000000 - 6.0000000000000000 1.3885214326235464E-017 0.0000000000000000 - 5.9500000000000002 2.5237337794355358E-017 0.0000000000000000 - 5.9000000000000004 4.5641827072255333E-017 0.0000000000000000 - 5.8499999999999996 8.2131741067563143E-017 0.0000000000000000 - 5.7999999999999998 1.4705763083579771E-016 0.0000000000000000 - 5.7500000000000000 2.6199477385677698E-016 0.0000000000000000 - 5.7000000000000002 4.6443636702139106E-016 0.0000000000000000 - 5.6500000000000004 8.1919697073946868E-016 ... ... ... As discussed above, the first column is the normalised perpendicular momentum, the second column is the normalised parallel momentum, and the third column is the value of the distribution function. The file contains 29,161 lines, which is just the combination of all perpendicular and parallel momentum steps. These have been defined by the lines nperp=120  \nnpar=240 in the file test_ICW_dist.in . Actually, the number 29,161 corresponds to 121*241, which is greater than 120*240 due to the inner and outer boundaries of the integration space. The variables nperp and npar refer to the integration domain only, which is one step smaller in each dimension than the f0-table. This is an important point to consider when setting up f0-tables: If you have an f0-table of X-by-Y entries in momentum space, set nperp=X-1 and npar=Y-1 in ALPS. Also ensure that the perpendicular momentum grid begins at a momentum of zero. Now that we have two f0-tables in the correct format, let's run ALPS on these! 4. Running ALPS on f0-tables Like for the generation of the input distribution above, we will run one of the test input files for this tutorial to demonstrate the running of ALPS. You can find this test input in the folder ./tests within the ALPS directory structure. Assuming that your terminal is still in ./distribution , let's change directory to ./tests : cd ../tests The input file that we want to use is called test_ICW.in . The name of the input file doesn't need to be the same as the name of the f0-table files ( dist_name ), but it helps to use a consistent nomenclature. Let's open test_ICW.in . It includes all the parameters that ALPS needs to run. Like in the case of the file test_ICW_dist.in above, the input file is commented to help you understand the meaning of the parameters. For more details and a reference to all of the parameters, please have a look at our ALPS Input page. We focus on a few key entries here for now. First, it's important to give the code the correct nperp and npar values. They are defined in the same way as above. So, here is a reminder: If you have an f0-table of X-by-Y entries in momentum space, set nperp=X-1 and npar=Y-1 in ALPS. In the example file, we see that nperp=120 and npar=240 , which are the correct entries for our example. Further down, you find the line arrayName='test_ICW' This line defines the name of the f0-tables that ALPS will use. Since we tell ALPS to work with two species (from the line nspec=2 ), the code will look for two files ./distribution/test_ICW.1.array  \n./distribution/test_ICW.2.array which we had created earlier. If you scroll further down, you'll find the following block: !Initial guess of complex frequency for first solution !Only used when use_map=.false. !Need to have # of name lists equal to nroots & guess_1 g_om = 1 . 5508 d - 01 ! real frequency g_gam = - 1 . 3429 d - 05 ! imaginary frequency / This block defines the initial guess for the frequency that the code will use to search for solutions. By picking the appropriate guess, you can select which plasma mode the code should follow. Remember that all frequencies are normalised to the gyro-frequency of the protons. Further down, you can find definitions for the species. The first species is defined through the following: !Species parameters list; species 1 & spec_1 nn = 1 . d0 ! relative density ; n_j / n_ref qq = 1 . d0 ! relative charge ; q_j / q_ref mm = 1 . d0 ! relative mass ; m_j / m_ref ff = 1 !# of fits to be used . relat = F ! relativistic ( T ) or non - relativistic ( F ) species log_fit = T ! log ( T ) or linear ( F ) fit use_bM = F ! numerically integrate array ( F ) or use bi - Maxwellian ( T ) / !Initial Fit Values; species 1, function 1 & ffit_1_1 fit_type_in = 1 ! Kind of fit function ( see documentation ) fit_1 = 5 . 986 D - 2 ! Suggested values for parameters , fit_2 = 1 . d0 ! e . g . generated by generate_distribution fit_3 = 0 . d0 fit_4 = 0 . d0 fit_5 = 0 . d0 perpcorr = 3 . 33 D - 1 ! renormalization factor / You can recognise many of the parameters from our test_ICW_dist.in file, like the charge and the mass of the particle species The block &ffit_1_1 includes the fit parameters for the hybrid-analytic continuation. As you can see, this file includes the suggestions for the ideal fit that generate_distribution has given us earlier. The key point about the fit parameters is that, for all damped solutions, you want to find a good representation of the distribution function so that the Landau-contour integral is precise. The procedure is described in the code paper in Section 3.2. If you have any closed mathematical expression to use, you can also input this for the analytic continuation as described here . Once we are happy with the parameters in test_ICW.in , let's run ALPS. Depending on your MPI configuration, you can run the code directly with the following commands (it's best to go back into the main folder of the ALPS directory structure): cd ../\nmpirun -np 4 ./src/ALPS tests/test_ICW.in This command will run 4 instances of ALPS via MPI. Depending on your computer and the MPI setup, you may need to add the option --oversubscribe to ensure that 4 instances of MPI can actually be executed. The ALPS binary ( ./src/ALPS ) expectes only one command-line argument: the name of the input file to run on. The number of processes (in this case 4), must always be an even number greater than 2, even if your computer doesn't have four or more cores. In those cases, the --oversubscribe option is particularly important. In general, the code scales quite well, especially for calculations of the dispersion relation with many plasma species and high perpendicular wavenumbers (compared to the species gyro-radii). If everything was successful so far, you'll now start to get the ALPS standard output: =========================================================== I I I A L P S I I Arbitrary Linear Plasma Solver I I I I Version X . X I I I I Kristopher Klein ( kgklein @arizone . edu ) I I Daniel Verscharen ( d . verscharen @ucl . ac . uk ) I I I =========================================================== All processes are up and running . Reading from Input File : test_ICW GUESS ROUTINE : Intial Guess 1 : 1.5508E-001 - 1.3429E-005 SPECIES PARAMETERS : Species 1 : ns / nREF = 1.0000E+000 | qs / qREF = 1.0000E+000 | ms / mREF = 1.0000E+000 Number of fitted functions = 1 Relativistic effects = F Species 2 : ns / nREF = 1.0000E+000 | qs / qREF = - 1.0000E+000 | ms / mREF = 5.4466E-004 Number of fitted functions = 1 Relativistic effects = F -=-=-=-=-=-=-=-=- This output summarises a lot of the information that is useful. We recommend that you read this output carefully, or even that you pipe the output into a log file for later reference by using mpirun -np 4 ./src/ALPS tests/test_ICW.in > test_ICW.output & Further down in the ALPS standard output, you'll find lines similar to this: kperp : 1.0000 E - 003 kpar : 1.0275 E - 001 Root 1 converged after iteration 7 D ( 1.4337 E - 001 - 8.9137 E - 006 )= - 2.0138 E - 018 - 1.2447 E - 018 kperp : 1.0000 E - 003 kpar : 1.0557 E - 001 Root 1 converged after iteration 8 D ( 1.4729 E - 001 - 8.6524 E - 006 )= - 2.9371 E - 019 - 1.6792 E - 019 kperp : 1.0000 E - 003 kpar : 1.0846 E - 001 Root 1 converged after iteration 8 D ( 1.5132 E - 001 - 8.3974 E - 006 )= 3.8108 E - 018 2.4923 E - 018 kperp : 1.0000 E - 003 kpar : 1.1144 E - 001 Root 1 converged after iteration 8 D ( 1.5546 E - 001 - 8.1484 E - 006 )= - 4.8910 E - 018 - 3.1173 E - 018 These lines tell us that the code is actually now finding solutions, as it scans through the wavevector space. The scan options had been defined in test_ICW.in , and details on how this works are given in our ALPS Input page. When the code has finished, it has produced a number of output files, which you can find in the folder ./solution in the ALPS directory structure. Let's look at the file test_ICW.scan_kpara_1.root_1 . As the name suggests, this file contains the scan result for a scan along the parallel wavenumber $k_{\\parallel}$ for root number 1 (we only scan along one root in this example). The file has the following format: 1.0000E-003 1.0000E-001 1.4424E-001 - 1.0449E-005 1.0000E-003 1.0275E-001 1.4337E-001 - 8.9137E-006 1.0000E-003 1.0557E-001 1.4729E-001 - 8.6524E-006 1.0000E-003 1.0846E-001 1.5132E-001 - 8.3974E-006 1.0000E-003 1.1144E-001 1.5546E-001 - 8.1484E-006 ... ... ... ... The format of the columns is as follows: Wavenumber $k_{\\perp}$ perpendicular to the background magnetic field in units of $\\Omega_{\\mathrm ref}/v_{\\mathrm A}$ Wavenumber $k_{\\parallel}$ parallel to the background magnetic field in units of $\\Omega_{\\mathrm ref}/v_{\\mathrm A}$ Real part of the wave frequency $\\omega$ in units of $\\Omega_{\\mathrm ref}$ Imaginary part of the wave frequency $\\omega$ in units of $\\Omega_{\\mathrm ref}$ In these definitions, $\\Omega_{\\mathrm ref}$ is the gyro-frequency of the reference species, which is the first species listed in the input file. This is typically set to be the proton distribution. Congratulations! You have found the solutions to the Maxwellian example case for the ion-cyclotron wave. Now you can also experiment with the other test cases in the folders ./distribution and ./tests . The code also includes a full test suite which you can launch with cd ./tests  \n./run_test_suite.sh The given test cases cover a range of typical applications, so there should be good starting points for your purposes. The code also creates additional output files for the heating contributions and for the eigenfunctions of the solutions. The general output format of ALPS is described on our ALPS Output page. 5. Interpolation of input distributions In many cases, you may want to use an f0-table based on a data file that is not in the same format as the ALPS format (e.g., from spacecraft observations) or isn't equally spaced in momentum space as required by ALPS. For those cases, ALPS provides an interpolation routine, which you can find in the folder ./interpolation . The ALPS code also comes with a test case to illustrate the the use of the interpolation routine. We'll go through this example here. Let's have a look at the file test_interp_coarse.array . This file includes a table of the distribution function, but not in the format as needed by ALPS: 3.48994945E-04 9.99390800E-03 0.999899983 3.67403193E-03 9.30061750E-03 0.999899983 6.57521421E-03 7.53435818E-03 0.999899983 8.71784426E-03 4.89889691E-03 0.999899983 9.85473860E-03 1.69827254E-03 0.999899983 9.85473767E-03 - 1.69827335E-03 0.999899983 ... ... ... The overall format is the same as in the f0-table files above in terms of the meaning of the columns: Perpendicular momentum $p_{\\perp}$ normalised to $m_{\\mathrm ref}v_{\\mathrm A}$ Parallel momentum $p_{\\parallel}$ normalised to $m_{\\mathrm ref}v_{\\mathrm A}$ Value of the background distribution function $f_{0j}$ at momentum $(p_{\\perp},p_{\\parallel})$ normalised to $(m_{\\mathrm ref}v_{\\mathrm A})&#94;{-3}$ Now let's look at the input file test_interp.in for the interpolation routine. This file includes a number of comments to help you with the setting up of the interpolation parameters. The file asks the interpolation routine to take the irregular table from test_interp_coarse.array and to interpolate it onto a grid in the ALPS format with nperp=50 and npar=100 . If needed, the code can also re-normalise and scale the distribution function depending on your needs. Let's run the interpolation routine on the input file: ./interpolation test_interp.in If successful, we will get the following output: Number of points in the coarse grid:          700\n\nProperties of the fine grid:\nNumber of grid points in nperp:                50\nNumber of grid points in npar:                100\nMaximum Pperp:                         2.9663E+00\nMinimum Pperp:                         0.0000E+00\nMaximum Ppar:                          3.0082E+00\nMinimum Ppar:                         -3.0082E+00\n\nWriting output to file test_interp.in.array At the same time, the folder now includes a new file test_interp.in.array , which includes the interpolated f0-table in the correct format for ALPS: 0.0000000000000000 - 3.0081663100000000 2.5699885852486149E-005 0.0000000000000000 - 2.9480029837999999 3.4671386965111912E-005 0.0000000000000000 - 2.8878396575999998 4.7473668668616121E-005 0.0000000000000000 - 2.8276763314000002 6.5558031421796410E-005 0.0000000000000000 - 2.7675130052000001 9.0732738996456109E-005 0.0000000000000000 - 2.7073496790000000 1.2528393376824723E-004 0.0000000000000000 - 2.6471863527999999 1.7212176003060674E-004 0.0000000000000000 - 2.5870230265999998 2.3495069283188794E-004 0.0000000000000000 - 2.5268597004000002 3.1846300082066743E-004 ... ... ... You can copy this file over into the ./distribution folder and give it the appropriate naming with the convention given above. Then ALPS can use this interpolated file for the calculation. 6. Using analytical expressions for the background distribution In some instances, you may have an analytical expression for the distribution function (which is not covered by generate_distribution ) that you want to run through ALPS. For example, you may want to analyse the instability of a model distribution that was derived analytical from a model. ALPS can also do this. For such a calculation, we need to define the background distribution in the code directly. Let's open the file ./distribution/distribution_analyt.f90 . This is a Fortran file that allows you to feed an analytical expression for the background distribution into ALPS. If you have the standard version of ALPS from the repository, this f90 file already contains some variable declarations and an example case. Let's scroll down to the following part: select case(is)\n\n  case(1) ! Species 1\n\n    ! The example below illustrates how to set up a Maxwellian with beta = 1:\n    beta=1.d0\n    ms=1.d0\n\n    f0=(pi**(-1.5d0) /((ms * beta )* *(3.d0/2.d0) )) * exp( -( ppar* *2/( beta * ms)& + (pperp* *2)/( beta * ms ) ) )\n\n  case(2) ! Species 2\n     ... The different cases here refer to the species. This allows you to use different equations for, say, electrons and protons. Whatever is defined as the variable f0 as a function of the variables pperp and ppar inside these cases defines the f0-table. If you require additional variables or functions to define your model distribution, please feel free to define them locally in this Fortran function. Important : You must ensure that the defined background distribution function is normalised to one. The code doesn't automatically normalise the distribution. However, the ALPS standard output will list the integration of the distribution, so that you can double check. The example above defines a simple Maxwellian for the protons and for the electrons as a simple example. Once you have defined the background distribution in distribution_analyt.f90 , it's important to re-compile the code, so that it includes the defined function: cd ../  \nmake For the next step, we need to create the f0-table based on the defined function. This is done with generate_distribution as for the other analytical cases. We have an example input file ./distribution/test_analytical_dist.in , which does exactly that. For both species, this file defines the distribution type as zero in the lines: distributions=0  !Type of distribution (see documentation) If you set distributions=0 , the function generate_distribution will use the function defined in distribution_analyt.f90 to create an f0-table. Let's run cd ./distribution    \n./generate_distribution test_analytical_dist.in The standard output explains a couple of details, which we had already encountered above. Most importantly, the programme now creates two new files: test_analytical.1.array   \ntest_analytical.2.array These files include the f0-tables according to the analytical function. Now it's important to tell ALPS to use the defined distribution functions. This happens in the ALPS input file. In the folder ./tests , there is an example file called test_analytical.in , which we will use in this example. As expected, it commands ALPS to use the f0-tables that we have just created: arrayName='test_analytical' It also makes sense to use the pre-defined background distribution function from distribution_analyt.f90 also for the analytical continuation. You can achieve this by setting AC_method=0 in the block of the corresponding species. If you set AC_method=0 , the code will look up the function in distribution_analyt.f90 to evaluate the Landau-contour integral. If you now run this test case through mpirun -np 4 ./src/ALPS ./tests/test_analytical.in the code will fully calculate the dispersion relation based on the distribution function defined in distribution_analyt.f90 . A particular strength is that you can use that distribution for the creation of the f0-table, the Landau-contour integral (analytic continuation), or for both. Sometimes, you may only want to use it for the f0-table and rely on ALPS's internal fitting. If that is the case, simply set AC_method=1 and define the fits as usual. At other times, you may only want to use the function from distribution_analyt.f90 as the fit function, but use a different f0-table. In that is the case, point ALPS to your usual f0-table files, but set AC_method=0 . 7. Running bi-Maxwellian species In some instances, it may be useful to assume a Maxwellian or bi-Maxwellian distribution for one or more species in the system. For example, you may want to calculate the proton susceptibilities based on an f0-table, but you're happy to work with a simple bi-Maxwellian electron population. In that case, ALPS includes an implementation of the NHDS code to accelerate the calculation. ALPS then does not integrate over the bi-Maxwellian distribution explicitly but uses the known analytical approximations. The relevant option for a bi-Maxwellian calculation is the logical flag use_bM in the ALPS input file under the section for the corresponding species. If you set use_bM=T for any species, its contributions to the dielectric tensor will be calculated with the NHDS routines. Also the Landau-contour integration will be done through NHDS. Once use_bM is set to true, ALPS will look for the parameters used to define the bi-Maxwellian properties of the corresponding species. These are given in a species-dependent block in the ALPS input file, which may look like this: !Bi-Maxwellian parameters; for species 1 !Only used if use_bM=T & bM_spec_1 bM_nmaxs = 500 ! Maximum number of resonaces to consider bM_Bessel_zeros = 1 . d - 50 ! Amplitude limit for Bessel function bM_betas = 1 . d0 ! Plasma beta for species 1 bM_alphas = 1 . d0 ! Tperp / Tpar for species 1 bM_pdrifts = 0 . d0 ! Momentum drift , norm . to m_ref v_A , ref / The ALPS code suite includes a test case called ./tests/test_bimax.in that uses the NHDS routines for a quick calculation of the dispersion relation for a bi-Maxwellian plasma. 8. Running cold-plasma species In some instances, it may be useful to evaluate a species with its susceptibility based on the cold-plasma dispersion relation. For example, you may want to calculate the electron susceptibilities based on an f0-table for very-high frequency waves, in which case the ions are at rest and simply serve as a cold, charge-neutralising background. In that case, the ions can be treated as a cold-plasma species. In that case, ALPS uses the cold-plasma capabilities of the NHDS code to accelerate the calculation. ALPS then does not integrate over the distribution explicitly but uses the known analytical approximations for the cold-plasma dispersion relation (including drifts) from the paper by Verscharen & Chandran (ApJ 764, 88, 2013). The cold-plasma calcuation is activated through the flag use_bM in the ALPS input file. It is then required to set the plasma-beta of the species to zero via the parameter bM_betas . If you set\nThe Landau-contour integration is not required in this case. Once use_bM is set to true and bM_betas is set to 0.d0, ALPS will look for the parameters used to define the cold-plasma properties of the corresponding species. These are given in a species-dependent block in the ALPS input file, which may look like this: !Bi-Maxwellian parameters; for species 1 !Only used if use_bM=T & bM_spec_1 bM_nmaxs = 500 ! Maximum number of resonaces to consider bM_Bessel_zeros = 1 . d - 50 ! Amplitude limit for Bessel function bM_betas = 0 . d0 ! Plasma beta for species 1 bM_alphas = 1 . d0 ! Tperp / Tpar for species 1 bM_pdrifts = 0 . d0 ! Momentum drift , norm . to m_ref v_A , ref / The ALPS code suite includes a test case called ./tests/test_cold_plasma.in that uses the NHDS routines for a quick calculation of the dispersion relation for a cold plasma.","tags":"","url":"page/tutorial.html"}]}